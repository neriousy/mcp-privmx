{
  "_meta": {
    "lang": "Swift",
    "name": "PrivMX Endpoint Swift",
    "package": "privmx-endpoint-swift",
    "version": "2.2"
  },
  "core": [
    {
      "content": [
        {
          "description": "Tool for direct requests to PrivMX Bridge.",
          "fields": [],
          "methods": [
            {
              "description": "Makes a direct request to PrivMX Bridge.\nThis function allows you to make direct API requests to PrivMX Bridge with the required authorization and parameters. The response is returned as a string, representing the result of the request.",
              "exceptions": [
                {
                  "code": 0,
                  "description": " - `PrivMXEndpointError.failedRequestingBackend` if the request to the backend fails due to any error from the bridge or incorrect request formatting.\n - Any other unexpected errors that might occur during the execution of the request.\n",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "static",
              "name": "backendRequest(serverUrl:memberToken:method:paramsAsJson:)",
              "params": [
                {
                  "description": "The URL of PrivMX cloud server to which the request will be sent.",
                  "name": "serverUrl",
                  "type": {
                    "name": "std.string",
                    "optional": false
                  }
                },
                {
                  "description": "The authorization token for the member making the request.",
                  "name": "memberToken",
                  "type": {
                    "name": "std.string",
                    "optional": false
                  }
                },
                {
                  "description": "The API method or endpoint to be called on PrivMX Bridge.",
                  "name": "method",
                  "type": {
                    "name": "std.string",
                    "optional": false
                  }
                },
                {
                  "description": "The parameters for the request, formatted as a JSON string.",
                  "name": "paramsAsJson",
                  "type": {
                    "name": "std.string",
                    "optional": false
                  }
                }
              ],
              "returns": [
                {
                  "description": "\n\n",
                  "type": {
                    "name": "std.string",
                    "optional": false
                  }
                }
              ],
              "snippet": "public static func backendRequest(\n\tserverUrl: std.string,\n\tmemberToken: std.string,\n\tmethod: std.string,\n\tparamsAsJson: std.string\n) throws -> std.string",
              "type": "method"
            },
            {
              "description": "Makes a direct request to PrivMX Bridge.\nThis function allows you to make direct API requests to PrivMX Bridge with the required parameters. The response is returned as a string, representing the result of the request.",
              "exceptions": [
                {
                  "code": 0,
                  "description": " - `PrivMXEndpointError.failedRequestingBackend` if the request to the backend fails due to any error from the bridge or incorrect request formatting.\n - Any other unexpected errors that might occur during the execution of the request.\n",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "static",
              "name": "backendRequest(serverUrl:method:paramsAsJson:)",
              "params": [
                {
                  "description": "The URL of PrivMX cloud server to which the request will be sent.",
                  "name": "serverUrl",
                  "type": {
                    "name": "std.string",
                    "optional": false
                  }
                },
                {
                  "description": "The API method or endpoint to be called on PrivMX Bridge.",
                  "name": "method",
                  "type": {
                    "name": "std.string",
                    "optional": false
                  }
                },
                {
                  "description": "The parameters for the request, formatted as a JSON string.",
                  "name": "paramsAsJson",
                  "type": {
                    "name": "std.string",
                    "optional": false
                  }
                }
              ],
              "returns": [
                {
                  "description": "\n\n",
                  "type": {
                    "name": "std.string",
                    "optional": false
                  }
                }
              ],
              "snippet": "public static func backendRequest(\n\tserverUrl: std.string,\n\tmethod: std.string,\n\tparamsAsJson: std.string\n) throws -> std.string",
              "type": "method"
            },
            {
              "description": "Sends a request to PrivMX Bridge API using pair of API KEY ID and API KEY SECRET for authorization.",
              "methodType": "static",
              "name": "backendRequest(serverUrl:apiKeyId:apiKeySecret:mode:method:paramsAsJson:)",
              "params": [
                {
                  "description": "PrivMX Bridge server URL",
                  "name": "serverUrl",
                  "type": {
                    "name": "std.string",
                    "optional": false
                  }
                },
                {
                  "description": "API KEY ID (see PrivMX Bridge API for more details)",
                  "name": "apiKeyId",
                  "type": {
                    "name": "std.string",
                    "optional": false
                  }
                },
                {
                  "description": "API KEY SECRET (see PrivMX Bridge API for more details)",
                  "name": "apiKeySecret",
                  "type": {
                    "name": "std.string",
                    "optional": false
                  }
                },
                {
                  "description": "allows you to set whether the request should be signed (mode = 1) or plain (mode = 0)",
                  "name": "mode",
                  "type": {
                    "name": "Int64",
                    "optional": false
                  }
                },
                {
                  "description": "API method to call",
                  "name": "method",
                  "type": {
                    "name": "std.string",
                    "optional": false
                  }
                },
                {
                  "description": "API methodâ€™s parameters in JSON format",
                  "name": "paramsAsJson",
                  "type": {
                    "name": "std.string",
                    "optional": false
                  }
                }
              ],
              "returns": [
                {
                  "description": "A string containing the response from PrivMX Bridge, typically in JSON format.\n",
                  "type": {
                    "name": "std.string",
                    "optional": false
                  }
                }
              ],
              "snippet": "public static func backendRequest(\n\tserverUrl: std.string,\n\tapiKeyId: std.string,\n\tapiKeySecret: std.string,\n\tmode: Int64,\n\tmethod: std.string,\n\tparamsAsJson: std.string\n) throws -> std.string",
              "type": "method"
            }
          ],
          "name": "BackendRequester",
          "type": "enum"
        }
      ],
      "title": "BackendRequester"
    },
    {
      "content": [
        {
          "description": "Swift wrapper for `privmx.NativeConnectionWrapper`, used to establish and manage secure connections with PrivMX platform.",
          "fields": [],
          "methods": [
            {
              "description": "Sets the path to the .pem file containing the necessary certificates for the connection, which are dependent on your PrivMX Bridge setup.\nThis method must be called before attempting to establish a connection to ensure the certificates are properly set.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "`PrivMXEndpointError.failedSettingCerts` if setting the certificate path fails.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "static",
              "name": "setCertsPath(_:)",
              "params": [
                {
                  "description": "The path to the .pem file containing the certificates.",
                  "name": "path",
                  "type": {
                    "name": "std.string",
                    "optional": false
                  }
                }
              ],
              "snippet": "public static func setCertsPath(\n\t_ path: std.string\n) throws -> Void",
              "type": "method"
            },
            {
              "description": "Creates a new connection instance to PrivMX platform using a private key.\nThe path to the certificates must be set beforehand using `setCertsPath()`. This connection is used to interact with secured operations such as Inboxes, Threads, and Stores.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "`PrivMXEndpointError.failedConnecting` if establishing the connection fails.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "static",
              "name": "connect(userPrivKey:solutionId:bridgeUrl:)",
              "params": [
                {
                  "description": "The userâ€™s private key in WIF format, required for authentication.",
                  "name": "userPrivKey",
                  "type": {
                    "name": "std.string",
                    "optional": false
                  }
                },
                {
                  "description": "The ID of the Solution that the connection targets.",
                  "name": "solutionId",
                  "type": {
                    "name": "std.string",
                    "optional": false
                  }
                },
                {
                  "description": "The URL of PrivMX platform endpoint.",
                  "name": "bridgeUrl",
                  "type": {
                    "name": "std.string",
                    "optional": false
                  }
                }
              ],
              "returns": [
                {
                  "description": "A `Connection` instance that can be used for further operations.\n",
                  "type": {
                    "name": "Connection",
                    "optional": false
                  }
                }
              ],
              "snippet": "public static func connect(\n\tuserPrivKey: std.string,\n\tsolutionId: std.string,\n\tbridgeUrl: std.string\n) throws -> Connection",
              "type": "method"
            },
            {
              "description": "Creates a new connection instance to PrivMX platform using a private key.\nThe path to the certificates must be set beforehand using `setCertsPath()`. This connection is used to interact with secured operations such as Inboxes, Threads, and Stores.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "`PrivMXEndpointError.failedConnecting` if establishing the connection fails.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "static",
              "name": "connect(userPrivKey:solutionId:platformUrl:)",
              "params": [
                {
                  "description": "The userâ€™s private key in WIF format, required for authentication.",
                  "name": "userPrivKey",
                  "type": {
                    "name": "std.string",
                    "optional": false
                  }
                },
                {
                  "description": "The ID of the Solution that the connection targets.",
                  "name": "solutionId",
                  "type": {
                    "name": "std.string",
                    "optional": false
                  }
                },
                {
                  "description": "The URL of PrivMX platform endpoint.",
                  "name": "platformUrl",
                  "type": {
                    "name": "std.string",
                    "optional": false
                  }
                }
              ],
              "returns": [
                {
                  "description": "A `Connection` instance that can be used for further operations.\n",
                  "type": {
                    "name": "Connection",
                    "optional": false
                  }
                }
              ],
              "snippet": "public static func connect(\n\tuserPrivKey: std.string,\n\tsolutionId: std.string,\n\tplatformUrl: std.string\n) throws -> Connection",
              "type": "method"
            },
            {
              "description": "Creates a new public connection to PrivMX platform.\nThe path to the certificates must be set beforehand using `setCertsPath()`. This type of connection is primarily used for public operations, such as inbound Inbox traffic, where authentication is not required.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "`PrivMXEndpointError.failedConnecting` if establishing the connection fails.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "static",
              "name": "connectPublic(solutionId:bridgeUrl:)",
              "params": [
                {
                  "description": "The ID of the Solution that the connection targets.",
                  "name": "solutionId",
                  "type": {
                    "name": "std.string",
                    "optional": false
                  }
                },
                {
                  "description": "The URL of PrivMX platform endpoint.",
                  "name": "bridgeUrl",
                  "type": {
                    "name": "std.string",
                    "optional": false
                  }
                }
              ],
              "returns": [
                {
                  "description": "A public `Connection` instance that can be used for non-authenticated operations.\n",
                  "type": {
                    "name": "Connection",
                    "optional": false
                  }
                }
              ],
              "snippet": "public static func connectPublic(\n\tsolutionId: std.string,\n\tbridgeUrl: std.string\n) throws -> Connection",
              "type": "method"
            },
            {
              "description": "Creates a new public connection to PrivMX platform.\nThe path to the certificates must be set beforehand using `setCertsPath()`. This type of connection is primarily used for public operations, such as inbound Inbox traffic, where authentication is not required.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "`PrivMXEndpointError.failedConnecting` if establishing the connection fails.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "static",
              "name": "connectPublic(solutionId:platformUrl:)",
              "params": [
                {
                  "description": "The ID of the Solution that the connection targets.",
                  "name": "solutionId",
                  "type": {
                    "name": "std.string",
                    "optional": false
                  }
                },
                {
                  "description": "The URL of PrivMX platform endpoint.",
                  "name": "platformUrl",
                  "type": {
                    "name": "std.string",
                    "optional": false
                  }
                }
              ],
              "returns": [
                {
                  "description": "A public `Connection` instance that can be used for non-authenticated operations.\n",
                  "type": {
                    "name": "Connection",
                    "optional": false
                  }
                }
              ],
              "snippet": "public static func connectPublic(\n\tsolutionId: std.string,\n\tplatformUrl: std.string\n) throws -> Connection",
              "type": "method"
            },
            {
              "description": "Retrieves the unique ID of the connection.\nEach connection instance has a unique identifier that can be used to track and manage multiple connections.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "`PrivMXEndpointError.failedGettingConnectionId` if retrieving the connection ID fails.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "method",
              "name": "getConnectionId()",
              "params": [],
              "returns": [
                {
                  "description": "The unique ID of the current connection as an `Int64`.\n",
                  "type": {
                    "name": "Int64",
                    "optional": false
                  }
                }
              ],
              "snippet": "public func getConnectionId(\n) throws -> Int64",
              "type": "method"
            },
            {
              "description": "Disconnects the current connection to PrivMX platform.\nOnce disconnected, the `Connection` instance, along with any associated API instances like `StoreApi` or `ThreadApi`, becomes unusable. It is important to call this method when the connection is no longer needed to free up resources.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "`PrivMXEndpointError.failedDisconnecting` if the disconnection process fails.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "method",
              "name": "disconnect()",
              "params": [],
              "snippet": "public func disconnect(\n) throws -> Void",
              "type": "method"
            },
            {
              "description": "Lists all Contexts available to the currently connected user.\nContexts represent different environments or groups to which the user has access. This method returns a list of these Contexts.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "`PrivMXEndpointError.failedListingContexts` if listing the Contexts fails.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "method",
              "name": "listContexts(query:)",
              "params": [
                {
                  "description": "A `PagingQuery` object that specifies the filtering and pagination options for the query.",
                  "name": "query",
                  "type": {
                    "name": "privmx.endpoint.core.PagingQuery",
                    "optional": false
                  }
                }
              ],
              "returns": [
                {
                  "description": "A `ContextList` structure containing the total number of Contexts and a list of the retrieved Contexts.\n",
                  "type": {
                    "name": "privmx.ContextList",
                    "optional": false
                  }
                }
              ],
              "snippet": "public func listContexts(\n\tquery: privmx.endpoint.core.PagingQuery\n)throws -> privmx.ContextList",
              "type": "method"
            }
          ],
          "name": "Connection",
          "type": "class"
        }
      ],
      "title": "Connection"
    }
  ],
  "crypto": [
    {
      "content": [
        {
          "description": "Swift wrapper for `privmx.NativeCryptoApiWrapper`.\nThis class provides cryptographic functions such as key generation, encryption, and decryption, as well as signing data. It wraps the underlying C++ implementation for use in Swift.",
          "fields": [],
          "methods": [
            {
              "description": "Creates a new `CryptoApi` instance.",
              "methodType": "static",
              "name": "create()",
              "params": [],
              "returns": [
                {
                  "description": "A new `CryptoApi` instance.\n",
                  "type": {
                    "name": "CryptoApi",
                    "optional": false
                  }
                }
              ],
              "snippet": "public static func create(\n) -> CryptoApi",
              "type": "method"
            },
            {
              "description": "Signs the given data using the specified private key.\nThis method takes raw binary data and a WIF (Wallet Import Format) private key to generate a cryptographic signature. The resulting signature can be used to verify the authenticity and integrity of the signed data.",
              "exceptions": [
                {
                  "code": 0,
                  "description": " - `PrivMXEndpointError.failedSigning` if the signing process fails due to an invalid key or data error.\n",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "method",
              "name": "signData(data:privateKey:)",
              "params": [
                {
                  "description": "The binary data to be signed, typically a message or a file.",
                  "name": "data",
                  "type": {
                    "name": "privmx.endpoint.core.Buffer",
                    "optional": false
                  }
                },
                {
                  "description": "The WIF private key used to sign the data.",
                  "name": "privateKey",
                  "type": {
                    "name": "std.string",
                    "optional": false
                  }
                }
              ],
              "returns": [
                {
                  "description": "The cryptographic signature as a binary buffer (`privmx.endpoint.core.Buffer`).\n",
                  "type": {
                    "name": "privmx.endpoint.core.Buffer",
                    "optional": false
                  }
                }
              ],
              "snippet": "public func signData(\n\tdata: privmx.endpoint.core.Buffer,\n\tprivateKey: std.string\n) throws -> privmx.endpoint.core.Buffer",
              "type": "method"
            },
            {
              "description": "Validate a signature of data using given key.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "`PrivMXEndpointError.failedVerifyingSignature` if an verification process fails.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "method",
              "name": "verifySignature(data:signature:publicKey:)",
              "params": [
                {
                  "description": "buffer containing the data signature of which is being verified.",
                  "name": "data",
                  "type": {
                    "name": "privmx.endpoint.core.Buffer",
                    "optional": false
                  }
                },
                {
                  "description": "signature to be verified.",
                  "name": "signature",
                  "type": {
                    "name": "privmx.endpoint.core.Buffer",
                    "optional": false
                  }
                },
                {
                  "description": "public ECC key in BASE58DER format used to validate data.",
                  "name": "publicKey",
                  "type": {
                    "name": "std.string",
                    "optional": false
                  }
                }
              ],
              "returns": [
                {
                  "description": "data validation result.\n",
                  "type": {
                    "name": "Bool",
                    "optional": false
                  }
                }
              ],
              "snippet": "public func verifySignature(\n\tdata: privmx.endpoint.core.Buffer,\n\tsignature: privmx.endpoint.core.Buffer,\n\tpublicKey: std.string\n) throws -> Bool",
              "type": "method"
            },
            {
              "description": "Generates a new symmetric key (AES-256) for encryption and decryption.\nSymmetric encryption uses the same key for both encryption and decryption, and AES-256 is a widely adopted standard for secure encryption. This method generates a 256-bit key which can be used for encrypting sensitive data.\n This is typically used when you need to secure data in transit or at rest. The same key will be required to decrypt the data that was encrypted with it.",
              "exceptions": [
                {
                  "code": 0,
                  "description": " - `PrivMXEndpointError.failedGeneratingSymmetricKey` if there is an issue generating the key, for instance due to insufficient entropy or a system-level error.\n",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "method",
              "name": "generateKeySymmetric()",
              "params": [],
              "returns": [
                {
                  "description": "A 256-bit symmetric key as a binary buffer (`privmx.endpoint.core.Buffer`).\n",
                  "type": {
                    "name": "privmx.endpoint.core.Buffer",
                    "optional": false
                  }
                }
              ],
              "snippet": "public func generateKeySymmetric(\n) throws -> privmx.endpoint.core.Buffer",
              "type": "method"
            },
            {
              "description": "Generates a new private key in WIF (Wallet Import Format).\nThe private key can be used for various cryptographic operations such as signing data, generating public keys, and encrypting sensitive information. You can optionally provide a seed to generate a deterministic key, or omit the seed to generate a random key. Here it can be used for identifying and authorizing User (after previous adding its Public Key to PrivMX Bridge)\n Private keys are used in both asymmetric encryption and signing operations. This method is useful when you need a fresh key pair for a new user or system process.\n Private keys should be stored securely, ideally in an encrypted keystore or hardware security module (HSM).",
              "exceptions": [
                {
                  "code": 0,
                  "description": " - `PrivMXEndpointError.failedGeneratingPrivKey` if the key generation fails, potentially due to a system error or invalid seed.\n",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "method",
              "name": "generatePrivateKey(randomSeed:)",
              "params": [
                {
                  "description": "An optional seed to generate a deterministic private key. If `nil` is provided, a random key will be generated.",
                  "name": "randomSeed",
                  "type": {
                    "name": "std.string?",
                    "optional": false
                  }
                }
              ],
              "returns": [
                {
                  "description": "The generated private key in WIF format.\n",
                  "type": {
                    "name": "std.string",
                    "optional": false
                  }
                }
              ],
              "snippet": "public func generatePrivateKey(\n\trandomSeed: std.string?\n) throws -> std.string",
              "type": "method"
            },
            {
              "description": "Derives a private key from a given password and salt using a key derivation function.\nThis method generates a private key based on a user-provided password and salt. The combination of the two ensures that the key is unique for each user and is always generated deterministically, and the salt prevents dictionary attacks.\n Useful in scenarios where users are authenticated via passwords, but cryptographic operations require a private key. By deriving the key from a password, you avoid directly storing or transferring the private key.\n Passwords should never be stored or transmitted in plain text. Ensure that the salt is unique and sufficiently random to prevent predictable key generation.",
              "exceptions": [
                {
                  "code": 0,
                  "description": " - `PrivMXEndpointError.failedGeneratingPrivKey` if the key derivation fails, such as when using invalid input or a weak password.\n",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "method",
              "name": "derivePrivateKey(password:salt:)",
              "params": [
                {
                  "description": "The base string (usually a user password) used for deriving the key.",
                  "name": "password",
                  "type": {
                    "name": "std.string",
                    "optional": false
                  }
                },
                {
                  "description": "The salt value that makes the derived key unique, even if the same password is used by multiple users.",
                  "name": "salt",
                  "type": {
                    "name": "std.string",
                    "optional": false
                  }
                }
              ],
              "returns": [
                {
                  "description": "The derived private key in WIF format.\n",
                  "type": {
                    "name": "std.string",
                    "optional": false
                  }
                }
              ],
              "snippet": "public func derivePrivateKey(\n\tpassword: std.string,\n\tsalt: std.string\n) throws -> std.string",
              "type": "method"
            },
            {
              "description": "Derives a private key from a given password and salt using a key derivation function.\nThis method generates a private key based on a user-provided password and salt. The combination of the two ensures that the key is unique for each user and is always generated deterministically, and the salt prevents dictionary attacks.\n Useful in scenarios where users are authenticated via passwords, but cryptographic operations require a private key. By deriving the key from a password, you avoid directly storing or transferring the private key.\n Passwords should never be stored or transmitted in plain text. Ensure that the salt is unique and sufficiently random to prevent predictable key generation.",
              "exceptions": [
                {
                  "code": 0,
                  "description": " - `PrivMXEndpointError.failedGeneratingPrivKey` if the key derivation fails, such as when using invalid input or a weak password.\n",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "method",
              "name": "derivePrivateKey2(password:salt:)",
              "params": [
                {
                  "description": "The base string (usually a user password) used for deriving the key.",
                  "name": "password",
                  "type": {
                    "name": "std.string",
                    "optional": false
                  }
                },
                {
                  "description": "The salt value that makes the derived key unique, even if the same password is used by multiple users.",
                  "name": "salt",
                  "type": {
                    "name": "std.string",
                    "optional": false
                  }
                }
              ],
              "returns": [
                {
                  "description": "The derived private key in WIF format.\n",
                  "type": {
                    "name": "std.string",
                    "optional": false
                  }
                }
              ],
              "snippet": "public func derivePrivateKey2(\n\tpassword: std.string,\n\tsalt: std.string\n) throws -> std.string",
              "type": "method"
            },
            {
              "description": "Derives a public key from the given private key.\nIn public-key cryptography, a public key is derived from a private key and can be shared publicly to allow others to verify signatures or encrypt messages for the private key holder. The private key remains secret.\n This function is used to generate a public key for a user or system after they have generated or provided a private key. Public keys have to be registered in PrivMX Bridge for encryption or verification. This should be done via Bridge REST API.",
              "exceptions": [
                {
                  "code": 0,
                  "description": " - `PrivMXEndpointError.failedGeneratingPubKey` if the derivation process fails, such as if the private key is invalid.\n",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "method",
              "name": "derivePublicKey(privKey:)",
              "params": [
                {
                  "description": "The WIF private key from which the public key will be derived.",
                  "name": "privKey",
                  "type": {
                    "name": "std.string",
                    "optional": false
                  }
                }
              ],
              "returns": [
                {
                  "description": "The derived public key in WIF format.\n",
                  "type": {
                    "name": "std.string",
                    "optional": false
                  }
                }
              ],
              "snippet": "public func derivePublicKey(\n\tprivKey: std.string\n) throws -> std.string",
              "type": "method"
            },
            {
              "description": "Encrypts the given data using AES-256 symmetric encryption.\nThis method encrypts the data using the provided symmetric key. Symmetric encryption is fast and suitable for large data volumes, such as files or communication payloads.\n This function is used to securely store or transmit data, ensuring that only those with the correct key can decrypt and access the original content.",
              "exceptions": [
                {
                  "code": 0,
                  "description": " - `PrivMXEndpointError.failedEncrypting` if the encryption process fails, typically due to an invalid key or data format.\n",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "method",
              "name": "encryptDataSymmetric(data:symmetricKey:)",
              "params": [
                {
                  "description": "The data to be encrypted.",
                  "name": "data",
                  "type": {
                    "name": "privmx.endpoint.core.Buffer",
                    "optional": false
                  }
                },
                {
                  "description": "The 256-bit key used for encryption (must be the same key used for decryption).",
                  "name": "symmetricKey",
                  "type": {
                    "name": "privmx.endpoint.core.Buffer",
                    "optional": false
                  }
                }
              ],
              "returns": [
                {
                  "description": "The encrypted data as a binary buffer.\n",
                  "type": {
                    "name": "privmx.endpoint.core.Buffer",
                    "optional": false
                  }
                }
              ],
              "snippet": "public func encryptDataSymmetric(\n\tdata: privmx.endpoint.core.Buffer,\n\tsymmetricKey: privmx.endpoint.core.Buffer\n) throws -> privmx.endpoint.core.Buffer",
              "type": "method"
            },
            {
              "description": "Decrypts the given data using AES-256 symmetric encryption.\nThis method decrypts data that was previously encrypted using the same symmetric key. If the correct key is not provided, the decryption will fail, resulting in corrupted or unreadable data.\n Decryption is used to retrieve the original content that was securely encrypted, ensuring the dataâ€™s confidentiality and integrity.",
              "exceptions": [
                {
                  "code": 0,
                  "description": " - `PrivMXEndpointError.failedDecrypting` if the decryption process fails, often due to an incorrect key or tampered data.\n",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "method",
              "name": "decryptDataSymmetric(data:symmetricKey:)",
              "params": [
                {
                  "description": "The encrypted data to be decrypted.",
                  "name": "data",
                  "type": {
                    "name": "privmx.endpoint.core.Buffer",
                    "optional": false
                  }
                },
                {
                  "description": "The 256-bit key that was used for encryption (must match the key used during encryption).",
                  "name": "symmetricKey",
                  "type": {
                    "name": "privmx.endpoint.core.Buffer",
                    "optional": false
                  }
                }
              ],
              "returns": [
                {
                  "description": "The decrypted data as a binary buffer.\n",
                  "type": {
                    "name": "privmx.endpoint.core.Buffer",
                    "optional": false
                  }
                }
              ],
              "snippet": "public func decryptDataSymmetric(\n\tdata: privmx.endpoint.core.Buffer,\n\tsymmetricKey: privmx.endpoint.core.Buffer\n) throws -> privmx.endpoint.core.Buffer",
              "type": "method"
            },
            {
              "description": "Converts a PEM-formatted key to WIF (Wallet Import Format).\nThis function converts keys that are in the PEM format, commonly used in SSL certificates and other cryptographic contexts, to WIF format, which is more commonly used in wallet and blockchain-based systems.\n Useful when migrating keys from a PEM-based system to a WIF-compatible system, such as moving from an SSL-based infrastructure to a blockchain-based system.",
              "exceptions": [
                {
                  "code": 0,
                  "description": " - `PrivMXEndpointError.failedConvertingKeyToWIF` if the conversion fails due to an invalid key or format.\n",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "method",
              "name": "convertPEMKeyToWIFKey(pemKey:)",
              "params": [
                {
                  "description": "The key in PEM format to be converted.",
                  "name": "pemKey",
                  "type": {
                    "name": "std.string",
                    "optional": false
                  }
                }
              ],
              "returns": [
                {
                  "description": "The converted key in WIF format.\n",
                  "type": {
                    "name": "std.string",
                    "optional": false
                  }
                }
              ],
              "snippet": "public func convertPEMKeyToWIFKey(\n\tpemKey: std.string\n)throws -> std.string",
              "type": "method"
            }
          ],
          "name": "CryptoApi",
          "type": "class"
        }
      ],
      "title": "CryptoApi"
    }
  ],
  "errors": [
    {
      "content": [
        {
          "description": "Errors thrown by PrivMX Endpoint Swift.\nCases correspond to methods in which rthe error happened. Each case has `privmx.InternalError` as associated value, which holds data about the error.",
          "fields": [
            {
              "description": "Represents failure unrelated to methods in PrivmxEndpointSwift package",
              "name": "otherFailure(_:)",
              "snippet": "case otherFailure(privmx.InternalError)",
              "type": {
                "name": "Enum Case",
                "optional": false
              }
            },
            {
              "description": "Failed to get Connection ID",
              "name": "failedGettingConnectionId(_:)",
              "snippet": "case failedGettingConnectionId(privmx.InternalError)",
              "type": {
                "name": "Enum Case",
                "optional": false
              }
            },
            {
              "description": "Failed to generate Symmetric Key",
              "name": "failedGeneratingSymmetricKey(_:)",
              "snippet": "case failedGeneratingSymmetricKey(privmx.InternalError)",
              "type": {
                "name": "Enum Case",
                "optional": false
              }
            },
            {
              "description": "Failed to encrypt",
              "name": "failedEncrypting(_:)",
              "snippet": "case failedEncrypting(privmx.InternalError)",
              "type": {
                "name": "Enum Case",
                "optional": false
              }
            },
            {
              "description": "Failed to decrypt",
              "name": "failedDecrypting(_:)",
              "snippet": "case failedDecrypting(privmx.InternalError)",
              "type": {
                "name": "Enum Case",
                "optional": false
              }
            },
            {
              "description": "Failed to sign",
              "name": "failedSigning(_:)",
              "snippet": "case failedSigning(privmx.InternalError)",
              "type": {
                "name": "Enum Case",
                "optional": false
              }
            },
            {
              "description": "Failed to verify Signature",
              "name": "failedVerifyingSignature(_:)",
              "snippet": "case failedVerifyingSignature(privmx.InternalError)",
              "type": {
                "name": "Enum Case",
                "optional": false
              }
            },
            {
              "description": "Failed to create a Public Key",
              "name": "failedGeneratingPubKey(_:)",
              "snippet": "case failedGeneratingPubKey(privmx.InternalError)",
              "type": {
                "name": "Enum Case",
                "optional": false
              }
            },
            {
              "description": "Failed to create a Private Key",
              "name": "failedGeneratingPrivKey(_:)",
              "snippet": "case failedGeneratingPrivKey(privmx.InternalError)",
              "type": {
                "name": "Enum Case",
                "optional": false
              }
            },
            {
              "description": "Failed to convert a Key to WIF",
              "name": "failedConvertingKeyToWIF(_:)",
              "snippet": "case failedConvertingKeyToWIF(privmx.InternalError)",
              "type": {
                "name": "Enum Case",
                "optional": false
              }
            },
            {
              "description": "Failed to connect",
              "name": "failedConnecting(_:)",
              "snippet": "case failedConnecting(privmx.InternalError)",
              "type": {
                "name": "Enum Case",
                "optional": false
              }
            },
            {
              "description": "Failed to disconnect",
              "name": "failedDisconnecting(_:)",
              "snippet": "case failedDisconnecting(privmx.InternalError)",
              "type": {
                "name": "Enum Case",
                "optional": false
              }
            },
            {
              "description": "Failed to list Contexts",
              "name": "failedListingContexts(_:)",
              "snippet": "case failedListingContexts(privmx.InternalError)",
              "type": {
                "name": "Enum Case",
                "optional": false
              }
            },
            {
              "description": "Failed to instantiate `ThreadApi`",
              "name": "failedInstantiatingThreadApi(_:)",
              "snippet": "case failedInstantiatingThreadApi(privmx.InternalError)",
              "type": {
                "name": "Enum Case",
                "optional": false
              }
            },
            {
              "description": "Failed to create a Thread",
              "name": "failedCreatingThread(_:)",
              "snippet": "case failedCreatingThread(privmx.InternalError)",
              "type": {
                "name": "Enum Case",
                "optional": false
              }
            },
            {
              "description": "Failed to get a Thread",
              "name": "failedGettingThread(_:)",
              "snippet": "case failedGettingThread(privmx.InternalError)",
              "type": {
                "name": "Enum Case",
                "optional": false
              }
            },
            {
              "description": "Failed to list Threads",
              "name": "failedListingThreads(_:)",
              "snippet": "case failedListingThreads(privmx.InternalError)",
              "type": {
                "name": "Enum Case",
                "optional": false
              }
            },
            {
              "description": "Failed to get a Message",
              "name": "failedGettingMessage(_:)",
              "snippet": "case failedGettingMessage(privmx.InternalError)",
              "type": {
                "name": "Enum Case",
                "optional": false
              }
            },
            {
              "description": "Failed to list Messages",
              "name": "failedListingMessages(_:)",
              "snippet": "case failedListingMessages(privmx.InternalError)",
              "type": {
                "name": "Enum Case",
                "optional": false
              }
            },
            {
              "description": "Failed to create a Message",
              "name": "failedCreatingMessage(_:)",
              "snippet": "case failedCreatingMessage(privmx.InternalError)",
              "type": {
                "name": "Enum Case",
                "optional": false
              }
            },
            {
              "description": "Failed to update a Thread",
              "name": "failedUpdatingThread(_:)",
              "snippet": "case failedUpdatingThread(privmx.InternalError)",
              "type": {
                "name": "Enum Case",
                "optional": false
              }
            },
            {
              "description": "Failed to update a Mesage",
              "name": "failedUpdatingMessage(_:)",
              "snippet": "case failedUpdatingMessage(privmx.InternalError)",
              "type": {
                "name": "Enum Case",
                "optional": false
              }
            },
            {
              "description": "Failed to instantiate `StoreApi`",
              "name": "failedInstantiatingStoreApi(_:)",
              "snippet": "case failedInstantiatingStoreApi(privmx.InternalError)",
              "type": {
                "name": "Enum Case",
                "optional": false
              }
            },
            {
              "description": "Failed to list Stores",
              "name": "failedListingStores(_:)",
              "snippet": "case failedListingStores(privmx.InternalError)",
              "type": {
                "name": "Enum Case",
                "optional": false
              }
            },
            {
              "description": "Failed to get a Store",
              "name": "failedGettingStore(_:)",
              "snippet": "case failedGettingStore(privmx.InternalError)",
              "type": {
                "name": "Enum Case",
                "optional": false
              }
            },
            {
              "description": "Failed to create a Store",
              "name": "failedCreatingStore(_:)",
              "snippet": "case failedCreatingStore(privmx.InternalError)",
              "type": {
                "name": "Enum Case",
                "optional": false
              }
            },
            {
              "description": "Failed to update a Store",
              "name": "failedUpdatingStore(_:)",
              "snippet": "case failedUpdatingStore(privmx.InternalError)",
              "type": {
                "name": "Enum Case",
                "optional": false
              }
            },
            {
              "description": "Failed to get a File",
              "name": "failedGettingFile(_:)",
              "snippet": "case failedGettingFile(privmx.InternalError)",
              "type": {
                "name": "Enum Case",
                "optional": false
              }
            },
            {
              "description": "Failed to list Files",
              "name": "failedListingFiles(_:)",
              "snippet": "case failedListingFiles(privmx.InternalError)",
              "type": {
                "name": "Enum Case",
                "optional": false
              }
            },
            {
              "description": "Failed to create a File",
              "name": "failedCreatingFile(_:)",
              "snippet": "case failedCreatingFile(privmx.InternalError)",
              "type": {
                "name": "Enum Case",
                "optional": false
              }
            },
            {
              "description": "Failed to update a File",
              "name": "failedUpdatingFile(_:)",
              "snippet": "case failedUpdatingFile(privmx.InternalError)",
              "type": {
                "name": "Enum Case",
                "optional": false
              }
            },
            {
              "description": "Failed to open a File",
              "name": "failedOpeningFile(_:)",
              "snippet": "case failedOpeningFile(privmx.InternalError)",
              "type": {
                "name": "Enum Case",
                "optional": false
              }
            },
            {
              "description": "Failed to read from a File",
              "name": "failedReadingFromFile(_:)",
              "snippet": "case failedReadingFromFile(privmx.InternalError)",
              "type": {
                "name": "Enum Case",
                "optional": false
              }
            },
            {
              "description": "Failed to seek in a File",
              "name": "failedSeekingInFile(_:)",
              "snippet": "case failedSeekingInFile(privmx.InternalError)",
              "type": {
                "name": "Enum Case",
                "optional": false
              }
            },
            {
              "description": "Failed to write to a File",
              "name": "failedWritingToFile(_:)",
              "snippet": "case failedWritingToFile(privmx.InternalError)",
              "type": {
                "name": "Enum Case",
                "optional": false
              }
            },
            {
              "description": "Failed to close a File",
              "name": "failedClosingFile(_:)",
              "snippet": "case failedClosingFile(privmx.InternalError)",
              "type": {
                "name": "Enum Case",
                "optional": false
              }
            },
            {
              "description": "Failed to delete a File",
              "name": "failedDeletingFile(_:)",
              "snippet": "case failedDeletingFile(privmx.InternalError)",
              "type": {
                "name": "Enum Case",
                "optional": false
              }
            },
            {
              "description": "Failed to instantiate `InboxApi`",
              "name": "failedInstantiatingInboxApi(_:)",
              "snippet": "case failedInstantiatingInboxApi(privmx.InternalError)",
              "type": {
                "name": "Enum Case",
                "optional": false
              }
            },
            {
              "description": "Failed to create an Inbox",
              "name": "failedCreatingInbox(_:)",
              "snippet": "case failedCreatingInbox(privmx.InternalError)",
              "type": {
                "name": "Enum Case",
                "optional": false
              }
            },
            {
              "description": "Failed to update an Inbox",
              "name": "failedUpdatingInbox(_:)",
              "snippet": "case failedUpdatingInbox(privmx.InternalError)",
              "type": {
                "name": "Enum Case",
                "optional": false
              }
            },
            {
              "description": "Failed to delete an Inbox",
              "name": "failedDeletingInbox(_:)",
              "snippet": "case failedDeletingInbox(privmx.InternalError)",
              "type": {
                "name": "Enum Case",
                "optional": false
              }
            },
            {
              "description": "Failed to get an Inbox",
              "name": "failedGettingInbox(_:)",
              "snippet": "case failedGettingInbox(privmx.InternalError)",
              "type": {
                "name": "Enum Case",
                "optional": false
              }
            },
            {
              "description": "Failed to get a Public View of an Inbox",
              "name": "failedGettingInboxPublicView(_:)",
              "snippet": "case failedGettingInboxPublicView(privmx.InternalError)",
              "type": {
                "name": "Enum Case",
                "optional": false
              }
            },
            {
              "description": "Failed to list Inboxes",
              "name": "failedListingInboxes(_:)",
              "snippet": "case failedListingInboxes(privmx.InternalError)",
              "type": {
                "name": "Enum Case",
                "optional": false
              }
            },
            {
              "description": "Failed to prepare an Entry",
              "name": "failedPreparingEntry(_:)",
              "snippet": "case failedPreparingEntry(privmx.InternalError)",
              "type": {
                "name": "Enum Case",
                "optional": false
              }
            },
            {
              "description": "Failed to send an Entry",
              "name": "failedSendingEntry(_:)",
              "snippet": "case failedSendingEntry(privmx.InternalError)",
              "type": {
                "name": "Enum Case",
                "optional": false
              }
            },
            {
              "description": "Failed to read an Entry",
              "name": "failedReadingEntry(_:)",
              "snippet": "case failedReadingEntry(privmx.InternalError)",
              "type": {
                "name": "Enum Case",
                "optional": false
              }
            },
            {
              "description": "Failed to delete an Entry",
              "name": "failedDeletingEntry(_:)",
              "snippet": "case failedDeletingEntry(privmx.InternalError)",
              "type": {
                "name": "Enum Case",
                "optional": false
              }
            },
            {
              "description": "Failed to list Entries",
              "name": "failedListingEntries(_:)",
              "snippet": "case failedListingEntries(privmx.InternalError)",
              "type": {
                "name": "Enum Case",
                "optional": false
              }
            },
            {
              "description": "Failed to create a File Handle",
              "name": "failedCreatingFileHandle(_:)",
              "snippet": "case failedCreatingFileHandle(privmx.InternalError)",
              "type": {
                "name": "Enum Case",
                "optional": false
              }
            },
            {
              "description": "Failed to wait for an Event",
              "name": "failedWaitingForEvent(_:)",
              "snippet": "case failedWaitingForEvent(privmx.InternalError)",
              "type": {
                "name": "Enum Case",
                "optional": false
              }
            },
            {
              "description": "Failed to get an Event",
              "name": "failedGettingEvent(_:)",
              "snippet": "case failedGettingEvent(privmx.InternalError)",
              "type": {
                "name": "Enum Case",
                "optional": false
              }
            },
            {
              "description": "Failed to subscirbe for Events",
              "name": "failedSubscribingForEvents(_:)",
              "snippet": "case failedSubscribingForEvents(privmx.InternalError)",
              "type": {
                "name": "Enum Case",
                "optional": false
              }
            },
            {
              "description": "Failed to unsubscribe from Events",
              "name": "failedUnsubscribingFromEvents(_:)",
              "snippet": "case failedUnsubscribingFromEvents(privmx.InternalError)",
              "type": {
                "name": "Enum Case",
                "optional": false
              }
            },
            {
              "description": "Failed to delete a Thread",
              "name": "failedDeletingThread(_:)",
              "snippet": "case failedDeletingThread(privmx.InternalError)",
              "type": {
                "name": "Enum Case",
                "optional": false
              }
            },
            {
              "description": "Failed to delete a Message",
              "name": "failedDeletingMessage(_:)",
              "snippet": "case failedDeletingMessage(privmx.InternalError)",
              "type": {
                "name": "Enum Case",
                "optional": false
              }
            },
            {
              "description": "Failed to delete a Store",
              "name": "failedDeletingStore(_:)",
              "snippet": "case failedDeletingStore(privmx.InternalError)",
              "type": {
                "name": "Enum Case",
                "optional": false
              }
            },
            {
              "description": "Failed to query and `EventHolder`",
              "name": "failedQueryingEventHolder(_:)",
              "snippet": "case failedQueryingEventHolder(privmx.InternalError)",
              "type": {
                "name": "Enum Case",
                "optional": false
              }
            },
            {
              "description": "Failed to extract an Event from an `EventHolder`",
              "name": "failedExtractingEventFromHolder(_:)",
              "snippet": "case failedExtractingEventFromHolder(privmx.InternalError)",
              "type": {
                "name": "Enum Case",
                "optional": false
              }
            },
            {
              "description": "Failed to set Certificates",
              "name": "failedSettingCerts(_:)",
              "snippet": "case failedSettingCerts(privmx.InternalError)",
              "type": {
                "name": "Enum Case",
                "optional": false
              }
            },
            {
              "description": "Failed to instantiate `EventQueue`",
              "name": "failedInstantiatingEventQueue(_:)",
              "snippet": "case failedInstantiatingEventQueue(privmx.InternalError)",
              "type": {
                "name": "Enum Case",
                "optional": false
              }
            },
            {
              "description": "Failed to emit `LibBreakEvent`",
              "name": "failedEmittingBreakEvent(_:)",
              "snippet": "case failedEmittingBreakEvent(privmx.InternalError)",
              "type": {
                "name": "Enum Case",
                "optional": false
              }
            },
            {
              "description": "Failed to send a request to the backend",
              "name": "failedRequestingBackend(_:)",
              "snippet": "case failedRequestingBackend(privmx.InternalError)",
              "type": {
                "name": "Enum Case",
                "optional": false
              }
            }
          ],
          "methods": [
            {
              "description": "Gets the Message of the error",
              "methodType": "method",
              "name": "getMessage()",
              "params": [],
              "returns": [
                {
                  "description": "Message of the error\n",
                  "type": {
                    "name": "String",
                    "optional": false
                  }
                }
              ],
              "snippet": "public func getMessage() -> String",
              "type": "method"
            },
            {
              "description": "Gets the Code of the error, if it exists",
              "methodType": "method",
              "name": "getCode()",
              "params": [],
              "returns": [
                {
                  "description": "Code of the internal error, or nil\n",
                  "type": {
                    "name": "CUnsignedInt?",
                    "optional": false
                  }
                }
              ],
              "snippet": "public func getCode() -> CUnsignedInt?",
              "type": "method"
            },
            {
              "description": "Gets the Name of the error",
              "methodType": "method",
              "name": "getName()",
              "params": [],
              "returns": [
                {
                  "description": "Name of the error\n",
                  "type": {
                    "name": "String",
                    "optional": false
                  }
                }
              ],
              "snippet": "public func getName() -> String",
              "type": "method"
            },
            {
              "description": "Gets the Description of the error",
              "methodType": "method",
              "name": "getDescription()",
              "params": [],
              "returns": [
                {
                  "description": "Description of the error\n",
                  "type": {
                    "name": "String",
                    "optional": false
                  }
                }
              ],
              "snippet": "public func getDescription() -> String",
              "type": "method"
            }
          ],
          "name": "PrivMXEndpointError",
          "type": "enum"
        }
      ],
      "title": "PrivMXEndpointError"
    }
  ],
  "events": [
    {
      "content": [
        {
          "description": "`EventHandler` is a collection of static methods that provide type-checking and event extraction capabilities for events held within `EventHolder` objects. These methods verify if specific events, such as connection and disconnection events, are contained within an `EventHolder`, and extract the events if present. It acts as a Swift wrapper for PrivMX Core Event handling mechanisms.",
          "fields": [],
          "methods": [
            {
              "description": "Checks if the `EventHolder` contains a `LibConnectedEvent`.\nThis method queries the provided `EventHolder` to determine if it contains an event that corresponds to a `LibConnectedEvent`.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "`PrivMXEndpointError.failedQueryingEventHolder` if an error occurs in the underlying C++ code or another issue arises.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "static",
              "name": "isLibConnectedEvent(eventHolder:)",
              "params": [
                {
                  "description": "The `EventHolder` instance to be queried.",
                  "name": "eventHolder",
                  "type": {
                    "name": "privmx.endpoint.core.EventHolder",
                    "optional": false
                  }
                }
              ],
              "returns": [
                {
                  "description": "`true` if the `EventHolder` contains a `LibConnectedEvent`; otherwise, `false`.\n",
                  "type": {
                    "name": "Bool",
                    "optional": false
                  }
                }
              ],
              "snippet": "public static func isLibConnectedEvent(\n\teventHolder: privmx.endpoint.core.EventHolder\n) throws -> Bool",
              "type": "method"
            },
            {
              "description": "Checks if the `EventHolder` contains a `LibDisconnectedEvent`.\nThis method queries the provided `EventHolder` to determine if it contains an event that corresponds to a `LibDisconnectedEvent`.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "`PrivMXEndpointError.failedQueryingEventHolder` if an error occurs in the underlying C++ code or another issue arises.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "static",
              "name": "isLibDisconnectedEvent(eventHolder:)",
              "params": [
                {
                  "description": "The `EventHolder` instance to be queried.",
                  "name": "eventHolder",
                  "type": {
                    "name": "privmx.endpoint.core.EventHolder",
                    "optional": false
                  }
                }
              ],
              "returns": [
                {
                  "description": "`true` if the `EventHolder` contains a `LibDisconnectedEvent`; otherwise, `false`.\n",
                  "type": {
                    "name": "Bool",
                    "optional": false
                  }
                }
              ],
              "snippet": "public static func isLibDisconnectedEvent(\n\teventHolder: privmx.endpoint.core.EventHolder\n) throws -> Bool",
              "type": "method"
            },
            {
              "description": "Checks if the `EventHolder` contains a `LibPlatformDisconnectedEvent`.\nThis method queries the provided `EventHolder` to determine if it contains an event that corresponds to a `LibPlatformDisconnectedEvent`.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "`PrivMXEndpointError.failedQueryingEventHolder` if an error occurs in the underlying C++ code or another issue arises.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "static",
              "name": "isLibPlatformDisconnectedEvent(eventHolder:)",
              "params": [
                {
                  "description": "The `EventHolder` instance to be queried.",
                  "name": "eventHolder",
                  "type": {
                    "name": "privmx.endpoint.core.EventHolder",
                    "optional": false
                  }
                }
              ],
              "returns": [
                {
                  "description": "`true` if the `EventHolder` contains a `LibPlatformDisconnectedEvent`; otherwise, `false`.\n",
                  "type": {
                    "name": "Bool",
                    "optional": false
                  }
                }
              ],
              "snippet": "public static func isLibPlatformDisconnectedEvent(\n\teventHolder: privmx.endpoint.core.EventHolder\n) throws -> Bool",
              "type": "method"
            },
            {
              "description": "Extracts a `LibConnectedEvent` from the provided `EventHolder`.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "`PrivMXEndpointError.failedExtractingEventFromHolder` if an error occurs while extracting the event.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "static",
              "name": "extractLibConnectedEvent(eventHolder:)",
              "params": [
                {
                  "description": "An `EventHolder` containing a `LibConnectedEvent`.",
                  "name": "eventHolder",
                  "type": {
                    "name": "privmx.endpoint.core.EventHolder",
                    "optional": false
                  }
                }
              ],
              "returns": [
                {
                  "description": "The extracted `LibConnectedEvent`.\n",
                  "type": {
                    "name": "privmx.endpoint.core.LibConnectedEvent",
                    "optional": false
                  }
                }
              ],
              "snippet": "public static func extractLibConnectedEvent(\n\teventHolder: privmx.endpoint.core.EventHolder\n) throws -> privmx.endpoint.core.LibConnectedEvent",
              "type": "method"
            },
            {
              "description": "Extracts a `LibDisconnectedEvent` from the provided `EventHolder`.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "`PrivMXEndpointError.failedExtractingEventFromHolder` if an error occurs while extracting the event.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "static",
              "name": "extractLibDisconnectedEvent(eventHolder:)",
              "params": [
                {
                  "description": "An `EventHolder` containing a `LibDisconnectedEvent`.",
                  "name": "eventHolder",
                  "type": {
                    "name": "privmx.endpoint.core.EventHolder",
                    "optional": false
                  }
                }
              ],
              "returns": [
                {
                  "description": "The extracted `LibDisconnectedEvent`.\n",
                  "type": {
                    "name": "privmx.endpoint.core.LibDisconnectedEvent",
                    "optional": false
                  }
                }
              ],
              "snippet": "public static func extractLibDisconnectedEvent(\n\teventHolder: privmx.endpoint.core.EventHolder\n) throws -> privmx.endpoint.core.LibDisconnectedEvent",
              "type": "method"
            },
            {
              "description": "Extracts a `LibPlatformDisconnectedEvent` from the provided `EventHolder`.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "`PrivMXEndpointError.failedExtractingEventFromHolder` if an error occurs while extracting the event.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "static",
              "name": "extractLibPlatformDisconnectedEvent(eventHolder:)",
              "params": [
                {
                  "description": "An `EventHolder` containing a `LibPlatformDisconnectedEvent`.",
                  "name": "eventHolder",
                  "type": {
                    "name": "privmx.endpoint.core.EventHolder",
                    "optional": false
                  }
                }
              ],
              "returns": [
                {
                  "description": "The extracted `LibPlatformDisconnectedEvent`.\n",
                  "type": {
                    "name": "privmx.endpoint.core.LibPlatformDisconnectedEvent",
                    "optional": false
                  }
                }
              ],
              "snippet": "public static func extractLibPlatformDisconnectedEvent(\n\teventHolder: privmx.endpoint.core.EventHolder\n) throws -> privmx.endpoint.core.LibPlatformDisconnectedEvent",
              "type": "method"
            },
            {
              "description": "Checks if the `EventHolder` contains a `LibBreakEvent`.\nThis method queries the provided `EventHolder` to determine if it contains a `LibBreakEvent`.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "`PrivMXEndpointError.failedExtractingEventFromHolder` if an error occurs in the underlying C++ code or another issue arises.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "static",
              "name": "isLibBreakEvent(eventHolder:)",
              "params": [
                {
                  "description": "The `EventHolder` instance to be queried.",
                  "name": "eventHolder",
                  "type": {
                    "name": "privmx.endpoint.core.EventHolder",
                    "optional": false
                  }
                }
              ],
              "returns": [
                {
                  "description": "`true` if the `EventHolder` contains a `LibBreakEvent`; otherwise, `false`.\n",
                  "type": {
                    "name": "Bool",
                    "optional": false
                  }
                }
              ],
              "snippet": "public static func isLibBreakEvent(\n\teventHolder: privmx.endpoint.core.EventHolder\n) throws -> Bool",
              "type": "method"
            },
            {
              "description": "Extracts a `LibBreakEvent` from the provided `EventHolder`.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "`PrivMXEndpointError.failedExtractingEventFromHolder` if an error occurs while extracting the event.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "static",
              "name": "extractLibBreakEvent(eventHolder:)",
              "params": [
                {
                  "description": "An `EventHolder` containing a `LibBreakEvent`.",
                  "name": "eventHolder",
                  "type": {
                    "name": "privmx.endpoint.core.EventHolder",
                    "optional": false
                  }
                }
              ],
              "returns": [
                {
                  "description": "The extracted `LibBreakEvent`.\n",
                  "type": {
                    "name": "privmx.endpoint.core.LibBreakEvent",
                    "optional": false
                  }
                }
              ],
              "snippet": "public static func extractLibBreakEvent(\n\teventHolder: privmx.endpoint.core.EventHolder\n) throws -> privmx.endpoint.core.LibBreakEvent",
              "type": "method"
            },
            {
              "description": "Checks if the `EventHolder` contains a `StoreCreatedEvent`.\nThis method queries the provided `EventHolder` instance to determine if it holds an event that corresponds to a `StoreCreatedEvent`.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "`PrivMXEndpointError.failedQueryingEventHolder` if an error occurs in querying the event.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "static",
              "name": "isStoreCreatedEvent(eventHolder:)",
              "params": [
                {
                  "description": "The `EventHolder` instance to be queried.",
                  "name": "eventHolder",
                  "type": {
                    "name": "privmx.endpoint.core.EventHolder",
                    "optional": false
                  }
                }
              ],
              "returns": [
                {
                  "description": "`true` if the event contained within the `EventHolder` is a `StoreCreatedEvent`; otherwise, `false`.\n",
                  "type": {
                    "name": "Bool",
                    "optional": false
                  }
                }
              ],
              "snippet": "public static func isStoreCreatedEvent(\n\teventHolder: privmx.endpoint.core.EventHolder\n) throws -> Bool",
              "type": "method"
            },
            {
              "description": "Checks if the `EventHolder` contains a `StoreUpdatedEvent`.\nThis method queries the provided `EventHolder` instance to determine if it holds an event that corresponds to a `StoreUpdatedEvent`.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "`PrivMXEndpointError.failedQueryingEventHolder` if an error occurs in querying the event.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "static",
              "name": "isStoreUpdatedEvent(eventHolder:)",
              "params": [
                {
                  "description": "The `EventHolder` instance to be queried.",
                  "name": "eventHolder",
                  "type": {
                    "name": "privmx.endpoint.core.EventHolder",
                    "optional": false
                  }
                }
              ],
              "returns": [
                {
                  "description": "`true` if the event contained within the `EventHolder` is a `StoreUpdatedEvent`; otherwise, `false`.\n",
                  "type": {
                    "name": "Bool",
                    "optional": false
                  }
                }
              ],
              "snippet": "public static func isStoreUpdatedEvent(\n\teventHolder: privmx.endpoint.core.EventHolder\n) throws -> Bool",
              "type": "method"
            },
            {
              "description": "Checks if the `EventHolder` contains a `StoreDeletedEvent`.\nThis method queries the provided `EventHolder` instance to determine if it holds an event that corresponds to a `StoreDeletedEvent`.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "`PrivMXEndpointError.failedQueryingEventHolder` if an error occurs in querying the event.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "static",
              "name": "isStoreDeletedEvent(eventHolder:)",
              "params": [
                {
                  "description": "The `EventHolder` instance to be queried.",
                  "name": "eventHolder",
                  "type": {
                    "name": "privmx.endpoint.core.EventHolder",
                    "optional": false
                  }
                }
              ],
              "returns": [
                {
                  "description": "`true` if the event contained within the `EventHolder` is a `StoreDeletedEvent`; otherwise, `false`.\n",
                  "type": {
                    "name": "Bool",
                    "optional": false
                  }
                }
              ],
              "snippet": "public static func isStoreDeletedEvent(\n\teventHolder: privmx.endpoint.core.EventHolder\n) throws -> Bool",
              "type": "method"
            },
            {
              "description": "Checks if the `EventHolder` contains a `StoreStatsChangedEvent`.\nThis method queries the provided `EventHolder` instance to determine if it holds an event that corresponds to a `StoreStatsChangedEvent`.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "`PrivMXEndpointError.failedQueryingEventHolder` if an error occurs in querying the event.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "static",
              "name": "isStoreStatsChangedEvent(eventHolder:)",
              "params": [
                {
                  "description": "The `EventHolder` instance to be queried.",
                  "name": "eventHolder",
                  "type": {
                    "name": "privmx.endpoint.core.EventHolder",
                    "optional": false
                  }
                }
              ],
              "returns": [
                {
                  "description": "`true` if the event contained within the `EventHolder` is a `StoreStatsChangedEvent`; otherwise, `false`.\n",
                  "type": {
                    "name": "Bool",
                    "optional": false
                  }
                }
              ],
              "snippet": "public static func isStoreStatsChangedEvent(\n\teventHolder: privmx.endpoint.core.EventHolder\n) throws -> Bool",
              "type": "method"
            },
            {
              "description": "Checks if the `EventHolder` contains a `StoreFileCreatedEvent`.\nThis method queries the provided `EventHolder` instance to determine if it holds an event that corresponds to a `StoreFileCreatedEvent`.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "`PrivMXEndpointError.failedQueryingEventHolder` if an error occurs in querying the event.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "static",
              "name": "isStoreFileCreatedEvent(eventHolder:)",
              "params": [
                {
                  "description": "The `EventHolder` instance to be queried.",
                  "name": "eventHolder",
                  "type": {
                    "name": "privmx.endpoint.core.EventHolder",
                    "optional": false
                  }
                }
              ],
              "returns": [
                {
                  "description": "`true` if the event contained within the `EventHolder` is a `StoreFileCreatedEvent`; otherwise, `false`.\n",
                  "type": {
                    "name": "Bool",
                    "optional": false
                  }
                }
              ],
              "snippet": "public static func isStoreFileCreatedEvent(\n\teventHolder: privmx.endpoint.core.EventHolder\n) throws -> Bool",
              "type": "method"
            },
            {
              "description": "Checks if the `EventHolder` contains a `StoreFileUpdatedEvent`.\nThis method queries the provided `EventHolder` instance to determine if it holds an event that corresponds to a `StoreFileUpdatedEvent`.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "`PrivMXEndpointError.failedQueryingEventHolder` if an error occurs in querying the event.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "static",
              "name": "isStoreFileUpdatedEvent(eventHolder:)",
              "params": [
                {
                  "description": "The `EventHolder` instance to be queried.",
                  "name": "eventHolder",
                  "type": {
                    "name": "privmx.endpoint.core.EventHolder",
                    "optional": false
                  }
                }
              ],
              "returns": [
                {
                  "description": "`true` if the event contained within the `EventHolder` is a `StoreFileUpdatedEvent`; otherwise, `false`.\n",
                  "type": {
                    "name": "Bool",
                    "optional": false
                  }
                }
              ],
              "snippet": "public static func isStoreFileUpdatedEvent(\n\teventHolder: privmx.endpoint.core.EventHolder\n) throws -> Bool",
              "type": "method"
            },
            {
              "description": "Checks if the `EventHolder` contains a `StoreFileDeletedEvent`.\nThis method queries the provided `EventHolder` instance to determine if it holds an event that corresponds to a `StoreFileDeletedEvent`.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "`PrivMXEndpointError.failedQueryingEventHolder` if an error occurs in querying the event.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "static",
              "name": "isStoreFileDeletedEvent(eventHolder:)",
              "params": [
                {
                  "description": "The `EventHolder` instance to be queried.",
                  "name": "eventHolder",
                  "type": {
                    "name": "privmx.endpoint.core.EventHolder",
                    "optional": false
                  }
                }
              ],
              "returns": [
                {
                  "description": "`true` if the event contained within the `EventHolder` is a `StoreFileDeletedEvent`; otherwise, `false`.\n",
                  "type": {
                    "name": "Bool",
                    "optional": false
                  }
                }
              ],
              "snippet": "public static func isStoreFileDeletedEvent(\n\teventHolder: privmx.endpoint.core.EventHolder\n) throws -> Bool",
              "type": "method"
            },
            {
              "description": "Extracts a `StoreCreatedEvent` from the provided `EventHolder`.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "`PrivMXEndpointError.failedExtractingEventFromHolder` if extraction fails.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "static",
              "name": "extractStoreCreatedEvent(eventHolder:)",
              "params": [
                {
                  "description": "An `EventHolder` containing a `StoreCreatedEvent`.",
                  "name": "eventHolder",
                  "type": {
                    "name": "privmx.endpoint.core.EventHolder",
                    "optional": false
                  }
                }
              ],
              "returns": [
                {
                  "description": "The extracted `StoreCreatedEvent`.\n",
                  "type": {
                    "name": "privmx.endpoint.store.StoreCreatedEvent",
                    "optional": false
                  }
                }
              ],
              "snippet": "public static func extractStoreCreatedEvent(\n\teventHolder: privmx.endpoint.core.EventHolder\n) throws -> privmx.endpoint.store.StoreCreatedEvent",
              "type": "method"
            },
            {
              "description": "Extracts a `StoreCreatedEvent` from the provided `EventHolder`.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "`PrivMXEndpointError.failedExtractingEventFromHolder` if extraction fails.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "static",
              "name": "extractStoreUpdatedEvent(eventHolder:)",
              "params": [
                {
                  "description": "An `EventHolder` containing a `StoreCreatedEvent`.",
                  "name": "eventHolder",
                  "type": {
                    "name": "privmx.endpoint.core.EventHolder",
                    "optional": false
                  }
                }
              ],
              "returns": [
                {
                  "description": "The extracted `StoreCreatedEvent`.\n",
                  "type": {
                    "name": "privmx.endpoint.store.StoreUpdatedEvent",
                    "optional": false
                  }
                }
              ],
              "snippet": "public static func extractStoreUpdatedEvent(\n\teventHolder: privmx.endpoint.core.EventHolder\n) throws -> privmx.endpoint.store.StoreUpdatedEvent",
              "type": "method"
            },
            {
              "description": "Extracts a `StoreDeletedEvent` from the provided `EventHolder`.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "`PrivMXEndpointError.failedExtractingEventFromHolder` if extraction fails.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "static",
              "name": "extractStoreDeletedEvent(eventHolder:)",
              "params": [
                {
                  "description": "An `EventHolder` containing a `StoreDeletedEvent`.",
                  "name": "eventHolder",
                  "type": {
                    "name": "privmx.endpoint.core.EventHolder",
                    "optional": false
                  }
                }
              ],
              "returns": [
                {
                  "description": "The extracted `StoreDeletedEvent`.\n",
                  "type": {
                    "name": "privmx.endpoint.store.StoreDeletedEvent",
                    "optional": false
                  }
                }
              ],
              "snippet": "public static func extractStoreDeletedEvent(\n\teventHolder: privmx.endpoint.core.EventHolder\n) throws -> privmx.endpoint.store.StoreDeletedEvent",
              "type": "method"
            },
            {
              "description": "Extracts a `StoreStatsChangedEvent` from the provided `EventHolder`.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "`PrivMXEndpointError.failedExtractingEventFromHolder` if extraction fails.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "static",
              "name": "extractStoreStatsChangedEvent(eventHolder:)",
              "params": [
                {
                  "description": "An `EventHolder` containing a `StoreStatsChangedEvent`.",
                  "name": "eventHolder",
                  "type": {
                    "name": "privmx.endpoint.core.EventHolder",
                    "optional": false
                  }
                }
              ],
              "returns": [
                {
                  "description": "The extracted `StoreStatsChangedEvent`.\n",
                  "type": {
                    "name": "privmx.endpoint.store.StoreStatsChangedEvent",
                    "optional": false
                  }
                }
              ],
              "snippet": "public static func extractStoreStatsChangedEvent(\n\teventHolder: privmx.endpoint.core.EventHolder\n) throws -> privmx.endpoint.store.StoreStatsChangedEvent",
              "type": "method"
            },
            {
              "description": "Extracts a `StoreFileCreatedEvent` from the provided `EventHolder`.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "`PrivMXEndpointError.failedExtractingEventFromHolder` if extraction fails.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "static",
              "name": "extractStoreFileCreatedEvent(eventHolder:)",
              "params": [
                {
                  "description": "An `EventHolder` containing a `StoreFileCreatedEvent`.",
                  "name": "eventHolder",
                  "type": {
                    "name": "privmx.endpoint.core.EventHolder",
                    "optional": false
                  }
                }
              ],
              "returns": [
                {
                  "description": "The extracted `StoreFileCreatedEvent`.\n",
                  "type": {
                    "name": "privmx.endpoint.store.StoreFileCreatedEvent",
                    "optional": false
                  }
                }
              ],
              "snippet": "public static func extractStoreFileCreatedEvent(\n\teventHolder: privmx.endpoint.core.EventHolder\n) throws -> privmx.endpoint.store.StoreFileCreatedEvent",
              "type": "method"
            },
            {
              "description": "Extracts a `StoreFileUpdatedEvent` from the provided `EventHolder`.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "`PrivMXEndpointError.failedExtractingEventFromHolder` if extraction fails.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "static",
              "name": "extractStoreFileUpdatedEvent(eventHolder:)",
              "params": [
                {
                  "description": "An `EventHolder` containing a `StoreFileUpdatedEvent`.",
                  "name": "eventHolder",
                  "type": {
                    "name": "privmx.endpoint.core.EventHolder",
                    "optional": false
                  }
                }
              ],
              "returns": [
                {
                  "description": "The extracted `StoreFileUpdatedEvent`.\n",
                  "type": {
                    "name": "privmx.endpoint.store.StoreFileUpdatedEvent",
                    "optional": false
                  }
                }
              ],
              "snippet": "public static func extractStoreFileUpdatedEvent(\n\teventHolder: privmx.endpoint.core.EventHolder\n) throws -> privmx.endpoint.store.StoreFileUpdatedEvent",
              "type": "method"
            },
            {
              "description": "Extracts a `StoreFileDeletedEvent` from the provided `EventHolder`.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "`PrivMXEndpointError.failedExtractingEventFromHolder` if extraction fails.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "static",
              "name": "extractStoreFileDeletedEvent(eventHolder:)",
              "params": [
                {
                  "description": "An `EventHolder` containing a `StoreFileDeletedEvent`.",
                  "name": "eventHolder",
                  "type": {
                    "name": "privmx.endpoint.core.EventHolder",
                    "optional": false
                  }
                }
              ],
              "returns": [
                {
                  "description": "The extracted `StoreFileDeletedEvent`.\n",
                  "type": {
                    "name": "privmx.endpoint.store.StoreFileDeletedEvent",
                    "optional": false
                  }
                }
              ],
              "snippet": "public static func extractStoreFileDeletedEvent(\n\teventHolder: privmx.endpoint.core.EventHolder\n) throws -> privmx.endpoint.store.StoreFileDeletedEvent",
              "type": "method"
            },
            {
              "description": "Checks if the `EventHolder` contains a `ThreadCreatedEvent`.\nThis method verifies whether the provided `EventHolder` instance contains an event that corresponds to a `privmx.endpoint.thread.ThreadCreatedEvent`.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "`PrivMXEndpointError.failedQueryingEventHolder` if an error occurs during querying.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "static",
              "name": "isThreadCreatedEvent(eventHolder:)",
              "params": [
                {
                  "description": "The `EventHolder` instance containing an event to check.",
                  "name": "eventHolder",
                  "type": {
                    "name": "privmx.endpoint.core.EventHolder",
                    "optional": false
                  }
                }
              ],
              "returns": [
                {
                  "description": "`true` if the `EventHolder` contains a `ThreadCreatedEvent`; otherwise, `false`.\n",
                  "type": {
                    "name": "Bool",
                    "optional": false
                  }
                }
              ],
              "snippet": "public static func isThreadCreatedEvent(\n\teventHolder: privmx.endpoint.core.EventHolder\n) throws -> Bool",
              "type": "method"
            },
            {
              "description": "Checks if the `EventHolder` contains a `ThreadUpdatedEvent`.\nThis method verifies whether the provided `EventHolder` instance contains an event that corresponds to a `privmx.endpoint.thread.ThreadUpdatedEvent`.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "`PrivMXEndpointError.failedQueryingEventHolder` if an error occurs during querying.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "static",
              "name": "isThreadUpdatedEvent(eventHolder:)",
              "params": [
                {
                  "description": "The `EventHolder` instance containing an event to check.",
                  "name": "eventHolder",
                  "type": {
                    "name": "privmx.endpoint.core.EventHolder",
                    "optional": false
                  }
                }
              ],
              "returns": [
                {
                  "description": "`true` if the `EventHolder` contains a `ThreadUpdatedEvent`; otherwise, `false`.\n",
                  "type": {
                    "name": "Bool",
                    "optional": false
                  }
                }
              ],
              "snippet": "public static func isThreadUpdatedEvent(\n\teventHolder: privmx.endpoint.core.EventHolder\n) throws -> Bool",
              "type": "method"
            },
            {
              "description": "Checks if the `EventHolder` contains a `ThreadDeletedEvent`.\nThis method verifies whether the provided `EventHolder` instance contains an event that corresponds to a `privmx.endpoint.thread.ThreadDeletedEvent`.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "`PrivMXEndpointError.failedQueryingEventHolder` if an error occurs during querying.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "static",
              "name": "isThreadDeletedEvent(eventHolder:)",
              "params": [
                {
                  "description": "The `EventHolder` instance containing an event to check.",
                  "name": "eventHolder",
                  "type": {
                    "name": "privmx.endpoint.core.EventHolder",
                    "optional": false
                  }
                }
              ],
              "returns": [
                {
                  "description": "`true` if the `EventHolder` contains a `ThreadDeletedEvent`; otherwise, `false`.\n",
                  "type": {
                    "name": "Bool",
                    "optional": false
                  }
                }
              ],
              "snippet": "public static func isThreadDeletedEvent(\n\teventHolder: privmx.endpoint.core.EventHolder\n) throws -> Bool",
              "type": "method"
            },
            {
              "description": "Checks if the `EventHolder` contains a `ThreadStatsEvent`.\nThis method verifies whether the provided `EventHolder` instance contains an event that corresponds to a `privmx.endpoint.thread.ThreadStatsEvent`.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "`PrivMXEndpointError.failedQueryingEventHolder` if an error occurs during querying.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "static",
              "name": "isThreadStatsEvent(eventHolder:)",
              "params": [
                {
                  "description": "The `EventHolder` instance containing an event to check.",
                  "name": "eventHolder",
                  "type": {
                    "name": "privmx.endpoint.core.EventHolder",
                    "optional": false
                  }
                }
              ],
              "returns": [
                {
                  "description": "`true` if the `EventHolder` contains a `ThreadStatsEvent`; otherwise, `false`.\n",
                  "type": {
                    "name": "Bool",
                    "optional": false
                  }
                }
              ],
              "snippet": "public static func isThreadStatsEvent(\n\teventHolder: privmx.endpoint.core.EventHolder\n) throws -> Bool",
              "type": "method"
            },
            {
              "description": "Checks if the `EventHolder` contains a `ThreadNewMessageEvent`.\nThis method verifies whether the provided `EventHolder` instance contains an event that corresponds to a `privmx.endpoint.thread.ThreadNewMessageEvent`.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "`PrivMXEndpointError.failedQueryingEventHolder` if an error occurs during querying.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "static",
              "name": "isThreadNewMessageEvent(eventHolder:)",
              "params": [
                {
                  "description": "The `EventHolder` instance containing an event to check.",
                  "name": "eventHolder",
                  "type": {
                    "name": "privmx.endpoint.core.EventHolder",
                    "optional": false
                  }
                }
              ],
              "returns": [
                {
                  "description": "`true` if the `EventHolder` contains a `ThreadNewMessageEvent`; otherwise, `false`.\n",
                  "type": {
                    "name": "Bool",
                    "optional": false
                  }
                }
              ],
              "snippet": "public static func isThreadNewMessageEvent(\n\teventHolder: privmx.endpoint.core.EventHolder\n) throws -> Bool",
              "type": "method"
            },
            {
              "description": "Checks if the `EventHolder` contains a `ThreadDeletedMessageEvent`.\nThis method verifies whether the provided `EventHolder` instance contains an event that corresponds to a `privmx.endpoint.thread.ThreadDeletedMessageEvent`.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "`PrivMXEndpointError.failedQueryingEventHolder` if an error occurs during querying.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "static",
              "name": "isThreadDeletedMessageEvent(eventHolder:)",
              "params": [
                {
                  "description": "The `EventHolder` instance containing an event to check.",
                  "name": "eventHolder",
                  "type": {
                    "name": "privmx.endpoint.core.EventHolder",
                    "optional": false
                  }
                }
              ],
              "returns": [
                {
                  "description": "`true` if the `EventHolder` contains a `ThreadDeletedMessageEvent`; otherwise, `false`.\n",
                  "type": {
                    "name": "Bool",
                    "optional": false
                  }
                }
              ],
              "snippet": "public static func isThreadDeletedMessageEvent(\n\teventHolder: privmx.endpoint.core.EventHolder\n) throws -> Bool",
              "type": "method"
            },
            {
              "description": "Checks if the `EventHolder` contains a `ThreadMessageEvent`.\nThis method verifies whether the provided `EventHolder` instance contains an event that corresponds to a `privmx.endpoint.thread.ThreadDeletedMessageEvent`.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "`PrivMXEndpointError.failedQueryingEventHolder` if an error occurs during querying.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "static",
              "name": "isThreadMessageDeletedEvent(eventHolder:)",
              "params": [
                {
                  "description": "The `EventHolder` instance containing an event to check.",
                  "name": "eventHolder",
                  "type": {
                    "name": "privmx.endpoint.core.EventHolder",
                    "optional": false
                  }
                }
              ],
              "returns": [
                {
                  "description": "`true` if the `EventHolder` contains a `ThreadDeletedMessageEvent`; otherwise, `false`.\n",
                  "type": {
                    "name": "Bool",
                    "optional": false
                  }
                }
              ],
              "snippet": "public static func isThreadMessageDeletedEvent(\n\teventHolder: privmx.endpoint.core.EventHolder\n) throws -> Bool",
              "type": "method"
            },
            {
              "description": "Checks if the `EventHolder` contains a `ThreadDeletedMessageEvent`.\nThis method verifies whether the provided `EventHolder` instance contains an event that corresponds to a `privmx.endpoint.thread.ThreadDeletedMessageEvent`.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "`PrivMXEndpointError.failedQueryingEventHolder` if an error occurs during querying.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "static",
              "name": "isThreadMessageUpdatedEvent(eventHolder:)",
              "params": [
                {
                  "description": "The `EventHolder` instance containing an event to check.",
                  "name": "eventHolder",
                  "type": {
                    "name": "privmx.endpoint.core.EventHolder",
                    "optional": false
                  }
                }
              ],
              "returns": [
                {
                  "description": "`true` if the `EventHolder` contains a `ThreadDeletedMessageEvent`; otherwise, `false`.\n",
                  "type": {
                    "name": "Bool",
                    "optional": false
                  }
                }
              ],
              "snippet": "public static func isThreadMessageUpdatedEvent(\n\teventHolder: privmx.endpoint.core.EventHolder\n) throws -> Bool",
              "type": "method"
            },
            {
              "description": "Extracts a `ThreadCreatedEvent` from the provided `EventHolder`.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "`PrivMXEndpointError.failedExtractingEventFromHolder` if extraction fails.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "static",
              "name": "extractThreadCreatedEvent(eventHolder:)",
              "params": [
                {
                  "description": "An `EventHolder` instance containing the `ThreadCreatedEvent`.",
                  "name": "eventHolder",
                  "type": {
                    "name": "privmx.endpoint.core.EventHolder",
                    "optional": false
                  }
                }
              ],
              "returns": [
                {
                  "description": "The extracted `ThreadCreatedEvent`.\n",
                  "type": {
                    "name": "privmx.endpoint.thread.ThreadCreatedEvent",
                    "optional": false
                  }
                }
              ],
              "snippet": "public static func extractThreadCreatedEvent(\n\teventHolder: privmx.endpoint.core.EventHolder\n) throws -> privmx.endpoint.thread.ThreadCreatedEvent",
              "type": "method"
            },
            {
              "description": "Extracts a `ThreadUpdatedEvent` from the provided `EventHolder`.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "`PrivMXEndpointError.failedExtractingEventFromHolder` if extraction fails.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "static",
              "name": "extractThreadUpdatedEvent(eventHolder:)",
              "params": [
                {
                  "description": "An `EventHolder` instance containing the `ThreadUpdatedEvent`.",
                  "name": "eventHolder",
                  "type": {
                    "name": "privmx.endpoint.core.EventHolder",
                    "optional": false
                  }
                }
              ],
              "returns": [
                {
                  "description": "The extracted `ThreadUpdatedEvent`.\n",
                  "type": {
                    "name": "privmx.endpoint.thread.ThreadUpdatedEvent",
                    "optional": false
                  }
                }
              ],
              "snippet": "public static func extractThreadUpdatedEvent(\n\teventHolder: privmx.endpoint.core.EventHolder\n) throws -> privmx.endpoint.thread.ThreadUpdatedEvent",
              "type": "method"
            },
            {
              "description": "Extracts a `ThreadDeletedEvent` from the provided `EventHolder`.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "`PrivMXEndpointError.failedExtractingEventFromHolder` if extraction fails.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "static",
              "name": "extractThreadDeletedEvent(eventHolder:)",
              "params": [
                {
                  "description": "An `EventHolder` instance containing the `ThreadDeletedEvent`.",
                  "name": "eventHolder",
                  "type": {
                    "name": "privmx.endpoint.core.EventHolder",
                    "optional": false
                  }
                }
              ],
              "returns": [
                {
                  "description": "The extracted `ThreadDeletedEvent`.\n",
                  "type": {
                    "name": "privmx.endpoint.thread.ThreadDeletedEvent",
                    "optional": false
                  }
                }
              ],
              "snippet": "public static func extractThreadDeletedEvent(\n\teventHolder: privmx.endpoint.core.EventHolder\n) throws -> privmx.endpoint.thread.ThreadDeletedEvent",
              "type": "method"
            },
            {
              "description": "Extracts a `ThreadStatsEvent` from the provided `EventHolder`.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "`PrivMXEndpointError.failedExtractingEventFromHolder` if extraction fails.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "static",
              "name": "extractThreadStatsEvent(eventHolder:)",
              "params": [
                {
                  "description": "An `EventHolder` instance containing the `ThreadStatsEvent`.",
                  "name": "eventHolder",
                  "type": {
                    "name": "privmx.endpoint.core.EventHolder",
                    "optional": false
                  }
                }
              ],
              "returns": [
                {
                  "description": "The extracted `ThreadStatsEvent`.\n",
                  "type": {
                    "name": "privmx.endpoint.thread.ThreadStatsChangedEvent",
                    "optional": false
                  }
                }
              ],
              "snippet": "public static func extractThreadStatsEvent(\n\teventHolder: privmx.endpoint.core.EventHolder\n) throws -> privmx.endpoint.thread.ThreadStatsChangedEvent",
              "type": "method"
            },
            {
              "description": "Extracts a `ThreadNewMessageEvent` from the provided `EventHolder`.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "`PrivMXEndpointError.failedExtractingEventFromHolder` if extraction fails.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "static",
              "name": "extractThreadNewMessageEvent(eventHolder:)",
              "params": [
                {
                  "description": "An `EventHolder` instance containing the `ThreadNewMessageEvent`.",
                  "name": "eventHolder",
                  "type": {
                    "name": "privmx.endpoint.core.EventHolder",
                    "optional": false
                  }
                }
              ],
              "returns": [
                {
                  "description": "The extracted `ThreadNewMessageEvent`.\n",
                  "type": {
                    "name": "privmx.endpoint.thread.ThreadNewMessageEvent",
                    "optional": false
                  }
                }
              ],
              "snippet": "public static func extractThreadNewMessageEvent(\n\teventHolder: privmx.endpoint.core.EventHolder\n) throws -> privmx.endpoint.thread.ThreadNewMessageEvent",
              "type": "method"
            },
            {
              "description": "Extracts a `ThreadDeletedMessageEvent` from the provided `EventHolder`.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "`PrivMXEndpointError.failedExtractingEventFromHolder` if extraction fails.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "static",
              "name": "extractThreadDeletedMessageEvent(eventHolder:)",
              "params": [
                {
                  "description": "An `EventHolder` instance containing the `ThreadDeletedMessageEvent`.",
                  "name": "eventHolder",
                  "type": {
                    "name": "privmx.endpoint.core.EventHolder",
                    "optional": false
                  }
                }
              ],
              "returns": [
                {
                  "description": "The extracted `ThreadDeletedMessageEvent`.\n",
                  "type": {
                    "name": "privmx.endpoint.thread.ThreadMessageDeletedEvent",
                    "optional": false
                  }
                }
              ],
              "snippet": "public static func extractThreadDeletedMessageEvent(\n\teventHolder: privmx.endpoint.core.EventHolder\n) throws -> privmx.endpoint.thread.ThreadMessageDeletedEvent",
              "type": "method"
            },
            {
              "description": "Extracts a `ThreadMessageDeletedEvent` from the provided `EventHolder`.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "`PrivMXEndpointError.failedExtractingEventFromHolder` if extraction fails.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "static",
              "name": "extractThreadMessageDeletedEvent(eventHolder:)",
              "params": [
                {
                  "description": "An `EventHolder` instance containing the `ThreadMessageDeletedEvent`.",
                  "name": "eventHolder",
                  "type": {
                    "name": "privmx.endpoint.core.EventHolder",
                    "optional": false
                  }
                }
              ],
              "returns": [
                {
                  "description": "The extracted `ThreadMessageDeletedEvent`.\n",
                  "type": {
                    "name": "privmx.endpoint.thread.ThreadMessageDeletedEvent",
                    "optional": false
                  }
                }
              ],
              "snippet": "public static func extractThreadMessageDeletedEvent(\n\teventHolder: privmx.endpoint.core.EventHolder\n) throws -> privmx.endpoint.thread.ThreadMessageDeletedEvent",
              "type": "method"
            },
            {
              "description": "Extracts a `ThreadMessageDeletedEvent` from the provided `EventHolder`.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "`PrivMXEndpointError.failedExtractingEventFromHolder` if extraction fails.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "static",
              "name": "extractThreadMessageUpdatedEvent(eventHolder:)",
              "params": [
                {
                  "description": "An `EventHolder` instance containing the `ThreadMessageUpdatedEvent`.",
                  "name": "eventHolder",
                  "type": {
                    "name": "privmx.endpoint.core.EventHolder",
                    "optional": false
                  }
                }
              ],
              "returns": [
                {
                  "description": "The extracted `ThreadMessageUpdatedEvent`.\n",
                  "type": {
                    "name": "privmx.endpoint.thread.ThreadMessageUpdatedEvent",
                    "optional": false
                  }
                }
              ],
              "snippet": "public static func extractThreadMessageUpdatedEvent(\n\teventHolder: privmx.endpoint.core.EventHolder\n) throws -> privmx.endpoint.thread.ThreadMessageUpdatedEvent",
              "type": "method"
            },
            {
              "description": "Determines if the event contained in the event holder indicates an inbox creation.\nThis method checks if the event within the provided `EventHolder` instance represents an inbox creation event.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "`PrivMXEndpointError.failedQueryingEventHolder` if there is an error during the check.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "static",
              "name": "isInboxCreatedEvent(eventHolder:)",
              "params": [
                {
                  "description": "An `EventHolder` instance containing the event to be checked.",
                  "name": "eventHolder",
                  "type": {
                    "name": "privmx.endpoint.core.EventHolder",
                    "optional": false
                  }
                }
              ],
              "returns": [
                {
                  "description": "A `Bool` indicating whether the event is an inbox creation event (`true`) or not (`false`).\n",
                  "type": {
                    "name": "Bool",
                    "optional": false
                  }
                }
              ],
              "snippet": "public static func isInboxCreatedEvent(\n\teventHolder: privmx.endpoint.core.EventHolder\n) throws -> Bool",
              "type": "method"
            },
            {
              "description": "Extracts the inbox creation event from the provided event holder.\nThis method retrieves an `InboxCreatedEvent` object from the event contained in the given `EventHolder`.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "`PrivMXEndpointError.failedQueryingEventHolder` if the extraction process fails.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "static",
              "name": "extractInboxCreatedEvent(eventHolder:)",
              "params": [
                {
                  "description": "An `EventHolder` instance containing the event to be extracted.",
                  "name": "eventHolder",
                  "type": {
                    "name": "privmx.endpoint.core.EventHolder",
                    "optional": false
                  }
                }
              ],
              "returns": [
                {
                  "description": "An `InboxCreatedEvent` containing the details of the created inbox event.\n",
                  "type": {
                    "name": "privmx.endpoint.inbox.InboxCreatedEvent",
                    "optional": false
                  }
                }
              ],
              "snippet": "public static func extractInboxCreatedEvent(\n\teventHolder: privmx.endpoint.core.EventHolder\n) throws -> privmx.endpoint.inbox.InboxCreatedEvent",
              "type": "method"
            },
            {
              "description": "Determines if the event contained in the event holder indicates an inbox update.\nThis method checks if the event within the provided `EventHolder` instance represents an inbox update event.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "`PrivMXEndpointError.failedQueryingEventHolder` if there is an error during the check.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "static",
              "name": "isInboxUpdatedEvent(eventHolder:)",
              "params": [
                {
                  "description": "An `EventHolder` instance containing the event to be checked.",
                  "name": "eventHolder",
                  "type": {
                    "name": "privmx.endpoint.core.EventHolder",
                    "optional": false
                  }
                }
              ],
              "returns": [
                {
                  "description": "A `Bool` indicating whether the event is an inbox update event (`true`) or not (`false`).\n",
                  "type": {
                    "name": "Bool",
                    "optional": false
                  }
                }
              ],
              "snippet": "public static func isInboxUpdatedEvent(\n\teventHolder: privmx.endpoint.core.EventHolder\n) throws -> Bool",
              "type": "method"
            },
            {
              "description": "Extracts the inbox update event from the provided event holder.\nThis method retrieves an `InboxUpdatedEvent` object from the event contained in the given `EventHolder`.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "`PrivMXEndpointError.failedQueryingEventHolder` if the extraction process fails.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "static",
              "name": "extractInboxUpdatedEvent(eventHolder:)",
              "params": [
                {
                  "description": "An `EventHolder` instance containing the event to be extracted.",
                  "name": "eventHolder",
                  "type": {
                    "name": "privmx.endpoint.core.EventHolder",
                    "optional": false
                  }
                }
              ],
              "returns": [
                {
                  "description": "An `InboxUpdatedEvent` containing the details of the updated inbox event.\n",
                  "type": {
                    "name": "privmx.endpoint.inbox.InboxUpdatedEvent",
                    "optional": false
                  }
                }
              ],
              "snippet": "public static func extractInboxUpdatedEvent(\n\teventHolder: privmx.endpoint.core.EventHolder\n) throws -> privmx.endpoint.inbox.InboxUpdatedEvent",
              "type": "method"
            },
            {
              "description": "Determines if the event contained in the event holder indicates an inbox deletion.\nThis method checks if the event within the provided `EventHolder` instance represents an inbox deletion event.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "`PrivMXEndpointError.failedQueryingEventHolder` if there is an error during the check.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "static",
              "name": "isInboxDeletedEvent(eventHolder:)",
              "params": [
                {
                  "description": "An `EventHolder` instance containing the event to be checked.",
                  "name": "eventHolder",
                  "type": {
                    "name": "privmx.endpoint.core.EventHolder",
                    "optional": false
                  }
                }
              ],
              "returns": [
                {
                  "description": "A `Bool` indicating whether the event is an inbox deletion event (`true`) or not (`false`).\n",
                  "type": {
                    "name": "Bool",
                    "optional": false
                  }
                }
              ],
              "snippet": "public static func isInboxDeletedEvent(\n\teventHolder: privmx.endpoint.core.EventHolder\n) throws -> Bool",
              "type": "method"
            },
            {
              "description": "Extracts the inbox deletion event from the provided event holder.\nThis method retrieves an `InboxDeletedEvent` object from the event contained in the given `EventHolder`.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "`PrivMXEndpointError.failedQueryingEventHolder` if the extraction process fails.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "static",
              "name": "extractInboxDeletedEvent(eventHolder:)",
              "params": [
                {
                  "description": "An `EventHolder` instance containing the event to be extracted.",
                  "name": "eventHolder",
                  "type": {
                    "name": "privmx.endpoint.core.EventHolder",
                    "optional": false
                  }
                }
              ],
              "returns": [
                {
                  "description": "An `InboxDeletedEvent` containing the details of the deleted inbox event.\n",
                  "type": {
                    "name": "privmx.endpoint.inbox.InboxDeletedEvent",
                    "optional": false
                  }
                }
              ],
              "snippet": "public static func extractInboxDeletedEvent(\n\teventHolder: privmx.endpoint.core.EventHolder\n) throws -> privmx.endpoint.inbox.InboxDeletedEvent",
              "type": "method"
            },
            {
              "description": "Determines if the event contained in the event holder indicates the creation of an inbox entry.\nThis method checks if the event within the provided `EventHolder` instance represents an inbox entry creation event.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "`PrivMXEndpointError.failedQueryingEventHolder` if there is an error during the check.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "static",
              "name": "isInboxEntryCreatedEvent(eventHolder:)",
              "params": [
                {
                  "description": "An `EventHolder` instance containing the event to be checked.",
                  "name": "eventHolder",
                  "type": {
                    "name": "privmx.endpoint.core.EventHolder",
                    "optional": false
                  }
                }
              ],
              "returns": [
                {
                  "description": "A `Bool` indicating whether the event is an inbox entry creation event (`true`) or not (`false`).\n",
                  "type": {
                    "name": "Bool",
                    "optional": false
                  }
                }
              ],
              "snippet": "public static func isInboxEntryCreatedEvent(\n\teventHolder: privmx.endpoint.core.EventHolder\n) throws -> Bool",
              "type": "method"
            },
            {
              "description": "Extracts the inbox entry creation event from the provided event holder.\nThis method retrieves an `InboxEntryCreatedEvent` object from the event contained in the given `EventHolder`.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "`PrivMXEndpointError.failedQueryingEventHolder` if the extraction process fails.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "static",
              "name": "extractInboxEntryCreatedEvent(eventHolder:)",
              "params": [
                {
                  "description": "An `EventHolder` instance containing the event to be extracted.",
                  "name": "eventHolder",
                  "type": {
                    "name": "privmx.endpoint.core.EventHolder",
                    "optional": false
                  }
                }
              ],
              "returns": [
                {
                  "description": "An `InboxEntryCreatedEvent` containing the details of the created inbox entry event.\n",
                  "type": {
                    "name": "privmx.endpoint.inbox.InboxEntryCreatedEvent",
                    "optional": false
                  }
                }
              ],
              "snippet": "public static func extractInboxEntryCreatedEvent(\n\teventHolder: privmx.endpoint.core.EventHolder\n) throws -> privmx.endpoint.inbox.InboxEntryCreatedEvent",
              "type": "method"
            },
            {
              "description": "Determines if the event contained in the event holder indicates the deletion of an inbox entry.\nThis method checks if the event within the provided `EventHolder` instance represents an inbox entry deletion event.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "`PrivMXEndpointError.failedQueryingEventHolder` if there is an error during the check.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "static",
              "name": "isInboxEntryDeletedEvent(eventHolder:)",
              "params": [
                {
                  "description": "An `EventHolder` instance containing the event to be checked.",
                  "name": "eventHolder",
                  "type": {
                    "name": "privmx.endpoint.core.EventHolder",
                    "optional": false
                  }
                }
              ],
              "returns": [
                {
                  "description": "A `Bool` indicating whether the event is an inbox entry deletion event (`true`) or not (`false`).\n",
                  "type": {
                    "name": "Bool",
                    "optional": false
                  }
                }
              ],
              "snippet": "public static func isInboxEntryDeletedEvent(\n\teventHolder: privmx.endpoint.core.EventHolder\n) throws -> Bool",
              "type": "method"
            },
            {
              "description": "Extracts the inbox entry deletion event from the provided event holder.\nThis method retrieves an `InboxEntryDeletedEvent` object from the event contained in the given `EventHolder`.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "`PrivMXEndpointError.failedQueryingEventHolder` if the extraction process fails.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "static",
              "name": "extractInboxEntryDeletedEvent(eventHolder:)",
              "params": [
                {
                  "description": "An `EventHolder` instance containing the event to be extracted.",
                  "name": "eventHolder",
                  "type": {
                    "name": "privmx.endpoint.core.EventHolder",
                    "optional": false
                  }
                }
              ],
              "returns": [
                {
                  "description": "An `InboxEntryDeletedEvent` containing the details of the deleted inbox entry event.\n",
                  "type": {
                    "name": "privmx.endpoint.inbox.InboxEntryDeletedEvent",
                    "optional": false
                  }
                }
              ],
              "snippet": "public static func extractInboxEntryDeletedEvent(\n\teventHolder: privmx.endpoint.core.EventHolder\n) throws -> privmx.endpoint.inbox.InboxEntryDeletedEvent",
              "type": "method"
            }
          ],
          "name": "EventHandler",
          "type": "enum"
        }
      ],
      "title": "EventHandler"
    },
    {
      "content": [
        {
          "description": "Swift wrapper for `privmx.NativeEventQueueWrapper`, providing functionality to interact with the event queue within PrivMX platform.",
          "fields": [],
          "methods": [
            {
              "description": "Retrieves a singleton instance of `EventQueue`.\nThis method attempts to access the global instance of `EventQueue`, ensuring only one instance of the event queue wrapper exists. It should be used whenever event queue interaction is needed.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "`PrivMXEndpointError.failedInstantiatingEventQueue` if an error occurs while instantiating the event queue.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "static",
              "name": "getInstance()",
              "params": [],
              "returns": [
                {
                  "description": "The singleton `EventQueue` instance.\n",
                  "type": {
                    "name": "EventQueue",
                    "optional": false
                  }
                }
              ],
              "snippet": "public static func getInstance(\n) throws -> EventQueue",
              "type": "method"
            },
            {
              "description": "Inserts a special break event into the event queue.\nThis method emits a special event, `privmx.endpoint.core.libBreakEvent`, into the event queue. This break event can be used to interrupt or signal specific conditions in the event processing flow.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "`PrivMXEndpointError.failedEmittingBreakEvent` if an error occurs during event emission.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "method",
              "name": "emitBreakEvent()",
              "params": [],
              "snippet": "public func emitBreakEvent(\n) throws -> Void",
              "type": "method"
            },
            {
              "description": "Waits for the next event in the queue.\nThis method will pause and wait until a new event arrives in the queue. If there are any unprocessed events already in the queue, it will return the first unprocessed event. The returned event should be queried using `is*Event` methods and extracted with the appropriate method.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "`PrivMXEndpointError.failedWaitingForEvent` if an error occurs while waiting for the event.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "method",
              "name": "waitEvent()",
              "params": [],
              "returns": [
                {
                  "description": "An `EventHolder` object containing the next available event.\n",
                  "type": {
                    "name": "privmx.endpoint.core.EventHolder",
                    "optional": false
                  }
                }
              ],
              "snippet": "public func waitEvent(\n) throws -> privmx.endpoint.core.EventHolder",
              "type": "method"
            },
            {
              "description": "Attempts to retrieve the next unprocessed event from the queue.\nThis method retrieves the next unprocessed event from the queue without waiting. If there are no unprocessed events, it will simply return `nil`. The returned event, if present, should be queried using `is*Event` methods and extracted with the appropriate method.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "`PrivMXEndpointError.failedGettingEvent` if an error occurs while retrieving the event.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "method",
              "name": "getEvent()",
              "params": [],
              "returns": [
                {
                  "description": "An `EventHolder` containing the next unprocessed event, or `nil` if no unprocessed events are available.\n",
                  "type": {
                    "name": "privmx.endpoint.core.EventHolder?",
                    "optional": false
                  }
                }
              ],
              "snippet": "public func getEvent(\n) throws -> privmx.endpoint.core.EventHolder?",
              "type": "method"
            }
          ],
          "name": "EventQueue",
          "type": "class"
        }
      ],
      "title": "EventQueue"
    }
  ],
  "inboxes": [
    {
      "content": [
        {
          "description": "Swift wrapper for `privmx.NativeInboxApiWrapper`, providing methods to manage Inboxes and entries within PrivMX platform.",
          "fields": [],
          "methods": [
            {
              "description": "Creates a new instance of `InboxApi` using a connection, `threadApi`, and `StoreApi`.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "`PrivMXEndpointError.failedInstantiatingInboxApi` if an error occurs during initialization.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "static",
              "name": "create(connection:threadApi:storeApi:)",
              "params": [
                {
                  "description": "The connection object to interact with PrivMX.",
                  "name": "connection",
                  "type": {
                    "name": "inout Connection",
                    "optional": false
                  }
                },
                {
                  "description": "The Thread API instance.",
                  "name": "threadApi",
                  "type": {
                    "name": "inout ThreadApi",
                    "optional": false
                  }
                },
                {
                  "description": "The Store API instance.",
                  "name": "storeApi",
                  "type": {
                    "name": "inout StoreApi",
                    "optional": false
                  }
                }
              ],
              "returns": [
                {
                  "description": "A new `InboxApi` instance.\n",
                  "type": {
                    "name": "InboxApi",
                    "optional": false
                  }
                }
              ],
              "snippet": "public static func create(\n\tconnection:inout Connection,\n\tthreadApi: inout ThreadApi,\n\tstoreApi: inout StoreApi\n) throws -> InboxApi",
              "type": "method"
            },
            {
              "description": "Creates a new Inbox in the specified context.\nIf `policies` argument is set to `nil`, the default policies will be applied.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "`PrivMXEndpointError.failedCreatingInbox` if Inbox creation fails.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "method",
              "name": "createInbox(contextId:users:managers:publicMeta:privateMeta:filesConfig:policies:)",
              "params": [
                {
                  "description": "The ID of the context where the Inbox should be created.",
                  "name": "contextId",
                  "type": {
                    "name": "std.string",
                    "optional": false
                  }
                },
                {
                  "description": "A vector of users who will have access to the Inbox.",
                  "name": "users",
                  "type": {
                    "name": "privmx.UserWithPubKeyVector",
                    "optional": false
                  }
                },
                {
                  "description": "A vector of users who will manage the Inbox.",
                  "name": "managers",
                  "type": {
                    "name": "privmx.UserWithPubKeyVector",
                    "optional": false
                  }
                },
                {
                  "description": "Public metadata that is not encrypted.",
                  "name": "publicMeta",
                  "type": {
                    "name": "privmx.endpoint.core.Buffer",
                    "optional": false
                  }
                },
                {
                  "description": "Private metadata that is encrypted.",
                  "name": "privateMeta",
                  "type": {
                    "name": "privmx.endpoint.core.Buffer",
                    "optional": false
                  }
                },
                {
                  "description": "An optional configuration for file storage.",
                  "name": "filesConfig",
                  "type": {
                    "name": "privmx.endpoint.inbox.FilesConfig?",
                    "optional": false
                  }
                },
                {
                  "description": "A set of policies for the Container.",
                  "name": "policies",
                  "type": {
                    "name": "privmx.endpoint.core.ContainerPolicyWithoutItem?",
                    "optional": false
                  }
                }
              ],
              "returns": [
                {
                  "description": "The ID of the newly created Inbox as a `std.string`.\n",
                  "type": {
                    "name": "std.string",
                    "optional": false
                  }
                }
              ],
              "snippet": "public func createInbox(\n\tcontextId: std.string,\n\tusers: privmx.UserWithPubKeyVector,\n\tmanagers: privmx.UserWithPubKeyVector,\n\tpublicMeta: privmx.endpoint.core.Buffer,\n\tprivateMeta: privmx.endpoint.core.Buffer,\n\tfilesConfig: privmx.endpoint.inbox.FilesConfig?,\n\tpolicies: privmx.endpoint.core.ContainerPolicyWithoutItem? = nil\n) throws -> std.string",
              "type": "method"
            },
            {
              "description": "Updates an existing Inbox with new metadata and configuration.\nIf `policies` argument is set to `nil`, the default policies will be applied.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "`PrivMXEndpointError.failedUpdatingInbox` if the update process fails.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "method",
              "name": "updateInbox(inboxId:users:managers:publicMeta:privateMeta:filesConfig:version:force:forceGenerateNewKey:policies:)",
              "params": [
                {
                  "description": "The ID of the Inbox to be updated.",
                  "name": "inboxId",
                  "type": {
                    "name": "std.string",
                    "optional": false
                  }
                },
                {
                  "description": "A vector of users who will have access to the Inbox.",
                  "name": "users",
                  "type": {
                    "name": "privmx.UserWithPubKeyVector",
                    "optional": false
                  }
                },
                {
                  "description": "A vector of users who will manage the Inbox.",
                  "name": "managers",
                  "type": {
                    "name": "privmx.UserWithPubKeyVector",
                    "optional": false
                  }
                },
                {
                  "description": "Updated public metadata for the Inbox.",
                  "name": "publicMeta",
                  "type": {
                    "name": "privmx.endpoint.core.Buffer",
                    "optional": false
                  }
                },
                {
                  "description": "Updated private metadata for the Inbox.",
                  "name": "privateMeta",
                  "type": {
                    "name": "privmx.endpoint.core.Buffer",
                    "optional": false
                  }
                },
                {
                  "description": "An optional configuration for file storage.",
                  "name": "filesConfig",
                  "type": {
                    "name": "privmx.endpoint.inbox.FilesConfig?",
                    "optional": false
                  }
                },
                {
                  "description": "The current version of the Inbox for version control.",
                  "name": "version",
                  "type": {
                    "name": "Int64",
                    "optional": false
                  }
                },
                {
                  "description": "Whether to force the update, ignoring version control.",
                  "name": "force",
                  "type": {
                    "name": "Bool",
                    "optional": false
                  }
                },
                {
                  "description": "Whether to force regeneration of a new key for the Inbox.",
                  "name": "forceGenerateNewKey",
                  "type": {
                    "name": "Bool",
                    "optional": false
                  }
                },
                {
                  "description": "New set of policies for the Container.",
                  "name": "policies",
                  "type": {
                    "name": "privmx.endpoint.core.ContainerPolicyWithoutItem?",
                    "optional": false
                  }
                }
              ],
              "snippet": "public func updateInbox(\n\tinboxId: std.string,\n\tusers: privmx.UserWithPubKeyVector,\n\tmanagers: privmx.UserWithPubKeyVector,\n\tpublicMeta: privmx.endpoint.core.Buffer,\n\tprivateMeta: privmx.endpoint.core.Buffer,\n\tfilesConfig: privmx.endpoint.inbox.FilesConfig?,\n\tversion: Int64,\n\tforce: Bool,\n\tforceGenerateNewKey: Bool,\n\tpolicies: privmx.endpoint.core.ContainerPolicyWithoutItem? = nil\n) throws -> Void",
              "type": "method"
            },
            {
              "description": "Retrieves detailed information about a specific Inbox.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "`PrivMXEndpointError.failedGettingInbox` if fetching Inbox details fails.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "method",
              "name": "getInbox(inboxId:)",
              "params": [
                {
                  "description": "The ID of the Inbox to retrieve.",
                  "name": "inboxId",
                  "type": {
                    "name": "std.string",
                    "optional": false
                  }
                }
              ],
              "returns": [
                {
                  "description": "An `Inbox` instance containing Inbox details.\n",
                  "type": {
                    "name": "privmx.endpoint.inbox.Inbox",
                    "optional": false
                  }
                }
              ],
              "snippet": "public func getInbox(\n\tinboxId: std.string\n) throws -> privmx.endpoint.inbox.Inbox",
              "type": "method"
            },
            {
              "description": "Lists all Inboxes within a specified context.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "`PrivMXEndpointError.failedListingInboxes` if listing Inboxes fails.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "method",
              "name": "listInboxes(contextId:pagingQuery:)",
              "params": [
                {
                  "description": "The ID of the context from which to list Inboxes.",
                  "name": "contextId",
                  "type": {
                    "name": "std.string",
                    "optional": false
                  }
                },
                {
                  "description": "A query object to filter and paginate the results.",
                  "name": "pagingQuery",
                  "type": {
                    "name": "privmx.endpoint.core.PagingQuery",
                    "optional": false
                  }
                }
              ],
              "returns": [
                {
                  "description": "An `InboxList` containing the list of Inboxes.\n",
                  "type": {
                    "name": "privmx.InboxList",
                    "optional": false
                  }
                }
              ],
              "snippet": "public func listInboxes(\n\tcontextId: std.string,\n\tpagingQuery: privmx.endpoint.core.PagingQuery\n) throws -> privmx.InboxList",
              "type": "method"
            },
            {
              "description": "Retrieves the public view of a specific Inbox.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "`PrivMXEndpointError.failedGettingInboxPublicView` if fetching the public view fails.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "method",
              "name": "getInboxPublicView(inboxId:)",
              "params": [
                {
                  "description": "The ID of the Inbox to retrieve the public view for.",
                  "name": "inboxId",
                  "type": {
                    "name": "std.string",
                    "optional": false
                  }
                }
              ],
              "returns": [
                {
                  "description": "An `InboxPublicView` containing the public view of the Inbox.\n",
                  "type": {
                    "name": "privmx.endpoint.inbox.InboxPublicView",
                    "optional": false
                  }
                }
              ],
              "snippet": "public func getInboxPublicView(\n\tinboxId: std.string\n) throws -> privmx.endpoint.inbox.InboxPublicView",
              "type": "method"
            },
            {
              "description": "Deletes a specified Inbox.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "`PrivMXEndpointError.failedDeletingInbox` if deleting the Inbox fails.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "method",
              "name": "deleteInbox(inboxId:)",
              "params": [
                {
                  "description": "The ID of the Inbox to delete.",
                  "name": "inboxId",
                  "type": {
                    "name": "std.string",
                    "optional": false
                  }
                }
              ],
              "snippet": "public func deleteInbox(\n\tinboxId: std.string\n) throws -> Void",
              "type": "method"
            },
            {
              "description": "Prepares a new entry to be sent to the Inbox.\nIf the entry contains files, they must first be prepared using `createFileHandle()` and attached to the entry.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "`PrivMXEndpointError.failedPreparingEntry` if preparing the entry fails.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "method",
              "name": "prepareEntry(inboxId:data:inboxFileHandles:userPrivKey:)",
              "params": [
                {
                  "description": "The ID of the Inbox to which the entry will be sent.",
                  "name": "inboxId",
                  "type": {
                    "name": "std.string",
                    "optional": false
                  }
                },
                {
                  "description": "The data to be included in the entry.",
                  "name": "data",
                  "type": {
                    "name": "privmx.endpoint.core.Buffer",
                    "optional": false
                  }
                },
                {
                  "description": "An optional vector of file handles to be attached to the entry. By default, no files are attached.",
                  "name": "inboxFileHandles",
                  "type": {
                    "name": "privmx.InboxFileHandleVector",
                    "optional": false
                  }
                },
                {
                  "description": "An optional private key of the user preparing the entry, if required.",
                  "name": "userPrivKey",
                  "type": {
                    "name": "std.string?",
                    "optional": false
                  }
                }
              ],
              "returns": [
                {
                  "description": "An `InboxHandle` representing the prepared entry, which should then be sent.\n",
                  "type": {
                    "name": "privmx.InboxHandle",
                    "optional": false
                  }
                }
              ],
              "snippet": "public func prepareEntry(\n\t\tinboxId: std.string,\n\t\tdata: privmx.endpoint.core.Buffer,\n\t\tinboxFileHandles: privmx.InboxFileHandleVector = [],\n\t\tuserPrivKey: std.string? = nil\n\t) throws -> privmx.InboxHandle",
              "type": "method"
            },
            {
              "description": "Sends a previously prepared entry to the Inbox.\nThis method finalizes the process by sending the entry to the specified Inbox.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "`PrivMXEndpointError.failedSendingEntry` if sending the entry fails.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "method",
              "name": "sendEntry(inboxHandle:)",
              "params": [
                {
                  "description": "The handle of the prepared entry to be sent.",
                  "name": "inboxHandle",
                  "type": {
                    "name": "privmx.InboxHandle",
                    "optional": false
                  }
                }
              ],
              "snippet": "public func sendEntry(\n\tinboxHandle: privmx.InboxHandle\n) throws -> Void",
              "type": "method"
            },
            {
              "description": "Retrieves an entry from a specific Inbox.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "`PrivMXEndpointError.failedReadingEntry` if retrieving the entry fails.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "method",
              "name": "readEntry(inboxEntryId:)",
              "params": [
                {
                  "description": "The ID of the entry to be retrieved.",
                  "name": "inboxEntryId",
                  "type": {
                    "name": "std.string",
                    "optional": false
                  }
                }
              ],
              "returns": [
                {
                  "description": "An `InboxEntry` instance representing the entry.\n",
                  "type": {
                    "name": "privmx.endpoint.inbox.InboxEntry",
                    "optional": false
                  }
                }
              ],
              "snippet": "public func readEntry(\n\tinboxEntryId: std.string\n) throws -> privmx.endpoint.inbox.InboxEntry",
              "type": "method"
            },
            {
              "description": "Lists entries within a specific Inbox.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "`PrivMXEndpointError.failedListingEntries` if listing the entries fails.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "method",
              "name": "listEntries(inboxId:pagingQuery:)",
              "params": [
                {
                  "description": "The ID of the Inbox from which to list entries.",
                  "name": "inboxId",
                  "type": {
                    "name": "std.string",
                    "optional": false
                  }
                },
                {
                  "description": "A query object to filter and paginate the results.",
                  "name": "pagingQuery",
                  "type": {
                    "name": "privmx.endpoint.core.PagingQuery",
                    "optional": false
                  }
                }
              ],
              "returns": [
                {
                  "description": "An `InboxEntryList` containing the list of entries.\n",
                  "type": {
                    "name": "privmx.InboxEntryList",
                    "optional": false
                  }
                }
              ],
              "snippet": "public func listEntries(\ninboxId: std.string,\npagingQuery: privmx.endpoint.core.PagingQuery\n) throws -> privmx.InboxEntryList",
              "type": "method"
            },
            {
              "description": "Deletes a specified entry from an Inbox.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "`PrivMXEndpointError.failedDeletingEntry` if deleting the entry fails.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "method",
              "name": "deleteEntry(inboxEntryId:)",
              "params": [
                {
                  "description": "The ID of the entry to delete.",
                  "name": "inboxEntryId",
                  "type": {
                    "name": "std.string",
                    "optional": false
                  }
                }
              ],
              "snippet": "public func deleteEntry(\n\tinboxEntryId: std.string\n) throws -> Void",
              "type": "method"
            },
            {
              "description": "Creates a new file handle for writing data to the Inbox.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "`PrivMXEndpointError.failedCreatingFileHandle` if creating the file handle fails.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "method",
              "name": "createFileHandle(publicMeta:privateMeta:fileSize:)",
              "params": [
                {
                  "description": "Public metadata for the file.",
                  "name": "publicMeta",
                  "type": {
                    "name": "privmx.endpoint.core.Buffer",
                    "optional": false
                  }
                },
                {
                  "description": "Private metadata for the file.",
                  "name": "privateMeta",
                  "type": {
                    "name": "privmx.endpoint.core.Buffer",
                    "optional": false
                  }
                },
                {
                  "description": "The size of the file in bytes.",
                  "name": "fileSize",
                  "type": {
                    "name": "Int64",
                    "optional": false
                  }
                }
              ],
              "returns": [
                {
                  "description": "An `InboxFileHandle` for writing data to the file.\n",
                  "type": {
                    "name": "privmx.InboxFileHandle",
                    "optional": false
                  }
                }
              ],
              "snippet": "public func createFileHandle(\n\tpublicMeta:privmx.endpoint.core.Buffer,\n\tprivateMeta:privmx.endpoint.core.Buffer,\n\tfileSize: Int64\n) throws -> privmx.InboxFileHandle",
              "type": "method"
            },
            {
              "description": "Writes a chunk of data to a file in the Inbox.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "`PrivMXEndpointError.failedWritingToFile` if writing the data chunk fails.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "method",
              "name": "writeToFile(inboxHandle:inboxFileHandle:dataChunk:)",
              "params": [
                {
                  "description": "Handle to the prepared Inbox entry",
                  "name": "inboxHandle",
                  "type": {
                    "name": "privmx.InboxHandle",
                    "optional": false
                  }
                },
                {
                  "description": "handle to the file where the uploaded chunk belongs",
                  "name": "inboxFileHandle",
                  "type": {
                    "name": "privmx.InboxFileHandle",
                    "optional": false
                  }
                },
                {
                  "description": "",
                  "name": "dataChunk",
                  "type": {
                    "name": "privmx.endpoint.core.Buffer",
                    "optional": false
                  }
                }
              ],
              "snippet": "public func writeToFile(\n\tinboxHandle: privmx.InboxHandle,\n\tinboxFileHandle: privmx.InboxFileHandle,\n\tdataChunk: privmx.endpoint.core.Buffer\n) throws -> Void",
              "type": "method"
            },
            {
              "description": "Opens a file for reading from the Inbox.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "`PrivMXEndpointError.failedOpeningFile` if opening the file fails.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "method",
              "name": "openFile(fileId:)",
              "params": [
                {
                  "description": "The ID of the file to open.",
                  "name": "fileId",
                  "type": {
                    "name": "std.string",
                    "optional": false
                  }
                }
              ],
              "returns": [
                {
                  "description": "An `InboxFileHandle` for reading from the file.\n",
                  "type": {
                    "name": "privmx.InboxFileHandle",
                    "optional": false
                  }
                }
              ],
              "snippet": "public func openFile(\n\tfileId: std.string\n) throws -> privmx.InboxFileHandle",
              "type": "method"
            },
            {
              "description": "Reads data from an open file in the inbox.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "`PrivMXEndpointError.failedReadingFromFile` if reading from the file fails.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "method",
              "name": "readFromFile(fileHandle:length:)",
              "params": [
                {
                  "description": "The file handle to read from.",
                  "name": "fileHandle",
                  "type": {
                    "name": "privmx.InboxFileHandle",
                    "optional": false
                  }
                },
                {
                  "description": "The number of bytes to read.",
                  "name": "length",
                  "type": {
                    "name": "Int64",
                    "optional": false
                  }
                }
              ],
              "returns": [
                {
                  "description": "A buffer containing the read data.\n",
                  "type": {
                    "name": "privmx.endpoint.core.Buffer",
                    "optional": false
                  }
                }
              ],
              "snippet": "public func readFromFile(\n\tfileHandle: privmx.InboxFileHandle,\n\tlength: Int64\n) throws -> privmx.endpoint.core.Buffer",
              "type": "method"
            },
            {
              "description": "Moves the read cursor in an open file.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "`PrivMXEndpointError.failedSeekingInFile` if moving the cursor fails.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "method",
              "name": "seekInFile(fileHandle:position:)",
              "params": [
                {
                  "description": "The file handle to move the cursor in.",
                  "name": "fileHandle",
                  "type": {
                    "name": "privmx.InboxFileHandle",
                    "optional": false
                  }
                },
                {
                  "description": "The new position of the cursor in bytes.",
                  "name": "position",
                  "type": {
                    "name": "Int64",
                    "optional": false
                  }
                }
              ],
              "snippet": "public func seekInFile(\n\tfileHandle: privmx.InboxFileHandle,\n\tposition: Int64\n) throws -> Void",
              "type": "method"
            },
            {
              "description": "Closes an open file in the Inbox.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "`PrivMXEndpointError.failedClosingFile` if closing the file fails.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "method",
              "name": "closeFile(fileHandle:)",
              "params": [
                {
                  "description": "The file handle to close.",
                  "name": "fileHandle",
                  "type": {
                    "name": "privmx.InboxFileHandle",
                    "optional": false
                  }
                }
              ],
              "returns": [
                {
                  "description": "The ID of the closed file as a `std.string`.\n",
                  "type": {
                    "name": "std.string",
                    "optional": false
                  }
                }
              ],
              "snippet": "public func closeFile(\n\tfileHandle: privmx.InboxFileHandle\n) throws -> std.string",
              "type": "method"
            },
            {
              "description": "Subscribes to Inbox-related events.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "`PrivMXEndpointError.failedSubscribingForEvents` if subscribing to Inbox events fails.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "method",
              "name": "subscribeForInboxEvents()",
              "params": [],
              "snippet": "public func subscribeForInboxEvents(\n) throws -> Void",
              "type": "method"
            },
            {
              "description": "Unsubscribes from Inbox-related events.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "`PrivMXEndpointError.failedUnsubscribingFromEvents` if unsubscribing from Inbox events fails.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "method",
              "name": "unsubscribeFromInboxEvents()",
              "params": [],
              "snippet": "public func unsubscribeFromInboxEvents(\n) throws -> Void",
              "type": "method"
            },
            {
              "description": "Subscribes to entry-related events within a specific Inbox.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "`PrivMXEndpointError.failedSubscribingForEvents` if subscribing to entry events fails.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "method",
              "name": "subscribeForEntryEvents(inboxId:)",
              "params": [
                {
                  "description": "The ID of the Inbox to subscribe to entry events for.",
                  "name": "inboxId",
                  "type": {
                    "name": "std.string",
                    "optional": false
                  }
                }
              ],
              "snippet": "public func subscribeForEntryEvents(\n\tinboxId: std.string\n) throws -> Void",
              "type": "method"
            },
            {
              "description": "Unsubscribes from entry-related events within a specific Inbox.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "`PrivMXEndpointError.failedUnsubscribingFromEvents` if unsubscribing from entry events fails.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "method",
              "name": "unsubscribeFromEntryEvents(inboxId:)",
              "params": [
                {
                  "description": "The ID of the Inbox to unsubscribe from entry events for.",
                  "name": "inboxId",
                  "type": {
                    "name": "std.string",
                    "optional": false
                  }
                }
              ],
              "snippet": "public func unsubscribeFromEntryEvents(\n\tinboxId: std.string\n) throws -> Void",
              "type": "method"
            }
          ],
          "name": "InboxApi",
          "type": "class"
        }
      ],
      "title": "InboxApi"
    }
  ],
  "stores": [
    {
      "content": [
        {
          "description": "Swift wrapper for `privmx.NativeStoreApiWrapper`, providing functionality to manage Stores and files within PrivMX platform.",
          "fields": [],
          "methods": [
            {
              "description": "Creates a new instance of `StoreApi` from a connection object.\nThis method initializes the `StoreApi` instance, enabling Store-related operations over the specified connection.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "`PrivMXEndpointError.failedInstantiatingStoreApi` if the initialization fails.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "static",
              "name": "create(connection:)",
              "params": [
                {
                  "description": "The connection object used for Store operations.",
                  "name": "connection",
                  "type": {
                    "name": "inout Connection",
                    "optional": false
                  }
                }
              ],
              "returns": [
                {
                  "description": "A newly created `StoreApi` instance.\n",
                  "type": {
                    "name": "StoreApi",
                    "optional": false
                  }
                }
              ],
              "snippet": "public static func create(\n\tconnection: inout Connection\n) throws -> StoreApi",
              "type": "method"
            },
            {
              "description": "Lists all Stores the user has access to within a specified Context.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "`PrivMXEndpointError.failedListingStores` if listing Stores fails.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "method",
              "name": "listStores(contextId:pagingQuery:)",
              "params": [
                {
                  "description": "The Context from which the Stores should be listed.",
                  "name": "contextId",
                  "type": {
                    "name": "std.string",
                    "optional": false
                  }
                },
                {
                  "description": "A `PagingQuery` object to filter and paginate the results.",
                  "name": "pagingQuery",
                  "type": {
                    "name": "privmx.endpoint.core.PagingQuery",
                    "optional": false
                  }
                }
              ],
              "returns": [
                {
                  "description": "A `privmx.StoreList` instance containing the list of Stores.\n",
                  "type": {
                    "name": "privmx.StoreList",
                    "optional": false
                  }
                }
              ],
              "snippet": "public func listStores(\n\tcontextId: std.string,\n\tpagingQuery: privmx.endpoint.core.PagingQuery\n) throws -> privmx.StoreList",
              "type": "method"
            },
            {
              "description": "",
              "methodType": "method",
              "name": "listStores(contextId:query:)",
              "params": [
                {
                  "description": "",
                  "name": "contextId",
                  "type": {
                    "name": "std.string",
                    "optional": false
                  }
                },
                {
                  "description": "",
                  "name": "query",
                  "type": {
                    "name": "privmx.endpoint.core.PagingQuery",
                    "optional": false
                  }
                }
              ],
              "returns": [
                {
                  "description": "",
                  "type": {
                    "name": "privmx.StoreList",
                    "optional": false
                  }
                }
              ],
              "snippet": "public func listStores(\n\tcontextId: std.string,\n\tquery: privmx.endpoint.core.PagingQuery\n) throws -> privmx.StoreList",
              "type": "method"
            },
            {
              "description": "Retrieves detailed information about a specified Store.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "`PrivMXEndpointError.failedGettingStore` if fetching the Store details fails.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "method",
              "name": "getStore(storeId:)",
              "params": [
                {
                  "description": "The unique identifier of the Store to retrieve.",
                  "name": "storeId",
                  "type": {
                    "name": "std.string",
                    "optional": false
                  }
                }
              ],
              "returns": [
                {
                  "description": "A `privmx.endpoint.store.Store` instance containing Store details.\n",
                  "type": {
                    "name": "privmx.endpoint.store.Store",
                    "optional": false
                  }
                }
              ],
              "snippet": "public func getStore(\n\tstoreId: std.string\n) throws -> privmx.endpoint.store.Store",
              "type": "method"
            },
            {
              "description": "Creates a new Store within a specified Context.\nThis method creates a new Store with specified users and managers. Note that managers must be added as users to gain access to the Store.\nIf `policies` argument is set to `nil`, the default policies will be applied.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "`PrivMXEndpointError.failedCreatingStore` if Store creation fails.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "method",
              "name": "createStore(contextId:users:managers:publicMeta:privateMeta:policies:)",
              "params": [
                {
                  "description": "The Context in which the Store should be created.",
                  "name": "contextId",
                  "type": {
                    "name": "std.string",
                    "optional": false
                  }
                },
                {
                  "description": "A vector of users who will have access to the Store.",
                  "name": "users",
                  "type": {
                    "name": "privmx.UserWithPubKeyVector",
                    "optional": false
                  }
                },
                {
                  "description": "A vector of managers responsible for the Store.",
                  "name": "managers",
                  "type": {
                    "name": "privmx.UserWithPubKeyVector",
                    "optional": false
                  }
                },
                {
                  "description": "Public metadata for the Store, which will not be encrypted.",
                  "name": "publicMeta",
                  "type": {
                    "name": "privmx.endpoint.core.Buffer",
                    "optional": false
                  }
                },
                {
                  "description": "Private metadata for the Store, which will be encrypted.",
                  "name": "privateMeta",
                  "type": {
                    "name": "privmx.endpoint.core.Buffer",
                    "optional": false
                  }
                },
                {
                  "description": "A set of policies for the Container.",
                  "name": "policies",
                  "type": {
                    "name": "privmx.endpoint.core.ContainerPolicy?",
                    "optional": false
                  }
                }
              ],
              "returns": [
                {
                  "description": "The ID of the newly created Store as a `std.string`.\n",
                  "type": {
                    "name": "std.string",
                    "optional": false
                  }
                }
              ],
              "snippet": "public func createStore(\n\tcontextId: std.string,\n\tusers: privmx.UserWithPubKeyVector,\n\tmanagers: privmx.UserWithPubKeyVector,\n\tpublicMeta: privmx.endpoint.core.Buffer,\n\tprivateMeta: privmx.endpoint.core.Buffer,\n\tpolicies: privmx.endpoint.core.ContainerPolicy? = nil\n) throws -> std.string",
              "type": "method"
            },
            {
              "description": "Updates an existing Store.\nThe provided values will override the existing ones. You can also force regeneration of the Storeâ€™s key if needed.\nIf `policies` argument is set to `nil`, the default policies will be applied.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "`PrivMXEndpointError.failedUpdatingStore` if updating the Store fails.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "method",
              "name": "updateStore(storeId:version:users:managers:publicMeta:privateMeta:force:forceGenerateNewKey:policies:)",
              "params": [
                {
                  "description": "The unique identifier of the Store to be updated.",
                  "name": "storeId",
                  "type": {
                    "name": "std.string",
                    "optional": false
                  }
                },
                {
                  "description": "The current version of the Store for consistency checking.",
                  "name": "version",
                  "type": {
                    "name": "Int64",
                    "optional": false
                  }
                },
                {
                  "description": "A vector of users who will have access to the Store.",
                  "name": "users",
                  "type": {
                    "name": "privmx.UserWithPubKeyVector",
                    "optional": false
                  }
                },
                {
                  "description": "A vector of managers responsible for the Store.",
                  "name": "managers",
                  "type": {
                    "name": "privmx.UserWithPubKeyVector",
                    "optional": false
                  }
                },
                {
                  "description": "New public metadata for the Store, which will not be encrypted.",
                  "name": "publicMeta",
                  "type": {
                    "name": "privmx.endpoint.core.Buffer",
                    "optional": false
                  }
                },
                {
                  "description": "New private metadata for the Store, which will be encrypted.",
                  "name": "privateMeta",
                  "type": {
                    "name": "privmx.endpoint.core.Buffer",
                    "optional": false
                  }
                },
                {
                  "description": "Whether to force the update, bypassing version control.",
                  "name": "force",
                  "type": {
                    "name": "Bool",
                    "optional": false
                  }
                },
                {
                  "description": "Whether to generate a new key for the Store.",
                  "name": "forceGenerateNewKey",
                  "type": {
                    "name": "Bool",
                    "optional": false
                  }
                },
                {
                  "description": "New set of policies for the Container.",
                  "name": "policies",
                  "type": {
                    "name": "privmx.endpoint.core.ContainerPolicy?",
                    "optional": false
                  }
                }
              ],
              "snippet": "public func updateStore(\n\tstoreId: std.string,\n\tversion: Int64,\n\tusers: privmx.UserWithPubKeyVector,\n\tmanagers: privmx.UserWithPubKeyVector,\n\tpublicMeta: privmx.endpoint.core.Buffer,\n\tprivateMeta: privmx.endpoint.core.Buffer,\n\tforce: Bool,\n\tforceGenerateNewKey: Bool,\n\tpolicies: privmx.endpoint.core.ContainerPolicy? = nil\n) throws -> Void",
              "type": "method"
            },
            {
              "description": "Deletes a specified Store.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "`PrivMXEndpointError.failedDeletingStore` if deleting the Store fails.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "method",
              "name": "deleteStore(storeId:)",
              "params": [
                {
                  "description": "The unique identifier of the Store to delete.",
                  "name": "storeId",
                  "type": {
                    "name": "std.string",
                    "optional": false
                  }
                }
              ],
              "snippet": "public func deleteStore(\n\tstoreId: std.string\n) throws -> Void",
              "type": "method"
            },
            {
              "description": "Retrieves detailed information about a specified file.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "`PrivMXEndpointError.failedGettingFile` if fetching the file details fails.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "method",
              "name": "getFile(fileId:)",
              "params": [
                {
                  "description": "The unique identifier of the file to retrieve.",
                  "name": "fileId",
                  "type": {
                    "name": "std.string",
                    "optional": false
                  }
                }
              ],
              "returns": [
                {
                  "description": "A `privmx.endpoint.store.File` instance representing the file details.\n",
                  "type": {
                    "name": "privmx.endpoint.store.File",
                    "optional": false
                  }
                }
              ],
              "snippet": "public func getFile(\n\tfileId: std.string\n) throws -> privmx.endpoint.store.File",
              "type": "method"
            },
            {
              "description": "Lists all files in a specified Store.\nThis method retrieves metadata about files in the Store. To download files, use the `openFile()` and `readFile()` methods.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "`PrivMXEndpointError.failedListingFiles` if listing the files fails.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "method",
              "name": "listFiles(storeId:pagingQuery:)",
              "params": [
                {
                  "description": "The Store from which to list files.",
                  "name": "storeId",
                  "type": {
                    "name": "std.string",
                    "optional": false
                  }
                },
                {
                  "description": "A `PagingQuery` object to filter and paginate the results.",
                  "name": "pagingQuery",
                  "type": {
                    "name": "privmx.endpoint.core.PagingQuery",
                    "optional": false
                  }
                }
              ],
              "returns": [
                {
                  "description": "A `privmx.FileList` instance containing the list of files.\n",
                  "type": {
                    "name": "privmx.FileList",
                    "optional": false
                  }
                }
              ],
              "snippet": "public func listFiles(\n\tstoreId: std.string,\n\tpagingQuery: privmx.endpoint.core.PagingQuery\n) throws -> privmx.FileList",
              "type": "method"
            },
            {
              "description": "",
              "methodType": "method",
              "name": "listFiles(storeId:query:)",
              "params": [
                {
                  "description": "",
                  "name": "storeId",
                  "type": {
                    "name": "std.string",
                    "optional": false
                  }
                },
                {
                  "description": "",
                  "name": "query",
                  "type": {
                    "name": "privmx.endpoint.core.PagingQuery",
                    "optional": false
                  }
                }
              ],
              "returns": [
                {
                  "description": "",
                  "type": {
                    "name": "privmx.FileList",
                    "optional": false
                  }
                }
              ],
              "snippet": "public func listFiles(\n\tstoreId: std.string,\n\tquery: privmx.endpoint.core.PagingQuery\n) throws -> privmx.FileList",
              "type": "method"
            },
            {
              "description": "Creates a new file handle for writing in a Store.\nUse `writeToFile()` to upload data to this handle and `closeFile()` to finalize the process.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "`PrivMXEndpointError.failedCreatingFile` if creating the file handle fails.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "method",
              "name": "createFile(storeId:publicMeta:privateMeta:size:)",
              "params": [
                {
                  "description": "The Store in which the file should be created.",
                  "name": "storeId",
                  "type": {
                    "name": "std.string",
                    "optional": false
                  }
                },
                {
                  "description": "Public metadata for the file.",
                  "name": "publicMeta",
                  "type": {
                    "name": "privmx.endpoint.core.Buffer",
                    "optional": false
                  }
                },
                {
                  "description": "Private metadata for the file.",
                  "name": "privateMeta",
                  "type": {
                    "name": "privmx.endpoint.core.Buffer",
                    "optional": false
                  }
                },
                {
                  "description": "The size of the file in bytes.",
                  "name": "size",
                  "type": {
                    "name": "Int64",
                    "optional": false
                  }
                }
              ],
              "returns": [
                {
                  "description": "A `privmx.StoreFileHandle` for writing to the file.\n",
                  "type": {
                    "name": "privmx.StoreFileHandle",
                    "optional": false
                  }
                }
              ],
              "snippet": "public func createFile(\n\tstoreId: std.string,\n\tpublicMeta:privmx.endpoint.core.Buffer,\n\tprivateMeta:privmx.endpoint.core.Buffer,\n\tsize: Int64\n) throws -> privmx.StoreFileHandle",
              "type": "method"
            },
            {
              "description": "Moves the read cursor within an open file.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "`PrivMXEndpointError.failedSeekingInFile` if moving the cursor fails.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "method",
              "name": "seekInFile(handle:position:)",
              "params": [
                {
                  "description": "The handle to the open file.",
                  "name": "handle",
                  "type": {
                    "name": "privmx.StoreFileHandle",
                    "optional": false
                  }
                },
                {
                  "description": "The new position of the read cursor in bytes.",
                  "name": "position",
                  "type": {
                    "name": "Int64",
                    "optional": false
                  }
                }
              ],
              "snippet": "public func seekInFile(\n\thandle: privmx.StoreFileHandle,\n\tposition: Int64\n) throws -> Void",
              "type": "method"
            },
            {
              "description": "Updates an existing file within a Store.\nThis method creates a new handle for updating the fileâ€™s content and metadata. Use `writeToFile()` to upload data and `closeFile()` to finalize the update.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "`PrivMXEndpointError.failedUpdatingFile` if updating the file fails.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "method",
              "name": "updateFile(fileId:publicMeta:privateMeta:size:)",
              "params": [
                {
                  "description": "The unique identifier of the file to be updated.",
                  "name": "fileId",
                  "type": {
                    "name": "std.string",
                    "optional": false
                  }
                },
                {
                  "description": "New public metadata for the file.",
                  "name": "publicMeta",
                  "type": {
                    "name": "privmx.endpoint.core.Buffer",
                    "optional": false
                  }
                },
                {
                  "description": "New private metadata for the file.",
                  "name": "privateMeta",
                  "type": {
                    "name": "privmx.endpoint.core.Buffer",
                    "optional": false
                  }
                },
                {
                  "description": "The size of the updated file in bytes.",
                  "name": "size",
                  "type": {
                    "name": "Int64",
                    "optional": false
                  }
                }
              ],
              "returns": [
                {
                  "description": "A `privmx.StoreFileHandle` for writing to the updated file.\n",
                  "type": {
                    "name": "privmx.StoreFileHandle",
                    "optional": false
                  }
                }
              ],
              "snippet": "public func updateFile(\n\tfileId: std.string,\n\tpublicMeta:privmx.endpoint.core.Buffer,\n\tprivateMeta:privmx.endpoint.core.Buffer,\n\tsize: Int64\n) throws -> privmx.StoreFileHandle",
              "type": "method"
            },
            {
              "description": "Updates the metadata of an existing File.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "When an error occurs during updating metadata.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "method",
              "name": "updateFileMeta(fileId:publicMeta:privateMeta:)",
              "params": [
                {
                  "description": "id of a File to be updated",
                  "name": "fileId",
                  "type": {
                    "name": "std.string",
                    "optional": false
                  }
                },
                {
                  "description": "new public metadata",
                  "name": "publicMeta",
                  "type": {
                    "name": "privmx.endpoint.core.Buffer",
                    "optional": false
                  }
                },
                {
                  "description": "new private metadata",
                  "name": "privateMeta",
                  "type": {
                    "name": "privmx.endpoint.core.Buffer",
                    "optional": false
                  }
                }
              ],
              "snippet": "public func updateFileMeta(\n\tfileId: std.string,\n\tpublicMeta:privmx.endpoint.core.Buffer,\n\tprivateMeta:privmx.endpoint.core.Buffer\n) throws -> Void",
              "type": "method"
            },
            {
              "description": "Closes an open file handle.\nThis method finalizes a file operation, such as writing or updating.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "`PrivMXEndpointError.failedClosingFile` if closing the file handle fails.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "method",
              "name": "closeFile(handle:)",
              "params": [
                {
                  "description": "The handle to the open file.",
                  "name": "handle",
                  "type": {
                    "name": "privmx.StoreFileHandle",
                    "optional": false
                  }
                }
              ],
              "returns": [
                {
                  "description": "The ID of the closed file as a `std.string`.\n",
                  "type": {
                    "name": "std.string",
                    "optional": false
                  }
                }
              ],
              "snippet": "public func closeFile(\n\thandle: privmx.StoreFileHandle\n) throws -> std.string",
              "type": "method"
            },
            {
              "description": "Opens a file for reading from the Store.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "`PrivMXEndpointError.failedOpeningFile` if opening the file fails.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "method",
              "name": "openFile(fileId:)",
              "params": [
                {
                  "description": "The unique identifier of the file to be opened.",
                  "name": "fileId",
                  "type": {
                    "name": "std.string",
                    "optional": false
                  }
                }
              ],
              "returns": [
                {
                  "description": "A `privmx.StoreFileHandle` for reading the file.\n",
                  "type": {
                    "name": "privmx.StoreFileHandle",
                    "optional": false
                  }
                }
              ],
              "snippet": "public func openFile(\n\tfileId: std.string\n) throws -> privmx.StoreFileHandle",
              "type": "method"
            },
            {
              "description": "Reads data from an open file.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "`PrivMXEndpointError.failedReadingFromFile` if reading from the file fails.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "method",
              "name": "readFromFile(handle:length:)",
              "params": [
                {
                  "description": "The handle to the open file.",
                  "name": "handle",
                  "type": {
                    "name": "privmx.StoreFileHandle",
                    "optional": false
                  }
                },
                {
                  "description": "The number of bytes to read.",
                  "name": "length",
                  "type": {
                    "name": "Int64",
                    "optional": false
                  }
                }
              ],
              "returns": [
                {
                  "description": "A buffer containing the read data.\n",
                  "type": {
                    "name": "privmx.endpoint.core.Buffer",
                    "optional": false
                  }
                }
              ],
              "snippet": "public func readFromFile(\n\thandle: privmx.StoreFileHandle,\n\tlength: Int64\n) throws -> privmx.endpoint.core.Buffer",
              "type": "method"
            },
            {
              "description": "Writes a chunk of data to an open file on the platform.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "`PrivMXEndpointError.failedWritingToFile` if writing to the file fails.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "method",
              "name": "writeToFile(handle:dataChunk:)",
              "params": [
                {
                  "description": "The handle to the open file.",
                  "name": "handle",
                  "type": {
                    "name": "privmx.StoreFileHandle",
                    "optional": false
                  }
                },
                {
                  "description": "The chunk of data to be written to the file.",
                  "name": "dataChunk",
                  "type": {
                    "name": "privmx.endpoint.core.Buffer",
                    "optional": false
                  }
                }
              ],
              "snippet": "public func writeToFile(\n\thandle: privmx.StoreFileHandle,\n\tdataChunk: privmx.endpoint.core.Buffer\n) throws -> Void",
              "type": "method"
            },
            {
              "description": "Deletes a specified file from the Store.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "`PrivMXEndpointError.failedDeletingFile` if deleting the file fails.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "method",
              "name": "deleteFile(fileId:)",
              "params": [
                {
                  "description": "The unique identifier of the file to delete.",
                  "name": "fileId",
                  "type": {
                    "name": "std.string",
                    "optional": false
                  }
                }
              ],
              "snippet": "public func deleteFile(\n\tfileId: std.string\n) throws -> Void",
              "type": "method"
            },
            {
              "description": "Subscribes to Store-related events.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "`PrivMXEndpointError.failedSubscribingForEvents` if subscribing to Store events fails.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "method",
              "name": "subscribeForStoreEvents()",
              "params": [],
              "snippet": "public func subscribeForStoreEvents(\n) throws -> Void",
              "type": "method"
            },
            {
              "description": "Unsubscribes from Store-related events.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "`PrivMXEndpointError.failedUnsubscribingFromEvents` if unsubscribing from Store events fails.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "method",
              "name": "unsubscribeFromStoreEvents()",
              "params": [],
              "snippet": "public func unsubscribeFromStoreEvents(\n) throws -> Void",
              "type": "method"
            },
            {
              "description": "Subscribes to file-related events within a specified Store.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "`PrivMXEndpointError.failedSubscribingForEvents` if subscribing to file events fails.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "method",
              "name": "subscribeForFileEvents(storeId:)",
              "params": [
                {
                  "description": "The unique identifier of the Store to subscribe to file events for.",
                  "name": "storeId",
                  "type": {
                    "name": "std.string",
                    "optional": false
                  }
                }
              ],
              "snippet": "public func subscribeForFileEvents(\n\tstoreId: std.string\n) throws -> Void",
              "type": "method"
            },
            {
              "description": "Unsubscribes from file-related events within a specified Store.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "`PrivMXEndpointError.failedUnsubscribingFromEvents` if unsubscribing from file events fails.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "method",
              "name": "unsubscribeFromFileEvents(storeId:)",
              "params": [
                {
                  "description": "The unique identifier of the Store to unsubscribe from file events for.",
                  "name": "storeId",
                  "type": {
                    "name": "std.string",
                    "optional": false
                  }
                }
              ],
              "snippet": "public func unsubscribeFromFileEvents(\n\tstoreId: std.string\n) throws -> Void",
              "type": "method"
            }
          ],
          "name": "StoreApi",
          "type": "class"
        }
      ],
      "title": "StoreApi"
    }
  ],
  "threads": [
    {
      "content": [
        {
          "description": "Swift wrapper for `privmx.NativeThreadApiWrapper`, providing Thread-related operations within PrivMX platform.",
          "fields": [],
          "methods": [
            {
              "description": "Creates a new instance of `ThreadApi` from a `Connection` object.\nThis method initializes the `ThreadApi` instance, enabling Thread-related operations over the specified connection.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "`PrivMXEndpointError.failedInstantiatingThreadApi` if an error occurs during the initialization.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "static",
              "name": "create(connection:)",
              "params": [
                {
                  "description": "The connection object to be used for interacting with Threads.",
                  "name": "connection",
                  "type": {
                    "name": "inout Connection",
                    "optional": false
                  }
                }
              ],
              "returns": [
                {
                  "description": "A newly created `ThreadApi` instance.\n",
                  "type": {
                    "name": "ThreadApi",
                    "optional": false
                  }
                }
              ],
              "snippet": "public static func create(\n\tconnection: inout Connection\n) throws -> ThreadApi",
              "type": "method"
            },
            {
              "description": "Creates a new Thread within PrivMX Bridge.\nThis method creates a new Thread in the specified context, assigning users and managers to it. Note that managers must be added explicitly as users to access the Thread.\nIf `policies` argument is set to `nil`, the default policies will be applied.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "`PrivMXEndpointError.failedCreatingThread` if the Thread creation fails.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "method",
              "name": "createThread(contextId:users:managers:publicMeta:privateMeta:policies:)",
              "params": [
                {
                  "description": "The context in which the Thread should be created.",
                  "name": "contextId",
                  "type": {
                    "name": "std.string",
                    "optional": false
                  }
                },
                {
                  "description": "A vector of users who will have access to the Thread.",
                  "name": "users",
                  "type": {
                    "name": "privmx.UserWithPubKeyVector",
                    "optional": false
                  }
                },
                {
                  "description": "A vector of managers responsible for the Thread.",
                  "name": "managers",
                  "type": {
                    "name": "privmx.UserWithPubKeyVector",
                    "optional": false
                  }
                },
                {
                  "description": "Public metadata for the Thread, which will not be encrypted.",
                  "name": "publicMeta",
                  "type": {
                    "name": "privmx.endpoint.core.Buffer",
                    "optional": false
                  }
                },
                {
                  "description": "Private metadata for the Thread, which will be encrypted.",
                  "name": "privateMeta",
                  "type": {
                    "name": "privmx.endpoint.core.Buffer",
                    "optional": false
                  }
                },
                {
                  "description": "A set of policies for the Container.",
                  "name": "policies",
                  "type": {
                    "name": "privmx.endpoint.core.ContainerPolicy?",
                    "optional": false
                  }
                }
              ],
              "returns": [
                {
                  "description": "The ID of the newly created Thread as a `std.string`.\n",
                  "type": {
                    "name": "std.string",
                    "optional": false
                  }
                }
              ],
              "snippet": "public func createThread(\n\tcontextId: std.string,\n\tusers: privmx.UserWithPubKeyVector,\n\tmanagers: privmx.UserWithPubKeyVector,\n\tpublicMeta: privmx.endpoint.core.Buffer,\n\tprivateMeta: privmx.endpoint.core.Buffer,\n\tpolicies: privmx.endpoint.core.ContainerPolicy? = nil\n)throws -> std.string",
              "type": "method"
            },
            {
              "description": "Retrieves detailed information about a specific Thread.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "`PrivMXEndpointError.failedGettingThread` if fetching Thread details fails.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "method",
              "name": "getThread(threadId:)",
              "params": [
                {
                  "description": "The unique identifier of the Thread to retrieve.",
                  "name": "threadId",
                  "type": {
                    "name": "std.string",
                    "optional": false
                  }
                }
              ],
              "returns": [
                {
                  "description": "A `privmx.endpoint.thread.Thread` instance representing the Thread details.\n",
                  "type": {
                    "name": "privmx.endpoint.thread.Thread",
                    "optional": false
                  }
                }
              ],
              "snippet": "public func getThread(\n\tthreadId: std.string\n) throws -> privmx.endpoint.thread.Thread",
              "type": "method"
            },
            {
              "description": "Updates an existing Thread with new values.\nThis method updates the metadata, users, and managers of a Thread. The update can be forced, and a new key can be generated if needed.\nIf `policies` argument is set to `nil`, the default policies will be applied.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "`PrivMXEndpointError.failedUpdatingThread` if the update process fails.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "method",
              "name": "updateThread(threadId:version:users:managers:publicMeta:privateMeta:force:forceGenerateNewKey:policies:)",
              "params": [
                {
                  "description": "The unique identifier of the Thread to be updated.",
                  "name": "threadId",
                  "type": {
                    "name": "std.string",
                    "optional": false
                  }
                },
                {
                  "description": "The current version of the Thread to ensure version consistency.",
                  "name": "version",
                  "type": {
                    "name": "Int64",
                    "optional": false
                  }
                },
                {
                  "description": "A vector of users who will have access to the Thread.",
                  "name": "users",
                  "type": {
                    "name": "privmx.UserWithPubKeyVector",
                    "optional": false
                  }
                },
                {
                  "description": "A vector of managers responsible for the Thread.",
                  "name": "managers",
                  "type": {
                    "name": "privmx.UserWithPubKeyVector",
                    "optional": false
                  }
                },
                {
                  "description": "New public metadata for the Thread, which will not be encrypted.",
                  "name": "publicMeta",
                  "type": {
                    "name": "privmx.endpoint.core.Buffer",
                    "optional": false
                  }
                },
                {
                  "description": "New private metadata for the Thread, which will be encrypted.",
                  "name": "privateMeta",
                  "type": {
                    "name": "privmx.endpoint.core.Buffer",
                    "optional": false
                  }
                },
                {
                  "description": "Whether to force the update, bypassing version control.",
                  "name": "force",
                  "type": {
                    "name": "Bool",
                    "optional": false
                  }
                },
                {
                  "description": "Whether to generate a new key for the Thread.",
                  "name": "forceGenerateNewKey",
                  "type": {
                    "name": "Bool",
                    "optional": false
                  }
                },
                {
                  "description": "A new set of policies for the Container.",
                  "name": "policies",
                  "type": {
                    "name": "privmx.endpoint.core.ContainerPolicy?",
                    "optional": false
                  }
                }
              ],
              "snippet": "public func updateThread(\n\tthreadId : std.string,\n\tversion: Int64,\n\tusers: privmx.UserWithPubKeyVector,\n\tmanagers: privmx.UserWithPubKeyVector,\n\tpublicMeta: privmx.endpoint.core.Buffer,\n\tprivateMeta: privmx.endpoint.core.Buffer,\n\tforce: Bool,\n\tforceGenerateNewKey: Bool,\n\tpolicies: privmx.endpoint.core.ContainerPolicy? = nil\n) throws -> Void",
              "type": "method"
            },
            {
              "description": "Deletes a specified Thread.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "`PrivMXEndpointError.failedDeletingThread` if the deletion fails.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "method",
              "name": "deleteThread(threadId:)",
              "params": [
                {
                  "description": "The unique identifier of the Thread to delete.",
                  "name": "threadId",
                  "type": {
                    "name": "std.string",
                    "optional": false
                  }
                }
              ],
              "snippet": "public func deleteThread(\n\tthreadId: std.string\n) throws -> Void",
              "type": "method"
            },
            {
              "description": "Lists all Threads accessible to the user within a specified context.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "`PrivMXEndpointError.failedListingThreads` if the listing process fails.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "method",
              "name": "listThreads(contextId:pagingQuery:)",
              "params": [
                {
                  "description": "The unique identifier of the context from which to list Threads.",
                  "name": "contextId",
                  "type": {
                    "name": "std.string",
                    "optional": false
                  }
                },
                {
                  "description": "A query object to filter and paginate the results.",
                  "name": "pagingQuery",
                  "type": {
                    "name": "privmx.endpoint.core.PagingQuery",
                    "optional": false
                  }
                }
              ],
              "returns": [
                {
                  "description": "A `privmx.ThreadList` instance containing the list of Threads.\n",
                  "type": {
                    "name": "privmx.ThreadList",
                    "optional": false
                  }
                }
              ],
              "snippet": "public func listThreads(\n\tcontextId: std.string,\n\tpagingQuery: privmx.endpoint.core.PagingQuery\n) throws -> privmx.ThreadList",
              "type": "method"
            },
            {
              "description": "",
              "methodType": "method",
              "name": "listThreads(contextId:query:)",
              "params": [
                {
                  "description": "",
                  "name": "contextId",
                  "type": {
                    "name": "std.string",
                    "optional": false
                  }
                },
                {
                  "description": "",
                  "name": "query",
                  "type": {
                    "name": "privmx.endpoint.core.PagingQuery",
                    "optional": false
                  }
                }
              ],
              "returns": [
                {
                  "description": "",
                  "type": {
                    "name": "privmx.ThreadList",
                    "optional": false
                  }
                }
              ],
              "snippet": "public func listThreads(\n\tcontextId: std.string,\n\tquery: privmx.endpoint.core.PagingQuery\n) throws -> privmx.ThreadList",
              "type": "method"
            },
            {
              "description": "Sends a message in a Thread.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "`PrivMXEndpointError.failedCreatingMessage` if the message creation fails.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "method",
              "name": "sendMessage(threadId:publicMeta:privateMeta:data:)",
              "params": [
                {
                  "description": "The unique identifier of the Thread to send the message to.",
                  "name": "threadId",
                  "type": {
                    "name": "std.string",
                    "optional": false
                  }
                },
                {
                  "description": "Public metadata for the message, which will not be encrypted.",
                  "name": "publicMeta",
                  "type": {
                    "name": "privmx.endpoint.core.Buffer",
                    "optional": false
                  }
                },
                {
                  "description": "Encrypted metadata for the message.",
                  "name": "privateMeta",
                  "type": {
                    "name": "privmx.endpoint.core.Buffer",
                    "optional": false
                  }
                },
                {
                  "description": "The actual content of the message.",
                  "name": "data",
                  "type": {
                    "name": "privmx.endpoint.core.Buffer",
                    "optional": false
                  }
                }
              ],
              "returns": [
                {
                  "description": "The ID of the created message as a `std.string`.\n",
                  "type": {
                    "name": "std.string",
                    "optional": false
                  }
                }
              ],
              "snippet": "public func sendMessage(\n\tthreadId: std.string,\n\tpublicMeta: privmx.endpoint.core.Buffer,\n\tprivateMeta: privmx.endpoint.core.Buffer,\n\tdata: privmx.endpoint.core.Buffer\n) throws -> std.string",
              "type": "method"
            },
            {
              "description": "Deletes a specified message.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "`PrivMXEndpointError.failedDeletingMessage` if the deletion process fails.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "method",
              "name": "deleteMessage(_:)",
              "params": [
                {
                  "description": "The unique identifier of the message to delete.",
                  "name": "messageId",
                  "type": {
                    "name": "std.string",
                    "optional": false
                  }
                }
              ],
              "snippet": "public func deleteMessage(\n\t_ messageId: std.string\n) throws -> Void",
              "type": "method"
            },
            {
              "description": "Retrieves a specific message by its ID.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "`PrivMXEndpointError.failedGettingMessage` if retrieving the message fails.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "method",
              "name": "getMessage(_:)",
              "params": [
                {
                  "description": "The unique identifier of the message to retrieve.",
                  "name": "messageId",
                  "type": {
                    "name": "std.string",
                    "optional": false
                  }
                }
              ],
              "returns": [
                {
                  "description": "A `privmx.endpoint.thread.Message` instance representing the message details.\n",
                  "type": {
                    "name": "privmx.endpoint.thread.Message",
                    "optional": false
                  }
                }
              ],
              "snippet": "public func getMessage(\n\t_ messageId: std.string\n) throws -> privmx.endpoint.thread.Message",
              "type": "method"
            },
            {
              "description": "Lists all messages from a specified Thread based on a query.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "`PrivMXEndpointError.failedListingMessages` if listing the messages fails.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "method",
              "name": "listMessages(threadId:pagingQuery:)",
              "params": [
                {
                  "description": "The unique identifier of the Thread from which to list messages.",
                  "name": "threadId",
                  "type": {
                    "name": "std.string",
                    "optional": false
                  }
                },
                {
                  "description": "A query object to filter and paginate the results.",
                  "name": "pagingQuery",
                  "type": {
                    "name": "privmx.endpoint.core.PagingQuery",
                    "optional": false
                  }
                }
              ],
              "returns": [
                {
                  "description": "A `privmx.MessageList` instance containing the list of messages.\n",
                  "type": {
                    "name": "privmx.MessageList",
                    "optional": false
                  }
                }
              ],
              "snippet": "public func listMessages(\n\tthreadId: std.string,\n\tpagingQuery: privmx.endpoint.core.PagingQuery\n) throws -> privmx.MessageList",
              "type": "method"
            },
            {
              "description": "",
              "methodType": "method",
              "name": "listMessages(threadId:query:)",
              "params": [
                {
                  "description": "",
                  "name": "threadId",
                  "type": {
                    "name": "std.string",
                    "optional": false
                  }
                },
                {
                  "description": "",
                  "name": "query",
                  "type": {
                    "name": "privmx.endpoint.core.PagingQuery",
                    "optional": false
                  }
                }
              ],
              "returns": [
                {
                  "description": "",
                  "type": {
                    "name": "privmx.MessageList",
                    "optional": false
                  }
                }
              ],
              "snippet": "public func listMessages(\n\tthreadId: std.string,\n\tquery: privmx.endpoint.core.PagingQuery\n) throws -> privmx.MessageList",
              "type": "method"
            },
            {
              "description": "Updates an existing message with new metadata and content.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "`PrivMXEndpointError.failedUpdatingMessage` if the update fails.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "method",
              "name": "updateMessage(messageId:publicMeta:privateMeta:data:)",
              "params": [
                {
                  "description": "The unique identifier of the message to be updated.",
                  "name": "messageId",
                  "type": {
                    "name": "std.string",
                    "optional": false
                  }
                },
                {
                  "description": "New public metadata for the message, which will not be encrypted.",
                  "name": "publicMeta",
                  "type": {
                    "name": "privmx.endpoint.core.Buffer",
                    "optional": false
                  }
                },
                {
                  "description": "New encrypted metadata for the message.",
                  "name": "privateMeta",
                  "type": {
                    "name": "privmx.endpoint.core.Buffer",
                    "optional": false
                  }
                },
                {
                  "description": "New content for the message, which will not be encrypted.",
                  "name": "data",
                  "type": {
                    "name": "privmx.endpoint.core.Buffer",
                    "optional": false
                  }
                }
              ],
              "snippet": "public func updateMessage(\n\tmessageId: std.string,\n\tpublicMeta: privmx.endpoint.core.Buffer,\n\tprivateMeta: privmx.endpoint.core.Buffer,\n\tdata: privmx.endpoint.core.Buffer\n) throws -> Void",
              "type": "method"
            },
            {
              "description": "Subscribes to Thread-related events, allowing notifications when Thread changes occur.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "`PrivMXEndpointError.failedSubscribingForEvents` if subscribing to Thread events fails.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "method",
              "name": "subscribeForThreadEvents()",
              "params": [],
              "snippet": "public func subscribeForThreadEvents(\n) throws -> Void",
              "type": "method"
            },
            {
              "description": "Unsubscribes from Thread-related events.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "`PrivMXEndpointError.failedUnsubscribingFromEvents` if unsubscribing from Thread events fails.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "method",
              "name": "unsubscribeFromThreadEvents()",
              "params": [],
              "snippet": "public func unsubscribeFromThreadEvents(\n) throws -> Void",
              "type": "method"
            },
            {
              "description": "Subscribes to message-related events within a specific Thread, allowing notifications when messages are updated or received.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "`PrivMXEndpointError.failedSubscribingForEvents` if subscribing to message events fails.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "method",
              "name": "subscribeForMessageEvents(threadId:)",
              "params": [
                {
                  "description": "The unique identifier of the Thread for which to subscribe to message events.",
                  "name": "threadId",
                  "type": {
                    "name": "std.string",
                    "optional": false
                  }
                }
              ],
              "snippet": "public func subscribeForMessageEvents(\n\tthreadId: std.string\n) throws -> Void",
              "type": "method"
            },
            {
              "description": "Unsubscribes from message-related events within a specific Thread.",
              "exceptions": [
                {
                  "code": 0,
                  "description": "`PrivMXEndpointError.failedUnsubscribingFromEvents` if unsubscribing from message events fails.",
                  "type": {
                    "name": "PrivMXEndpointError",
                    "optional": false
                  }
                }
              ],
              "methodType": "method",
              "name": "unsubscribeFromMessageEvents(threadId:)",
              "params": [
                {
                  "description": "The unique identifier of the Thread for which to unsubscribe from message events.",
                  "name": "threadId",
                  "type": {
                    "name": "std.string",
                    "optional": false
                  }
                }
              ],
              "snippet": "public func unsubscribeFromMessageEvents(\n\tthreadId: std.string\n) throws -> Void",
              "type": "method"
            }
          ],
          "name": "ThreadApi",
          "type": "class"
        }
      ],
      "title": "ThreadApi"
    }
  ]
}
