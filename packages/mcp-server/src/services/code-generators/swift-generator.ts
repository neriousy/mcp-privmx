/**
 * Swift Code Generator
 * Generates production-ready setup code for PrivMX Endpoint Swift (iOS/macOS)
 */

import { BaseCodeGenerator } from './base-generator.js';

export class SwiftGenerator extends BaseCodeGenerator {
  generateSetup(features: string[]): string {
    const hasThreads = this.hasFeature(features, 'threads');
    const hasStores = this.hasFeature(features, 'stores');
    const hasInboxes = this.hasFeature(features, 'inboxes');
    const hasCrypto = this.hasFeature(features, 'crypto');

    const imports = ['import Foundation', 'import PrivMXEndpointSwift'];

    if (hasThreads) imports.push('// Threads for secure messaging');
    if (hasStores) imports.push('// Stores for encrypted file sharing');
    if (hasInboxes) imports.push('// Inboxes for anonymous submissions');
    if (hasCrypto) imports.push('// Crypto for key management');

    const setupCode = `
/**
 * PrivMX Endpoint Setup - Swift Production Ready (iOS/macOS)
 * Generated by PrivMX MCP Server
 * 
 * Requirements:
 * Add to Package.swift:
 * .package(url: "https://github.com/simplito/privmx-endpoint-swift", from: "2.0.0")
 * 
 * Or Xcode: File > Add Package Dependency:
 * https://github.com/simplito/privmx-endpoint-swift
 * 
 * Make sure to add PrivMXEndpointSwift to your target dependencies
 */

${this.generateImports(imports)}

/**
 * Configuration for PrivMX connection
 */
struct PrivMXConfig {
    let userPrivateKey: String
    let solutionId: String
    let bridgeUrl: String
    
    init(userPrivateKey: String, solutionId: String, bridgeUrl: String = "https://your-bridge.privmx.dev") {
        self.userPrivateKey = userPrivateKey
        self.solutionId = solutionId
        self.bridgeUrl = bridgeUrl
    }
}

/**
 * User representation for PrivMX operations
 */
struct PrivMXUser {
    let userId: String
    let pubKey: String
}

/**
 * Custom errors for PrivMX operations
 */
enum PrivMXError: Error, LocalizedError {
    case notInitialized
    case initializationFailed(String)
    case operationFailed(String)
    case invalidParameters(String)
    
    var errorDescription: String? {
        switch self {
        case .notInitialized:
            return "PrivMX not initialized"
        case .initializationFailed(let message):
            return "PrivMX initialization failed: \\(message)"
        case .operationFailed(let message):
            return "PrivMX operation failed: \\(message)"
        case .invalidParameters(let message):
            return "Invalid parameters: \\(message)"
        }
    }
}

/**
 * Main PrivMX Manager - handles all PrivMX operations with modern Swift async/await
 */
@MainActor
class PrivMXManager: ObservableObject {
    private var endpoint: PrivmxEndpoint?
    private var connectionId: Int64 = 0
    @Published var isConnected: Bool = false
    
    /**
     * Initialize PrivMX and connect to Bridge
     */
    func initialize(config: PrivMXConfig) async throws -> Int64 {
        do {
            // Create endpoint instance
            self.endpoint = PrivmxEndpoint()
            
            // Connect to PrivMX Bridge
            guard let endpoint = self.endpoint else {
                throw PrivMXError.initializationFailed("Failed to create endpoint")
            }
            
            self.connectionId = try await endpoint.connect(
                userPrivKey: config.userPrivateKey,
                solutionId: config.solutionId,
                bridgeUrl: config.bridgeUrl
            )
            
            self.isConnected = true
            print("‚úÖ Connected to PrivMX Bridge: \\(connectionId)")
            
            return connectionId
        } catch {
            print("‚ùå PrivMX initialization failed: \\(error.localizedDescription)")
            throw PrivMXError.initializationFailed(error.localizedDescription)
        }
    }${hasThreads ? this.generateThreadsFeature() : ''}${hasStores ? this.generateStoresFeature() : ''}${hasInboxes ? this.generateInboxesFeature() : ''}${hasCrypto ? this.generateCryptoFeature() : ''}

    /**
     * Cleanup and disconnect
     */
    func disconnect() async {
        do {
            if let endpoint = self.endpoint, isConnected {
                try await endpoint.disconnect(connectionId: connectionId)
                self.isConnected = false
                print("‚úÖ Disconnected from PrivMX Bridge")
            }
        } catch {
            print("‚ùå Disconnect failed: \\(error.localizedDescription)")
        }
    }
    
    /**
     * Check if PrivMX is ready for operations
     */
    var isReady: Bool {
        return isConnected && endpoint != nil
    }
}

// MARK: - Usage Example

/**
 * Example usage of PrivMXManager
 */
struct PrivMXExample {
    let privmx = PrivMXManager()
    
    func runExample() async {
        do {
            // Configuration
            let config = PrivMXConfig(
                userPrivateKey: "YOUR_PRIVATE_KEY_WIF",
                solutionId: "YOUR_SOLUTION_ID",
                bridgeUrl: "https://your-bridge.privmx.dev"
            )
            
            // Initialize connection
            try await privmx.initialize(config: config)
            
            ${hasThreads ? this.generateThreadsExample() : ''}${hasStores ? this.generateStoresExample() : ''}${hasInboxes ? this.generateInboxesExample() : ''}${hasCrypto ? this.generateCryptoExample() : ''}
            
        } catch {
            print("Application error: \\(error.localizedDescription)")
        }
        
        // Always disconnect when done
        await privmx.disconnect()
    }
}`;

    return setupCode;
  }

  generateThreadsFeature(): string {
    return `

    // MARK: - Secure Threads (Messaging) API
    
    /**
     * Create a secure thread for messaging
     */
    func createThread(users: [UserWithPubKey], publicMeta: String = "{}", privateMeta: String = "{}") async throws -> Thread {
        guard isReady else { throw PrivMXError.notInitialized }
        guard let endpoint = self.endpoint else { throw PrivMXError.notInitialized }
        
        do {
            let thread = try await endpoint.threadCreateThread(
                contextId: connectionId,
                users: users,
                publicMeta: publicMeta,
                privateMeta: privateMeta
            )
            
            print("‚úÖ Thread created: \\(thread.threadId)")
            return thread
        } catch {
            print("‚ùå Thread creation failed: \\(error.localizedDescription)")
            throw PrivMXError.operationFailed(error.localizedDescription)
        }
    }
    
    /**
     * Send a message to a thread
     */
    func sendMessage(threadId: String, data: Data, publicMeta: String = "{}", privateMeta: String = "{}") async throws -> Message {
        guard isReady else { throw PrivMXError.notInitialized }
        guard let endpoint = self.endpoint else { throw PrivMXError.notInitialized }
        
        do {
            let message = try await endpoint.threadSendMessage(
                threadId: threadId,
                publicMeta: publicMeta,
                privateMeta: privateMeta,
                data: data
            )
            
            print("‚úÖ Message sent: \\(message.messageId)")
            return message
        } catch {
            print("‚ùå Message sending failed: \\(error.localizedDescription)")
            throw PrivMXError.operationFailed(error.localizedDescription)
        }
    }
    
    /**
     * Get messages from a thread
     */
    func getMessages(threadId: String, skip: Int64 = 0, limit: Int64 = 10) async throws -> PagingList<Message> {
        guard isReady else { throw PrivMXError.notInitialized }
        guard let endpoint = self.endpoint else { throw PrivMXError.notInitialized }
        
        do {
            return try await endpoint.threadListMessages(
                threadId: threadId,
                skip: skip,
                limit: limit
            )
        } catch {
            print("‚ùå Getting messages failed: \\(error.localizedDescription)")
            throw PrivMXError.operationFailed(error.localizedDescription)
        }
    }`;
  }

  generateStoresFeature(): string {
    return `

    // MARK: - Secure Stores (File Sharing) API
    
    /**
     * Create a secure store for file sharing
     */
    func createStore(users: [UserWithPubKey], publicMeta: String = "{}", privateMeta: String = "{}") async throws -> Store {
        guard isReady else { throw PrivMXError.notInitialized }
        guard let endpoint = self.endpoint else { throw PrivMXError.notInitialized }
        
        do {
            let store = try await endpoint.storeCreateStore(
                contextId: connectionId,
                users: users,
                publicMeta: publicMeta,
                privateMeta: privateMeta
            )
            
            print("‚úÖ Store created: \\(store.storeId)")
            return store
        } catch {
            print("‚ùå Store creation failed: \\(error.localizedDescription)")
            throw PrivMXError.operationFailed(error.localizedDescription)
        }
    }
    
    /**
     * Upload a file to a store
     */
    func uploadFile(storeId: String, fileName: String, fileData: Data, publicMeta: String = "{}", privateMeta: String = "{}") async throws -> File {
        guard isReady else { throw PrivMXError.notInitialized }
        guard let endpoint = self.endpoint else { throw PrivMXError.notInitialized }
        
        do {
            // Create file
            let file = try await endpoint.storeCreateFile(
                storeId: storeId,
                publicMeta: publicMeta,
                privateMeta: privateMeta,
                size: Int64(fileData.count)
            )
            
            // Write file data
            let uploadHandle = try await endpoint.storeOpenFile(fileId: file.info.fileId)
            try await endpoint.storeWriteToFile(fileHandle: uploadHandle, dataToWrite: fileData)
            try await endpoint.storeCloseFile(fileHandle: uploadHandle)
            
            print("‚úÖ File uploaded: \\(file.info.fileId)")
            return file
        } catch {
            print("‚ùå File upload failed: \\(error.localizedDescription)")
            throw PrivMXError.operationFailed(error.localizedDescription)
        }
    }
    
    /**
     * Download a file from a store
     */
    func downloadFile(fileId: String) async throws -> Data {
        guard isReady else { throw PrivMXError.notInitialized }
        guard let endpoint = self.endpoint else { throw PrivMXError.notInitialized }
        
        do {
            let downloadHandle = try await endpoint.storeOpenFile(fileId: fileId)
            let fileData = try await endpoint.storeReadFromFile(fileHandle: downloadHandle)
            try await endpoint.storeCloseFile(fileHandle: downloadHandle)
            
            print("‚úÖ File downloaded: \\(fileId)")
            return fileData
        } catch {
            print("‚ùå File download failed: \\(error.localizedDescription)")
            throw PrivMXError.operationFailed(error.localizedDescription)
        }
    }`;
  }

  generateInboxesFeature(): string {
    return `

    // MARK: - Secure Inboxes (Anonymous Submissions) API
    
    /**
     * Create an inbox for anonymous submissions
     */
    func createInbox(users: [UserWithPubKey], publicMeta: String = "{}", privateMeta: String = "{}", filesConfig: FilesConfig? = nil) async throws -> Inbox {
        guard isReady else { throw PrivMXError.notInitialized }
        guard let endpoint = self.endpoint else { throw PrivMXError.notInitialized }
        
        do {
            let inbox = try await endpoint.inboxCreateInbox(
                contextId: connectionId,
                users: users,
                publicMeta: publicMeta,
                privateMeta: privateMeta,
                filesConfig: filesConfig ?? FilesConfig()
            )
            
            print("‚úÖ Inbox created: \\(inbox.inboxId)")
            return inbox
        } catch {
            print("‚ùå Inbox creation failed: \\(error.localizedDescription)")
            throw PrivMXError.operationFailed(error.localizedDescription)
        }
    }
    
    /**
     * Send an entry to an inbox (anonymous submission)
     */
    func sendToInbox(inboxId: String, data: Data, publicMeta: String = "{}", privateMeta: String = "{}", files: [InboxFileHandle] = []) async throws -> InboxEntry {
        guard isReady else { throw PrivMXError.notInitialized }
        guard let endpoint = self.endpoint else { throw PrivMXError.notInitialized }
        
        do {
            let entry = try await endpoint.inboxSendEntry(
                inboxId: inboxId,
                publicMeta: publicMeta,
                privateMeta: privateMeta,
                data: data,
                files: files
            )
            
            print("‚úÖ Entry sent to inbox: \\(entry.entryId)")
            return entry
        } catch {
            print("‚ùå Sending to inbox failed: \\(error.localizedDescription)")
            throw PrivMXError.operationFailed(error.localizedDescription)
        }
    }
    
    /**
     * Get entries from an inbox (managers only)
     */
    func getInboxEntries(inboxId: String, skip: Int64 = 0, limit: Int64 = 10) async throws -> PagingList<InboxEntry> {
        guard isReady else { throw PrivMXError.notInitialized }
        guard let endpoint = self.endpoint else { throw PrivMXError.notInitialized }
        
        do {
            return try await endpoint.inboxListEntries(
                inboxId: inboxId,
                skip: skip,
                limit: limit
            )
        } catch {
            print("‚ùå Getting inbox entries failed: \\(error.localizedDescription)")
            throw PrivMXError.operationFailed(error.localizedDescription)
        }
    }`;
  }

  generateCryptoFeature(): string {
    return `

    // MARK: - Crypto API for Key Management
    
    /**
     * Generate a new private key
     */
    func generatePrivateKey() async throws -> PrivateKey {
        guard isReady else { throw PrivMXError.notInitialized }
        guard let endpoint = self.endpoint else { throw PrivMXError.notInitialized }
        
        do {
            let privateKey = try await endpoint.cryptoGeneratePrivateKey()
            print("‚úÖ Private key generated")
            return privateKey
        } catch {
            print("‚ùå Key generation failed: \\(error.localizedDescription)")
            throw PrivMXError.operationFailed(error.localizedDescription)
        }
    }
    
    /**
     * Derive public key from private key
     */
    func derivePublicKey(privateKey: PrivateKey) async throws -> PublicKey {
        guard isReady else { throw PrivMXError.notInitialized }
        guard let endpoint = self.endpoint else { throw PrivMXError.notInitialized }
        
        do {
            let publicKey = try await endpoint.cryptoDerivePublicKey(privKey: privateKey)
            print("‚úÖ Public key derived")
            return publicKey
        } catch {
            print("‚ùå Public key derivation failed: \\(error.localizedDescription)")
            throw PrivMXError.operationFailed(error.localizedDescription)
        }
    }
    
    /**
     * Sign data with private key
     */
    func signData(data: Data, privateKey: PrivateKey) async throws -> Data {
        guard isReady else { throw PrivMXError.notInitialized }
        guard let endpoint = self.endpoint else { throw PrivMXError.notInitialized }
        
        do {
            let signature = try await endpoint.cryptoSignData(data: data, privKey: privateKey)
            print("‚úÖ Data signed")
            return signature
        } catch {
            print("‚ùå Data signing failed: \\(error.localizedDescription)")
            throw PrivMXError.operationFailed(error.localizedDescription)
        }
    }
    
    /**
     * Verify signature with public key
     */
    func verifySignature(data: Data, signature: Data, publicKey: PublicKey) async throws -> Bool {
        guard isReady else { throw PrivMXError.notInitialized }
        guard let endpoint = self.endpoint else { throw PrivMXError.notInitialized }
        
        do {
            let isValid = try await endpoint.cryptoVerifySignature(data: data, signature: signature, pubKey: publicKey)
            print("‚úÖ Signature verified: \\(isValid)")
            return isValid
        } catch {
            print("‚ùå Signature verification failed: \\(error.localizedDescription)")
            throw PrivMXError.operationFailed(error.localizedDescription)
        }
    }`;
  }

  generateThreadsExample(): string {
    return `
            // üîê Create a secure thread for messaging
            let users = [
                UserWithPubKey(userId: "user1", pubKey: "USER1_PUBLIC_KEY"),
                UserWithPubKey(userId: "user2", pubKey: "USER2_PUBLIC_KEY")
            ]
            
            let thread = try await privmx.createThread(
                users: users,
                publicMeta: "{\\"title\\": \\"My Secure Chat\\"}",
                privateMeta: "{\\"description\\": \\"Private conversation\\"}"
            )
            
            // Send a message
            let messageText = "Hello, secure world!"
            let messageData = messageText.data(using: .utf8)!
            try await privmx.sendMessage(
                threadId: thread.threadId,
                data: messageData,
                publicMeta: "{\\"messageType\\": \\"text\\"}"
            )
            
            // Get messages
            let messages = try await privmx.getMessages(threadId: thread.threadId, skip: 0, limit: 10)
            print("Messages: \\(messages.readItems.count)")`;
  }

  generateStoresExample(): string {
    return `
            // üìÅ Create a secure store for file sharing
            let users = [
                UserWithPubKey(userId: "user1", pubKey: "USER1_PUBLIC_KEY"),
                UserWithPubKey(userId: "user2", pubKey: "USER2_PUBLIC_KEY")
            ]
            
            let store = try await privmx.createStore(
                users: users,
                publicMeta: "{\\"storeName\\": \\"Shared Files\\"}",
                privateMeta: "{\\"description\\": \\"Team file sharing\\"}"
            )
            
            // Upload a file
            let fileContent = "Hello from a secure file!"
            let fileData = fileContent.data(using: .utf8)!
            let file = try await privmx.uploadFile(
                storeId: store.storeId,
                fileName: "hello.txt",
                fileData: fileData,
                publicMeta: "{\\"fileName\\": \\"hello.txt\\", \\"fileType\\": \\"text/plain\\"}"
            )
            
            // Download the file
            let downloadedData = try await privmx.downloadFile(fileId: file.info.fileId)
            let downloadedContent = String(data: downloadedData, encoding: .utf8) ?? ""
            print("Downloaded: \\(downloadedContent)")`;
  }

  generateInboxesExample(): string {
    return `
            // üìÆ Create an inbox for anonymous submissions
            let managers = [
                UserWithPubKey(userId: "manager1", pubKey: "MANAGER1_PUBLIC_KEY")
            ]
            
            let inbox = try await privmx.createInbox(
                users: managers,
                publicMeta: "{\\"inboxName\\": \\"Feedback Form\\"}",
                privateMeta: "{\\"description\\": \\"Anonymous feedback collection\\"}"
            )
            
            // Send anonymous entry
            let feedback = "Great product!"
            let feedbackData = feedback.data(using: .utf8)!
            try await privmx.sendToInbox(
                inboxId: inbox.inboxId,
                data: feedbackData,
                publicMeta: "{\\"submissionType\\": \\"feedback\\"}",
                privateMeta: "{\\"rating\\": 5}"
            )
            
            // Get inbox entries (managers only)
            let entries = try await privmx.getInboxEntries(inboxId: inbox.inboxId, skip: 0, limit: 10)
            print("Submissions: \\(entries.readItems.count)")`;
  }

  generateCryptoExample(): string {
    return `
            // üîê Generate cryptographic keys
            let privateKey = try await privmx.generatePrivateKey()
            let publicKey = try await privmx.derivePublicKey(privateKey: privateKey)
            print("Key pair generated successfully")
            
            // Sign and verify data
            let data = "Important message".data(using: .utf8)!
            let signature = try await privmx.signData(data: data, privateKey: privateKey)
            let isValid = try await privmx.verifySignature(data: data, signature: signature, publicKey: publicKey)
            print("Signature valid: \\(isValid)")`;
  }
}
