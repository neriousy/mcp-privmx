/**
 * Java Code Generator
 * Generates production-ready setup code for PrivMX Endpoint Java
 */

import { BaseCodeGenerator } from './base-generator.js';

export class JavaGenerator extends BaseCodeGenerator {
  generateSetup(features: string[]): string {
    const hasThreads = this.hasFeature(features, 'threads');
    const hasStores = this.hasFeature(features, 'stores');
    const hasInboxes = this.hasFeature(features, 'inboxes');
    const hasCrypto = this.hasFeature(features, 'crypto');

    const imports = [
      'import com.simplito.java.privmx_endpoint.*;',
      'import com.simplito.java.privmx_endpoint.model.*;',
      'import java.util.*;',
      'import java.nio.charset.StandardCharsets;',
    ];

    if (hasThreads) imports.push('// Threads for secure messaging');
    if (hasStores) imports.push('// Stores for encrypted file sharing');
    if (hasInboxes) imports.push('// Inboxes for anonymous submissions');
    if (hasCrypto) imports.push('// Crypto for key management');

    const setupCode = `
/**
 * PrivMX Endpoint Setup - Java Production Ready
 * Generated by PrivMX MCP Server
 * 
 * Requirements:
 * Maven dependency:
 * <dependency>
 *   <groupId>com.simplito</groupId>
 *   <artifactId>privmx-endpoint-java</artifactId>
 *   <version>2.0.0</version>
 * </dependency>
 * 
 * Gradle dependency:
 * implementation 'com.simplito:privmx-endpoint-java:2.0.0'
 * 
 * Native libraries must be included in java.library.path
 */

${this.generateImports(imports)}

public class PrivMXManager {
    private PrivmxEndpoint endpoint;
    private long connectionId;
    private boolean isConnected = false;

    /**
     * Configuration class for PrivMX connection
     */
    public static class Config {
        private final String userPrivateKey;
        private final String solutionId;
        private final String bridgeUrl;

        public Config(String userPrivateKey, String solutionId, String bridgeUrl) {
            this.userPrivateKey = userPrivateKey;
            this.solutionId = solutionId;
            this.bridgeUrl = bridgeUrl != null ? bridgeUrl : "https://your-bridge.privmx.dev";
        }

        public String getUserPrivateKey() { return userPrivateKey; }
        public String getSolutionId() { return solutionId; }
        public String getBridgeUrl() { return bridgeUrl; }
    }

    /**
     * User representation for PrivMX operations
     */
    public static class User {
        private final String userId;
        private final String pubKey;

        public User(String userId, String pubKey) {
            this.userId = userId;
            this.pubKey = pubKey;
        }

        public String getUserId() { return userId; }
        public String getPubKey() { return pubKey; }
    }

    /**
     * Initialize PrivMX and connect to Bridge
     */
    public long initialize(Config config) throws Exception {
        try {
            // Create endpoint instance
            this.endpoint = new PrivmxEndpoint();
            
            // Connect to PrivMX Bridge
            this.connectionId = endpoint.connect(
                config.getUserPrivateKey(),
                config.getSolutionId(),
                config.getBridgeUrl()
            );
            
            this.isConnected = true;
            System.out.println("✅ Connected to PrivMX Bridge: " + connectionId);
            
            return connectionId;
        } catch (Exception error) {
            System.err.println("❌ PrivMX initialization failed: " + error.getMessage());
            throw new Exception("PrivMX setup failed: " + error.getMessage(), error);
        }
    }${hasThreads ? this.generateThreadsFeature() : ''}${hasStores ? this.generateStoresFeature() : ''}${hasInboxes ? this.generateInboxesFeature() : ''}${hasCrypto ? this.generateCryptoFeature() : ''}

    /**
     * Cleanup and disconnect
     */
    public void disconnect() {
        try {
            if (endpoint != null && isConnected) {
                endpoint.disconnect(connectionId);
                isConnected = false;
                System.out.println("✅ Disconnected from PrivMX Bridge");
            }
        } catch (Exception error) {
            System.err.println("❌ Disconnect failed: " + error.getMessage());
        }
    }

    /**
     * Check connection status
     */
    public boolean isReady() {
        return isConnected && endpoint != null;
    }

    /**
     * Usage Example and Main Method
     */
    public static void main(String[] args) {
        PrivMXManager privmx = new PrivMXManager();
        
        try {
            // Configuration
            Config config = new Config(
                "YOUR_PRIVATE_KEY_WIF",
                "YOUR_SOLUTION_ID", 
                "https://your-bridge.privmx.dev"
            );
            
            // Initialize connection
            privmx.initialize(config);
            
            ${hasThreads ? this.generateThreadsExample() : ''}${hasStores ? this.generateStoresExample() : ''}${hasInboxes ? this.generateInboxesExample() : ''}${hasCrypto ? this.generateCryptoExample() : ''}
        } catch (Exception error) {
            System.err.println("Application error: " + error.getMessage());
            error.printStackTrace();
        } finally {
            privmx.disconnect();
        }
    }
}`;

    return setupCode;
  }

  generateThreadsFeature(): string {
    return `

    /**
     * Secure Threads (Messaging) API - Java
     */
    public Thread createThread(List<UserWithPubKey> users, String publicMeta, String privateMeta) 
            throws Exception {
        if (!isReady()) throw new Exception("PrivMX not initialized");
        
        try {
            Thread thread = endpoint.threadCreateThread(
                connectionId,
                users,
                publicMeta != null ? publicMeta : "{}",
                privateMeta != null ? privateMeta : "{}"
            );
            
            System.out.println("✅ Thread created: " + thread.getThreadId());
            return thread;
        } catch (Exception error) {
            System.err.println("❌ Thread creation failed: " + error.getMessage());
            throw error;
        }
    }

    public Message sendMessage(String threadId, byte[] data, String publicMeta, String privateMeta) 
            throws Exception {
        if (!isReady()) throw new Exception("PrivMX not initialized");
        
        try {
            Message message = endpoint.threadSendMessage(
                threadId,
                publicMeta != null ? publicMeta : "{}",
                privateMeta != null ? privateMeta : "{}",
                data
            );
            
            System.out.println("✅ Message sent: " + message.getMessageId());
            return message;
        } catch (Exception error) {
            System.err.println("❌ Message sending failed: " + error.getMessage());
            throw error;
        }
    }

    public PagingList<Message> getMessages(String threadId, long skip, long limit) 
            throws Exception {
        if (!isReady()) throw new Exception("PrivMX not initialized");
        
        try {
            return endpoint.threadListMessages(threadId, skip, limit);
        } catch (Exception error) {
            System.err.println("❌ Getting messages failed: " + error.getMessage());
            throw error;
        }
    }`;
  }

  generateStoresFeature(): string {
    return `

    /**
     * Secure Stores (File Sharing) API - Java
     */
    public Store createStore(List<UserWithPubKey> users, String publicMeta, String privateMeta) 
            throws Exception {
        if (!isReady()) throw new Exception("PrivMX not initialized");
        
        try {
            Store store = endpoint.storeCreateStore(
                connectionId,
                users,
                publicMeta != null ? publicMeta : "{}",
                privateMeta != null ? privateMeta : "{}"
            );
            
            System.out.println("✅ Store created: " + store.getStoreId());
            return store;
        } catch (Exception error) {
            System.err.println("❌ Store creation failed: " + error.getMessage());
            throw error;
        }
    }

    public File uploadFile(String storeId, String fileName, byte[] fileData, 
                          String publicMeta, String privateMeta) throws Exception {
        if (!isReady()) throw new Exception("PrivMX not initialized");
        
        try {
            // Create file
            File file = endpoint.storeCreateFile(
                storeId,
                publicMeta != null ? publicMeta : "{}",
                privateMeta != null ? privateMeta : "{}",
                fileData.length
            );

            // Write file data
            long uploadHandle = endpoint.storeOpenFile(file.getInfo().getFileId());
            endpoint.storeWriteToFile(uploadHandle, fileData);
            endpoint.storeCloseFile(uploadHandle);
            
            System.out.println("✅ File uploaded: " + file.getInfo().getFileId());
            return file;
        } catch (Exception error) {
            System.err.println("❌ File upload failed: " + error.getMessage());
            throw error;
        }
    }

    public byte[] downloadFile(String fileId) throws Exception {
        if (!isReady()) throw new Exception("PrivMX not initialized");
        
        try {
            long downloadHandle = endpoint.storeOpenFile(fileId);
            byte[] fileData = endpoint.storeReadFromFile(downloadHandle);
            endpoint.storeCloseFile(downloadHandle);
            
            System.out.println("✅ File downloaded: " + fileId);
            return fileData;
        } catch (Exception error) {
            System.err.println("❌ File download failed: " + error.getMessage());
            throw error;
        }
    }`;
  }

  generateInboxesFeature(): string {
    return `

    /**
     * Secure Inboxes (Anonymous Submissions) API - Java
     */
    public Inbox createInbox(List<UserWithPubKey> users, String publicMeta, 
                            String privateMeta, FilesConfig filesConfig) throws Exception {
        if (!isReady()) throw new Exception("PrivMX not initialized");
        
        try {
            Inbox inbox = endpoint.inboxCreateInbox(
                connectionId,
                users,
                publicMeta != null ? publicMeta : "{}",
                privateMeta != null ? privateMeta : "{}",
                filesConfig != null ? filesConfig : new FilesConfig()
            );
            
            System.out.println("✅ Inbox created: " + inbox.getInboxId());
            return inbox;
        } catch (Exception error) {
            System.err.println("❌ Inbox creation failed: " + error.getMessage());
            throw error;
        }
    }

    public InboxEntry sendToInbox(String inboxId, byte[] data, String publicMeta, 
                                 String privateMeta, List<InboxFileHandle> files) throws Exception {
        if (!isReady()) throw new Exception("PrivMX not initialized");
        
        try {
            InboxEntry entry = endpoint.inboxSendEntry(
                inboxId,
                publicMeta != null ? publicMeta : "{}",
                privateMeta != null ? privateMeta : "{}",
                data,
                files != null ? files : new ArrayList<>()
            );
            
            System.out.println("✅ Entry sent to inbox: " + entry.getEntryId());
            return entry;
        } catch (Exception error) {
            System.err.println("❌ Sending to inbox failed: " + error.getMessage());
            throw error;
        }
    }

    public PagingList<InboxEntry> getInboxEntries(String inboxId, long skip, long limit) 
            throws Exception {
        if (!isReady()) throw new Exception("PrivMX not initialized");
        
        try {
            return endpoint.inboxListEntries(inboxId, skip, limit);
        } catch (Exception error) {
            System.err.println("❌ Getting inbox entries failed: " + error.getMessage());
            throw error;
        }
    }`;
  }

  generateCryptoFeature(): string {
    return `

    /**
     * Crypto API for Key Management - Java
     */
    public PrivateKey generatePrivateKey() throws Exception {
        if (!isReady()) throw new Exception("PrivMX not initialized");
        
        try {
            PrivateKey privateKey = endpoint.cryptoGeneratePrivateKey();
            System.out.println("✅ Private key generated");
            return privateKey;
        } catch (Exception error) {
            System.err.println("❌ Key generation failed: " + error.getMessage());
            throw error;
        }
    }

    public PublicKey derivePublicKey(PrivateKey privateKey) throws Exception {
        if (!isReady()) throw new Exception("PrivMX not initialized");
        
        try {
            PublicKey publicKey = endpoint.cryptoDerivePublicKey(privateKey);
            System.out.println("✅ Public key derived");
            return publicKey;
        } catch (Exception error) {
            System.err.println("❌ Public key derivation failed: " + error.getMessage());
            throw error;
        }
    }

    public byte[] signData(byte[] data, PrivateKey privateKey) throws Exception {
        if (!isReady()) throw new Exception("PrivMX not initialized");
        
        try {
            byte[] signature = endpoint.cryptoSignData(data, privateKey);
            System.out.println("✅ Data signed");
            return signature;
        } catch (Exception error) {
            System.err.println("❌ Data signing failed: " + error.getMessage());
            throw error;
        }
    }

    public boolean verifySignature(byte[] data, byte[] signature, PublicKey publicKey) 
            throws Exception {
        if (!isReady()) throw new Exception("PrivMX not initialized");
        
        try {
            boolean isValid = endpoint.cryptoVerifySignature(data, signature, publicKey);
            System.out.println("✅ Signature verified: " + isValid);
            return isValid;
        } catch (Exception error) {
            System.err.println("❌ Signature verification failed: " + error.getMessage());
            throw error;
        }
    }`;
  }

  generateThreadsExample(): string {
    return `
            // 🔐 Create a secure thread for messaging
            List<UserWithPubKey> users = Arrays.asList(
                new UserWithPubKey("user1", "USER1_PUBLIC_KEY"),
                new UserWithPubKey("user2", "USER2_PUBLIC_KEY")
            );
            
            Thread thread = privmx.createThread(users, 
                "{\\"title\\": \\"My Secure Chat\\"}", 
                "{\\"description\\": \\"Private conversation\\"}"
            );
            
            // Send a message
            String messageText = "Hello, secure world!";
            privmx.sendMessage(thread.getThreadId(), 
                messageText.getBytes(StandardCharsets.UTF_8),
                "{\\"messageType\\": \\"text\\"}", 
                null
            );
            
            // Get messages
            PagingList<Message> messages = privmx.getMessages(thread.getThreadId(), 0, 10);
            System.out.println("Messages: " + messages.getReadItems().size());`;
  }

  generateStoresExample(): string {
    return `
            // 📁 Create a secure store for file sharing
            List<UserWithPubKey> users = Arrays.asList(
                new UserWithPubKey("user1", "USER1_PUBLIC_KEY"),
                new UserWithPubKey("user2", "USER2_PUBLIC_KEY")
            );
            
            Store store = privmx.createStore(users,
                "{\\"storeName\\": \\"Shared Files\\"}", 
                "{\\"description\\": \\"Team file sharing\\"}"
            );
            
            // Upload a file
            String fileContent = "Hello from a secure file!";
            byte[] fileData = fileContent.getBytes(StandardCharsets.UTF_8);
            File file = privmx.uploadFile(store.getStoreId(), "hello.txt", fileData,
                "{\\"fileName\\": \\"hello.txt\\", \\"fileType\\": \\"text/plain\\"}", 
                null
            );
            
            // Download the file
            byte[] downloadedData = privmx.downloadFile(file.getInfo().getFileId());
            String downloadedContent = new String(downloadedData, StandardCharsets.UTF_8);
            System.out.println("Downloaded: " + downloadedContent);`;
  }

  generateInboxesExample(): string {
    return `
            // 📮 Create an inbox for anonymous submissions
            List<UserWithPubKey> managers = Arrays.asList(
                new UserWithPubKey("manager1", "MANAGER1_PUBLIC_KEY")
            );
            
            FilesConfig filesConfig = new FilesConfig(); // Configure as needed
            Inbox inbox = privmx.createInbox(managers,
                "{\\"inboxName\\": \\"Feedback Form\\"}", 
                "{\\"description\\": \\"Anonymous feedback collection\\"}",
                filesConfig
            );
            
            // Send anonymous entry
            String feedback = "Great product!";
            privmx.sendToInbox(inbox.getInboxId(), 
                feedback.getBytes(StandardCharsets.UTF_8),
                "{\\"submissionType\\": \\"feedback\\"}", 
                "{\\"rating\\": 5}",
                null
            );
            
            // Get inbox entries (managers only)
            PagingList<InboxEntry> entries = privmx.getInboxEntries(inbox.getInboxId(), 0, 10);
            System.out.println("Submissions: " + entries.getReadItems().size());`;
  }

  generateCryptoExample(): string {
    return `
            // 🔐 Generate cryptographic keys
            PrivateKey privateKey = privmx.generatePrivateKey();
            PublicKey publicKey = privmx.derivePublicKey(privateKey);
            System.out.println("Key pair generated successfully");
            
            // Sign and verify data
            String data = "Important message";
            byte[] dataBytes = data.getBytes(StandardCharsets.UTF_8);
            byte[] signature = privmx.signData(dataBytes, privateKey);
            boolean isValid = privmx.verifySignature(dataBytes, signature, publicKey);
            System.out.println("Signature valid: " + isValid);`;
  }
}
