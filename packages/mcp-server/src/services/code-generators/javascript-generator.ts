/**
 * JavaScript/TypeScript Code Generator
 * Generates production-ready setup code for PrivMX WebEndpoint
 */

import { BaseCodeGenerator } from './base-generator.js';

export class JavaScriptGenerator extends BaseCodeGenerator {
  generateSetup(features: string[]): string {
    const hasThreads = this.hasFeature(features, 'threads');
    const hasStores = this.hasFeature(features, 'stores');
    const hasInboxes = this.hasFeature(features, 'inboxes');
    const hasCrypto = this.hasFeature(features, 'crypto');

    const imports = [
      "import { Endpoint } from '@privmx/privmx-webendpoint-sdk';",
    ];

    if (hasThreads) imports.push('// Threads for secure messaging');
    if (hasStores) imports.push('// Stores for encrypted file sharing');
    if (hasInboxes) imports.push('// Inboxes for anonymous submissions');
    if (hasCrypto) imports.push('// Crypto for key management');

    const setupCode = `
/**
 * PrivMX WebEndpoint Setup - Production Ready
 * Generated by PrivMX MCP Server
 */

${this.generateImports(imports)}

class PrivMXManager {
  constructor() {
    this.endpoint = null;
    this.connectionId = null;
    this.isConnected = false;
  }

  /**
   * Initialize PrivMX WebAssembly and connect to Bridge
   */
  async initialize(config) {
    try {
      // Setup WebAssembly assets (required for crypto operations)
      await Endpoint.setup('/path/to/privmx-webendpoint-assets/');
      
      // Create endpoint instance
      this.endpoint = new Endpoint();
      
      // Connect to PrivMX Bridge
      this.connectionId = await this.endpoint.connect({
        userPrivKey: config.userPrivateKey,
        solutionId: config.solutionId,
        platformUrl: config.bridgeUrl || 'https://your-bridge.privmx.dev'
      });
      
      this.isConnected = true;
      console.log('‚úÖ Connected to PrivMX Bridge:', this.connectionId);
      
      return this.connectionId;
    } catch (error) {
      console.error('‚ùå PrivMX initialization failed:', error);
      throw new Error(\`PrivMX setup failed: \${error.message}\`);
    }
  }${hasThreads ? this.generateThreadsFeature() : ''}${hasStores ? this.generateStoresFeature() : ''}${hasInboxes ? this.generateInboxesFeature() : ''}${hasCrypto ? this.generateCryptoFeature() : ''}

  /**
   * Cleanup and disconnect
   */
  async disconnect() {
    try {
      if (this.endpoint && this.connectionId) {
        await this.endpoint.disconnect(this.connectionId);
        this.isConnected = false;
        console.log('‚úÖ Disconnected from PrivMX Bridge');
      }
    } catch (error) {
      console.error('‚ùå Disconnect failed:', error);
    }
  }

  /**
   * Check connection status
   */
  isReady() {
    return this.isConnected && this.endpoint && this.connectionId;
  }
}

// Usage Example
async function main() {
  const privmx = new PrivMXManager();
  
  try {
    await privmx.initialize({
      userPrivateKey: 'YOUR_PRIVATE_KEY_WIF',
      solutionId: 'YOUR_SOLUTION_ID',
      bridgeUrl: 'https://your-bridge.privmx.dev'
    });
    
    ${hasThreads ? this.generateThreadsExample() : ''}${hasStores ? this.generateStoresExample() : ''}${hasInboxes ? this.generateInboxesExample() : ''}${hasCrypto ? this.generateCryptoExample() : ''}
  } catch (error) {
    console.error('Application error:', error);
  } finally {
    await privmx.disconnect();
  }
}

// Uncomment to run
// main().catch(console.error);

export { PrivMXManager };`;

    return setupCode;
  }

  generateThreadsFeature(): string {
    return `

  /**
   * Secure Threads (Messaging) API
   */
  async createThread(users, publicMeta = {}, privateMeta = {}) {
    if (!this.isReady()) throw new Error('PrivMX not initialized');
    
    try {
      const thread = await this.endpoint.thread.createThread(
        this.connectionId,
        JSON.stringify(publicMeta),
        JSON.stringify(privateMeta),
        users // Array of {userId: string, pubKey: string}
      );
      
      console.log('‚úÖ Thread created:', thread.threadId);
      return thread;
    } catch (error) {
      console.error('‚ùå Thread creation failed:', error);
      throw error;
    }
  }

  async sendMessage(threadId, data, publicMeta = {}, privateMeta = {}) {
    if (!this.isReady()) throw new Error('PrivMX not initialized');
    
    try {
      const message = await this.endpoint.thread.sendMessage(
        threadId,
        JSON.stringify(publicMeta),
        JSON.stringify(privateMeta),
        data
      );
      
      console.log('‚úÖ Message sent:', message.messageId);
      return message;
    } catch (error) {
      console.error('‚ùå Message sending failed:', error);
      throw error;
    }
  }

  async getMessages(threadId, skip = 0, limit = 10) {
    if (!this.isReady()) throw new Error('PrivMX not initialized');
    
    try {
      const messages = await this.endpoint.thread.getMessages(threadId, skip, limit);
      return messages;
    } catch (error) {
      console.error('‚ùå Getting messages failed:', error);
      throw error;
    }
  }`;
  }

  generateStoresFeature(): string {
    return `

  /**
   * Secure Stores (File Sharing) API  
   */
  async createStore(users, publicMeta = {}, privateMeta = {}) {
    if (!this.isReady()) throw new Error('PrivMX not initialized');
    
    try {
      const store = await this.endpoint.store.createStore(
        this.connectionId,
        JSON.stringify(publicMeta),
        JSON.stringify(privateMeta),
        users // Array of {userId: string, pubKey: string}
      );
      
      console.log('‚úÖ Store created:', store.storeId);
      return store;
    } catch (error) {
      console.error('‚ùå Store creation failed:', error);
      throw error;
    }
  }

  async uploadFile(storeId, fileName, fileData, publicMeta = {}, privateMeta = {}) {
    if (!this.isReady()) throw new Error('PrivMX not initialized');
    
    try {
      const file = await this.endpoint.store.createFile(
        storeId,
        JSON.stringify(publicMeta),
        JSON.stringify(privateMeta),
        fileData.length
      );

      // Write file data
      const uploadHandle = await this.endpoint.store.openFile(file.fileId);
      await this.endpoint.store.writeToFile(uploadHandle, fileData);
      await this.endpoint.store.closeFile(uploadHandle);
      
      console.log('‚úÖ File uploaded:', file.fileId);
      return file;
    } catch (error) {
      console.error('‚ùå File upload failed:', error);
      throw error;
    }
  }

  async downloadFile(fileId) {
    if (!this.isReady()) throw new Error('PrivMX not initialized');
    
    try {
      const downloadHandle = await this.endpoint.store.openFile(fileId);
      const fileData = await this.endpoint.store.readFromFile(downloadHandle);
      await this.endpoint.store.closeFile(downloadHandle);
      
      console.log('‚úÖ File downloaded:', fileId);
      return fileData;
    } catch (error) {
      console.error('‚ùå File download failed:', error);
      throw error;
    }
  }`;
  }

  generateInboxesFeature(): string {
    return `

  /**
   * Secure Inboxes (Anonymous Submissions) API
   */
  async createInbox(users, publicMeta = {}, privateMeta = {}, filesConfig = {}) {
    if (!this.isReady()) throw new Error('PrivMX not initialized');
    
    try {
      const inbox = await this.endpoint.inbox.createInbox(
        this.connectionId,
        JSON.stringify(publicMeta),
        JSON.stringify(privateMeta),
        users, // Array of {userId: string, pubKey: string}
        JSON.stringify(filesConfig)
      );
      
      console.log('‚úÖ Inbox created:', inbox.inboxId);
      return inbox;
    } catch (error) {
      console.error('‚ùå Inbox creation failed:', error);
      throw error;
    }
  }

  async sendToInbox(inboxId, data, publicMeta = {}, privateMeta = {}, files = []) {
    if (!this.isReady()) throw new Error('PrivMX not initialized');
    
    try {
      const entry = await this.endpoint.inbox.sendEntry(
        inboxId,
        JSON.stringify(publicMeta),
        JSON.stringify(privateMeta),
        data,
        files
      );
      
      console.log('‚úÖ Entry sent to inbox:', entry.entryId);
      return entry;
    } catch (error) {
      console.error('‚ùå Sending to inbox failed:', error);
      throw error;
    }
  }

  async getInboxEntries(inboxId, skip = 0, limit = 10) {
    if (!this.isReady()) throw new Error('PrivMX not initialized');
    
    try {
      const entries = await this.endpoint.inbox.getEntries(inboxId, skip, limit);
      return entries;
    } catch (error) {
      console.error('‚ùå Getting inbox entries failed:', error);
      throw error;
    }
  }`;
  }

  generateCryptoFeature(): string {
    return `

  /**
   * Crypto API for Key Management
   */
  generateKeyPair() {
    if (!this.isReady()) throw new Error('PrivMX not initialized');
    
    try {
      const keyPair = this.endpoint.crypto.generateKeyPair();
      console.log('‚úÖ Key pair generated');
      return {
        privateKey: keyPair.privateKey,
        publicKey: keyPair.publicKey
      };
    } catch (error) {
      console.error('‚ùå Key generation failed:', error);
      throw error;
    }
  }

  signData(data, privateKey) {
    if (!this.isReady()) throw new Error('PrivMX not initialized');
    
    try {
      const signature = this.endpoint.crypto.signData(data, privateKey);
      console.log('‚úÖ Data signed');
      return signature;
    } catch (error) {
      console.error('‚ùå Data signing failed:', error);
      throw error;
    }
  }

  verifySignature(data, signature, publicKey) {
    if (!this.isReady()) throw new Error('PrivMX not initialized');
    
    try {
      const isValid = this.endpoint.crypto.verifySignature(data, signature, publicKey);
      console.log('‚úÖ Signature verified:', isValid);
      return isValid;
    } catch (error) {
      console.error('‚ùå Signature verification failed:', error);
      throw error;
    }
  }`;
  }

  generateThreadsExample(): string {
    return `
    // üîê Create a secure thread for messaging
    const users = [
      { userId: 'user1', pubKey: 'USER1_PUBLIC_KEY' },
      { userId: 'user2', pubKey: 'USER2_PUBLIC_KEY' }
    ];
    
    const thread = await privmx.createThread(users, {
      title: 'My Secure Chat'
    }, {
      description: 'Private conversation'
    });
    
    // Send a message
    await privmx.sendMessage(thread.threadId, 'Hello, secure world!', {
      messageType: 'text'
    });
    
    // Get messages
    const messages = await privmx.getMessages(thread.threadId);
    console.log('Messages:', messages);`;
  }

  generateStoresExample(): string {
    return `
    // üìÅ Create a secure store for file sharing
    const users = [
      { userId: 'user1', pubKey: 'USER1_PUBLIC_KEY' },
      { userId: 'user2', pubKey: 'USER2_PUBLIC_KEY' }
    ];
    
    const store = await privmx.createStore(users, {
      storeName: 'Shared Files'
    }, {
      description: 'Team file sharing'
    });
    
    // Upload a file
    const fileData = new TextEncoder().encode('Hello from a secure file!');
    const file = await privmx.uploadFile(store.storeId, 'hello.txt', fileData, {
      fileName: 'hello.txt',
      fileType: 'text/plain'
    });
    
    // Download the file
    const downloadedData = await privmx.downloadFile(file.fileId);
    console.log('Downloaded:', new TextDecoder().decode(downloadedData));`;
  }

  generateInboxesExample(): string {
    return `
    // üìÆ Create an inbox for anonymous submissions
    const managers = [
      { userId: 'manager1', pubKey: 'MANAGER1_PUBLIC_KEY' }
    ];
    
    const inbox = await privmx.createInbox(managers, {
      inboxName: 'Feedback Form'
    }, {
      description: 'Anonymous feedback collection'
    });
    
    // Send anonymous entry (can be done without authentication)
    await privmx.sendToInbox(inbox.inboxId, 'Great product!', {
      submissionType: 'feedback'
    }, {
      rating: 5
    });
    
    // Get inbox entries (managers only)
    const entries = await privmx.getInboxEntries(inbox.inboxId);
    console.log('Submissions:', entries);`;
  }

  generateCryptoExample(): string {
    return `
    // üîê Generate cryptographic keys
    const keyPair = privmx.generateKeyPair();
    console.log('Private Key:', keyPair.privateKey);
    console.log('Public Key:', keyPair.publicKey);
    
    // Sign and verify data
    const data = 'Important message';
    const signature = privmx.signData(data, keyPair.privateKey);
    const isValid = privmx.verifySignature(data, signature, keyPair.publicKey);
    console.log('Signature valid:', isValid);`;
  }
}

export class TypeScriptGenerator extends JavaScriptGenerator {
  generateSetup(features: string[]): string {
    const hasThreads = this.hasFeature(features, 'threads');
    const hasStores = this.hasFeature(features, 'stores');
    const hasInboxes = this.hasFeature(features, 'inboxes');
    const hasCrypto = this.hasFeature(features, 'crypto');

    const imports = [
      "import { Endpoint } from '@privmx/privmx-webendpoint-sdk';",
    ];

    if (hasThreads) imports.push('// Threads for secure messaging');
    if (hasStores) imports.push('// Stores for encrypted file sharing');
    if (hasInboxes) imports.push('// Inboxes for anonymous submissions');
    if (hasCrypto) imports.push('// Crypto for key management');

    const setupCode = `
/**
 * PrivMX WebEndpoint Setup - TypeScript Production Ready
 * Generated by PrivMX MCP Server
 */

${this.generateImports(imports)}

interface PrivMXConfig {
  userPrivateKey: string;
  solutionId: string;
  bridgeUrl?: string;
}

interface User {
  userId: string;
  pubKey: string;
}

class PrivMXManager {
  private endpoint: Endpoint | null = null;
  private connectionId: string | null = null;
  private isConnected: boolean = false;

  /**
   * Initialize PrivMX WebAssembly and connect to Bridge
   */
  async initialize(config: PrivMXConfig): Promise<string> {
    try {
      // Setup WebAssembly assets (required for crypto operations)
      await Endpoint.setup('/path/to/privmx-webendpoint-assets/');
      
      // Create endpoint instance
      this.endpoint = new Endpoint();
      
      // Connect to PrivMX Bridge
      this.connectionId = await this.endpoint.connect({
        userPrivKey: config.userPrivateKey,
        solutionId: config.solutionId,
        platformUrl: config.bridgeUrl || 'https://your-bridge.privmx.dev'
      });
      
      this.isConnected = true;
      console.log('‚úÖ Connected to PrivMX Bridge:', this.connectionId);
      
      return this.connectionId;
    } catch (error) {
      console.error('‚ùå PrivMX initialization failed:', error);
      throw new Error(\`PrivMX setup failed: \${(error as Error).message}\`);
    }
  }${hasThreads ? this.generateThreadsFeature() : ''}${hasStores ? this.generateStoresFeature() : ''}${hasInboxes ? this.generateInboxesFeature() : ''}${hasCrypto ? this.generateCryptoFeature() : ''}

  /**
   * Cleanup and disconnect
   */
  async disconnect(): Promise<void> {
    try {
      if (this.endpoint && this.connectionId) {
        await this.endpoint.disconnect(this.connectionId);
        this.isConnected = false;
        console.log('‚úÖ Disconnected from PrivMX Bridge');
      }
    } catch (error) {
      console.error('‚ùå Disconnect failed:', error);
    }
  }

  /**
   * Check connection status
   */
  isReady(): boolean {
    return this.isConnected && this.endpoint !== null && this.connectionId !== null;
  }
}

// Usage Example
async function main(): Promise<void> {
  const privmx = new PrivMXManager();
  
  try {
    await privmx.initialize({
      userPrivateKey: 'YOUR_PRIVATE_KEY_WIF',
      solutionId: 'YOUR_SOLUTION_ID',
      bridgeUrl: 'https://your-bridge.privmx.dev'
    });
    
    ${hasThreads ? this.generateThreadsExample() : ''}${hasStores ? this.generateStoresExample() : ''}${hasInboxes ? this.generateInboxesExample() : ''}${hasCrypto ? this.generateCryptoExample() : ''}
  } catch (error) {
    console.error('Application error:', error);
  } finally {
    await privmx.disconnect();
  }
}

// Uncomment to run
// main().catch(console.error);

export { PrivMXManager, type PrivMXConfig, type User };`;

    return setupCode;
  }
}
