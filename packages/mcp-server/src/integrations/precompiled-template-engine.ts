/**
 * Precompiled Template Engine
 * Uses precompiled handlebars templates and runtime - no webpack issues!
 * Based on handlebars-loader research: https://github.com/pcardune/handlebars-loader
 */

import {
  TemplateGenerationRequest,
  IntegrationResult,
  PlopTemplateData,
} from './types.js';

export class PrecompiledTemplateEngine {
  private templatesPath: string;
  private outputPath: string;
  private runtime: unknown = null;

  constructor(
    templatesPath = './src/templates/privmx',
    outputPath = './generated'
  ) {
    this.templatesPath = templatesPath;
    this.outputPath = outputPath;
  }

  /**
   * Load handlebars runtime (much smaller, no compilation issues)
   */
  private async loadRuntime(): Promise<unknown> {
    if (this.runtime) return this.runtime;

    try {
      // Use handlebars/runtime instead of full handlebars
      // This is much smaller and doesn't cause webpack issues
      if (typeof window === 'undefined') {
        // Node.js environment
        this.runtime = await import('handlebars/runtime');
      } else {
        // Browser environment - runtime should be available globally
        this.runtime = (
          globalThis as unknown as Record<string, unknown>
        ).Handlebars;
      }
      return this.runtime;
    } catch {
      console.warn(
        '‚ö†Ô∏è  Handlebars runtime not available, using simple template processing'
      );
      return null;
    }
  }

  /**
   * Precompiled template functions (defined as string templates that compile to functions)
   */
  private getPrecompiledTemplates(): Record<
    string,
    (data: PlopTemplateData) => string
  > {
    // These would normally be imported from .handlebars files via handlebars-loader
    // For now, we'll define them as template functions

    return {
      'package.json': (data: PlopTemplateData) => `{
  "name": "${this.kebabCase(data.projectName)}",
  "version": "1.0.0",
  "description": "PrivMX ${data.framework} application",
  "main": "${data.isNodejs ? 'index.js' : `src/main.${data.isTypeScript ? 'ts' : 'js'}`}",
  "scripts": {${
    data.isReact
      ? `
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview"`
      : ''
  }${
    data.isNodejs
      ? `
    "start": "node index.js",
    "dev": "nodemon index.js"`
      : ''
  }
  },
  "dependencies": {
    "@privmx/privmx-webendpoint": "^2.0.0"${
      data.isReact
        ? `,
    "react": "^18.0.0",
    "react-dom": "^18.0.0"`
        : ''
    }${
      data.hasMessaging
        ? `,
    "@privmx/privmx-threads": "^1.0.0"`
        : ''
    }${
      data.hasFileSharing
        ? `,
    "@privmx/privmx-stores": "^1.0.0"`
        : ''
    }${
      data.hasNotifications
        ? `,
    "@privmx/privmx-inboxes": "^1.0.0"`
        : ''
    }
  }${
    data.isTypeScript
      ? `,
  "devDependencies": {
    "typescript": "^5.0.0"${
      data.isReact
        ? `,
    "@types/react": "^18.0.0",
    "@types/react-dom": "^18.0.0",
    "@vitejs/plugin-react": "^4.0.0",
    "vite": "^5.0.0"`
        : ''
    }
  }`
      : ''
  }
}`,

      'App.tsx': (data: PlopTemplateData) => `import React from 'react';${
        data.hasMessaging
          ? `
import { usePrivMXThreads } from './hooks/usePrivMXThreads';`
          : ''
      }${
        data.hasFileSharing
          ? `
import { usePrivMXStores } from './hooks/usePrivMXStores';`
          : ''
      }

function App() {${
        data.hasMessaging
          ? `
  const { threads, sendMessage } = usePrivMXThreads();`
          : ''
      }${
        data.hasFileSharing
          ? `
  const { stores, uploadFile } = usePrivMXStores();`
          : ''
      }

  return (
    <div className="App">
      <h1>${data.projectName}</h1>
      <p>PrivMX ${data.framework} Application</p>
      ${
        data.hasMessaging
          ? `
      <div>
        <h2>Secure Messaging</h2>
        {/* Add your messaging UI here */}
      </div>`
          : ''
      }
      ${
        data.hasFileSharing
          ? `
      <div>
        <h2>File Sharing</h2>
        {/* Add your file sharing UI here */}
      </div>`
          : ''
      }
    </div>
  );
}

export default App;`,

      'README.md': (data: PlopTemplateData) => `# ${data.projectName}

A PrivMX ${data.framework} application with the following features:
${data.features.map((f) => `- ${f}`).join('\n')}

## Getting Started

1. Install dependencies:
   \`\`\`bash
   npm install
   \`\`\`

2. Configure your PrivMX connection in \`src/config/privmx.js\`

3. Start the development server:
   \`\`\`bash
   ${data.isReact ? 'npm run dev' : ''}
   ${data.isNodejs ? 'npm run dev' : ''}
   \`\`\`

## PrivMX Configuration

Update your PrivMX configuration with your solution credentials:

\`\`\`javascript
export const privmxConfig = {
  solutionId: '${data.privmxConfig.solutionId}',
  platformUrl: '${data.privmxConfig.platformUrl}',
  // Add your specific configuration here
};
\`\`\`

Generated by PrivMX MCP Server with precompiled templates.`,

      'usePrivMX.ts': (
        _data: PlopTemplateData
      ) => `import { useEffect, useState } from 'react';
import { WebEndpoint } from '@privmx/privmx-webendpoint';

export interface PrivMXConfig {
  solutionId: string;
  platformUrl: string;
  userPrivKey: string;
}

export const usePrivMX = (config: PrivMXConfig) => {
  const [endpoint, setEndpoint] = useState<WebEndpoint | null>(null);
  const [isConnected, setIsConnected] = useState(false);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const connect = async () => {
      try {
        const webEndpoint = new WebEndpoint();
        await webEndpoint.connect(
          config.userPrivKey,
          config.solutionId,
          config.platformUrl
        );
        setEndpoint(webEndpoint);
        setIsConnected(true);
      } catch (err) {
        setError(err instanceof Error ? err.message : 'Connection failed');
      }
    };

    connect();

    return () => {
      if (endpoint) {
        endpoint.disconnect();
      }
    };
  }, [config]);

  return { endpoint, isConnected, error };
};`,
    };
  }

  /**
   * Simple kebab-case conversion
   */
  private kebabCase(str: string): string {
    return str
      .toLowerCase()
      .replace(/[^a-z0-9]/g, '-')
      .replace(/-+/g, '-')
      .replace(/^-|-$/g, '');
  }

  /**
   * Generate application from precompiled templates
   */
  async generateFromTemplate(
    request: TemplateGenerationRequest
  ): Promise<
    IntegrationResult<{ files: { path: string; content: string }[] }>
  > {
    try {
      console.log(
        `üì¶ Generating ${request.templateId} application (precompiled templates)...`
      );

      // Prepare template data
      const templateData = this.prepareTemplateData(request);

      // Get precompiled templates
      const templates = this.getPrecompiledTemplates();

      // Generate files based on framework and template
      const files = this.generateFilesFromTemplates(
        request,
        templateData,
        templates
      );

      console.log(
        `‚úÖ Generated ${files.length} files successfully (precompiled)`
      );

      return {
        success: true,
        data: { files },
        metadata: {
          toolUsed: 'plop',
          executionTime: Date.now(),
          filesGenerated: files.length,
        },
      };
    } catch (error) {
      return {
        success: false,
        errors: [
          error instanceof Error
            ? error.message
            : 'Unknown error in precompiled template generation',
        ],
        metadata: {
          toolUsed: 'plop',
          executionTime: 0,
        },
      };
    }
  }

  /**
   * Generate files from precompiled templates
   */
  private generateFilesFromTemplates(
    request: TemplateGenerationRequest,
    data: PlopTemplateData,
    templates: Record<string, (data: PlopTemplateData) => string>
  ): { path: string; content: string }[] {
    const files: { path: string; content: string }[] = [];

    // Always generate package.json
    files.push({
      path: 'package.json',
      content: templates['package.json'](data),
    });

    // Generate framework-specific files
    if (request.framework === 'react') {
      files.push({
        path: `src/App.${data.isTypeScript ? 'tsx' : 'jsx'}`,
        content: templates['App.tsx'](data),
      });

      if (data.hasMessaging || data.hasFileSharing) {
        files.push({
          path: `src/hooks/usePrivMX.${data.isTypeScript ? 'ts' : 'js'}`,
          content: templates['usePrivMX.ts'](data),
        });
      }
    }

    // Always generate README
    files.push({
      path: 'README.md',
      content: templates['README.md'](data),
    });

    // Add configuration file
    files.push({
      path: `src/config/privmx.${data.isTypeScript ? 'ts' : 'js'}`,
      content: `export const privmxConfig = {
  solutionId: '${data.privmxConfig.solutionId}',
  platformUrl: '${data.privmxConfig.platformUrl}',
  apiEndpoints: ${JSON.stringify(data.privmxConfig.apiEndpoints, null, 2)},
};`,
    });

    return files;
  }

  /**
   * Prepare template data from request
   */
  private prepareTemplateData(
    request: TemplateGenerationRequest
  ): PlopTemplateData {
    return {
      projectName: request.projectName,
      appName: request.projectName,
      framework: request.framework,
      language: request.language,
      features: request.features,
      privmxConfig: {
        solutionId: request.privmxConfig.solutionId || 'your-solution-id',
        platformUrl: request.privmxConfig.platformUrl || 'https://privmx.cloud',
        apiEndpoints: request.privmxConfig.apiEndpoints,
      },
      // Framework flags
      isReact: request.framework === 'react',
      isVue: request.framework === 'vue',
      isVanilla: request.framework === 'vanilla',
      isNodejs: request.framework === 'nodejs',
      // Language flags
      isTypeScript: request.language === 'typescript',
      isJavaScript: request.language === 'javascript',
      // Feature flags
      hasMessaging: request.features.includes('messaging'),
      hasFileSharing: request.features.includes('file-sharing'),
      hasNotifications: request.features.includes('notifications'),
      hasAuth: request.features.includes('auth'),
      // User context
      skillLevel: request.userContext.skillLevel,
      includeTests: request.userContext.skillLevel !== 'beginner',
      includeComments: request.userContext.skillLevel === 'beginner',
    };
  }

  /**
   * Get available templates
   */
  async getAvailableTemplates(): Promise<
    Array<{ name: string; description: string; path: string }>
  > {
    return [
      {
        name: 'secure-chat',
        description: 'Secure messaging application with PrivMX Threads',
        path: 'precompiled',
      },
      {
        name: 'file-sharing',
        description: 'File sharing application with PrivMX Stores',
        path: 'precompiled',
      },
      {
        name: 'feedback-inbox',
        description: 'Feedback collection system with PrivMX Inboxes',
        path: 'precompiled',
      },
    ];
  }
}
