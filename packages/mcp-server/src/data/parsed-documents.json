{
  "documents": [
    {
      "pageContent": "---\ntitle: Entries\n---\n\nAll the data sent by someone to an Inbox is called an Entry.\nIn Threads and Stores, a user must be assigned to the container to send data. In Inboxes, however, \nanyone who has Inbox ID can send a reply (assuming they have the Bridge URL and Solution ID).\n\n:::info\n\nBefore working with Inboxes, follow our [Getting Started Guide](./getting-started). It will show you how to set up your project to work with PrivMX Bridge.\\\n\\\nThe sample code on this page is based on the **[initial assumptions](./getting-started#initial-assumptions)**.\\\n\\\nEntry's [`publicMeta` and `privateMeta`](../start/public-private-meta) fields support any kind of data formats encoded to byte arrays. Examples in this section use Swift serialization to JSON format.\n\n:::",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/swift/entries.mdx",
        "type": "mdx",
        "chunkIndex": 0,
        "lastModified": "2025-06-05T19:33:57.851Z",
        "size": 766
      }
    },
    {
      "pageContent": "### Assumptions \nIn further examples, the following structures are used:\n```swift\nstruct InboxPublicEntry:Codable{\n    let name: String\n    let surname: String\n    let email: String\n    let comment: String\n}",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/swift/entries.mdx",
        "type": "mdx",
        "chunkIndex": 1,
        "headers": [
          "Assumptions"
        ],
        "title": "Assumptions",
        "lastModified": "2025-06-05T19:33:57.851Z",
        "size": 207
      }
    },
    {
      "pageContent": "```\n\nHaving established public connection and `inboxApi`, you can send data to the Inbox:\n\n<Tabs groupId=\"variant\" items={[\"Basic\",\"With Files\"]}>\n<Tab>\n```swift\n\nlet inboxID = \"INBOX_ID\"\n\nlet inboxPublicEntry = InboxPublicEntry(\n    name: \"name\",\n    surname: \"surname\",\n    email: \"email\",\n    comment: \"comment\")\n\nguard let inboxPublicEntryData = try? JSONEncoder().encode(inboxPublicEntry) else {return}\n\nguard let inboxHandle = try? publicEndpointSession?.inboxApi?.prepareEntry(in: inboxID, containing: inboxPublicEntryData, attaching: [], as: nil)  else {return}\n\ntry? publicEndpointSession?.inboxApi?.sendEntry(to: inboxHandle)\n\n\n```\n</Tab>\n\n<Tab>\n<div className={'fd-steps'}>\n    <div className={'fd-step'}>\n        Create `InboxFileHandle` for each file:\n\n        ```swift\n        let inboxID = \"INBOX_ID\"\n\n        let fileSize:Int64 = 0 // actual file size\n        let data:Data = Data() // actual file data",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/swift/entries.mdx",
        "type": "mdx",
        "chunkIndex": 2,
        "codeBlocks": [
          "```\n\nHaving established public connection and `inboxApi`, you can send data to the Inbox:\n\n<Tabs groupId=\"variant\" items={[\"Basic\",\"With Files\"]}>\n<Tab>\n```",
          "```\n</Tab>\n\n<Tab>\n<div className={'fd-steps'}>\n    <div className={'fd-step'}>\n        Create `InboxFileHandle` for each file:\n\n        ```"
        ],
        "lastModified": "2025-06-05T19:33:57.851Z",
        "size": 918
      }
    },
    {
      "pageContent": "```swift\n        let inboxID = \"INBOX_ID\"\n\n        let fileSize:Int64 = 0 // actual file size\n        let data:Data = Data() // actual file data\n\n        guard let inboxFileHandle = try? publicEndpointSession?.inboxApi?.createFileHandle(\n        withPublicMeta: Data(),\n        withPrivateMeta: Data(),\n        forSize: fileSize) else {return}\n        ```\n    </div>\n    <div className={'fd-step'}>\n        Create `InboxHandle` with all `InboxFileHandle` for files, passed as a parameter\n\n        ```swift\n\n        guard let inboxHandle = try? publicEndpointSession?.inboxApi?.prepareEntry(\n        in: inboxID,\n        containing: inboxPublicEntryData, //as in Basic Example\n        attaching: [inboxFileHandle],\n        as: nil)  else {return}\n        ```\n    </div>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/swift/entries.mdx",
        "type": "mdx",
        "chunkIndex": 3,
        "codeBlocks": [
          "```swift\n        let inboxID = \"INBOX_ID\"\n\n        let fileSize:Int64 = 0 // actual file size\n        let data:Data = Data() // actual file data\n\n        guard let inboxFileHandle = try? publicEndpointSession?.inboxApi?.createFileHandle(\n        withPublicMeta: Data(),\n        withPrivateMeta: Data(),\n        forSize: fileSize) else {return}\n        ```",
          "```swift\n\n        guard let inboxHandle = try? publicEndpointSession?.inboxApi?.prepareEntry(\n        in: inboxID,\n        containing: inboxPublicEntryData, //as in Basic Example\n        attaching: [inboxFileHandle],\n        as: nil)  else {return}\n        ```"
        ],
        "lastModified": "2025-06-05T19:33:57.851Z",
        "size": 768
      }
    },
    {
      "pageContent": "<div className={'fd-step'}>\n        Upload and close all files using `writeToFile` and `closeFile` methods from `InboxApi`:\n        ```swift\n        try? publicEndpointSession?.inboxApi?.writeToFile(inboxFileHandle, in: inboxHandle, uploading: data)\n        try? publicEndpointSession?.inboxApi?.closeFile(withHandle: inboxFileHandle)\n        ```\n    </div>\n    <div className={'fd-step'}>\n        Call `sendEntry` which starts sending `inboxPublicEntryData` data to Inbox:\n        ```swift\n        try? publicEndpointSession?.inboxApi?.sendEntry(to: inboxHandle)\n        ```\n    </div>\n</div>\n\n</Tab>\n\n</Tabs>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/swift/entries.mdx",
        "type": "mdx",
        "chunkIndex": 4,
        "codeBlocks": [
          "```swift\n        try? publicEndpointSession?.inboxApi?.writeToFile(inboxFileHandle, in: inboxHandle, uploading: data)\n        try? publicEndpointSession?.inboxApi?.closeFile(withHandle: inboxFileHandle)\n        ```",
          "```swift\n        try? publicEndpointSession?.inboxApi?.sendEntry(to: inboxHandle)\n        ```"
        ],
        "lastModified": "2025-06-05T19:33:57.851Z",
        "size": 610
      }
    },
    {
      "pageContent": "## Getting Entries\n\nCreated entries can be listed by non-public connections created using `PrivmxEndpoint`.\n\n\n<Tabs groupId=\"variant\" items={[\"Most Recent\",\"Oldest\"]}>\n<Tab>\nFetching the most recent Entries in given Inbox\n```swift\nlet inboxID = \"INBOX_ID\"\nlet startIndex:Int64 = 0\nlet pageSize:Int64 = 100\n\nvar entires = try? endpointSession?.inboxApi?.listEntries(\n    from: inboxID,\n    basedOn: privmx.endpoint.core.PagingQuery(skip: startIndex, limit: pageSize, sortOrder: .desc)\n)\n```\n</Tab>\n\n<Tab>\nFetching the oldest Entries (by creation date) in given Inbox:\n```swift\nlet inboxID = \"INBOX_ID\"\nlet startIndex:Int64 = 0\nlet pageSize:Int64 = 100\n    \nvar entires = try? endpointSession?.inboxApi?.listEntries(\n    from: inboxID,\n    basedOn: privmx.endpoint.core.PagingQuery(skip: startIndex, limit: pageSize, sortOrder: .asc)\n)\n```\n</Tab>\n</Tabs>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/swift/entries.mdx",
        "type": "mdx",
        "chunkIndex": 5,
        "headers": [
          "Getting Entries"
        ],
        "title": "Getting Entries",
        "codeBlocks": [
          "```swift\nlet inboxID = \"INBOX_ID\"\nlet startIndex:Int64 = 0\nlet pageSize:Int64 = 100\n\nvar entires = try? endpointSession?.inboxApi?.listEntries(\n    from: inboxID,\n    basedOn: privmx.endpoint.core.PagingQuery(skip: startIndex, limit: pageSize, sortOrder: .desc)\n)\n```",
          "```swift\nlet inboxID = \"INBOX_ID\"\nlet startIndex:Int64 = 0\nlet pageSize:Int64 = 100\n    \nvar entires = try? endpointSession?.inboxApi?.listEntries(\n    from: inboxID,\n    basedOn: privmx.endpoint.core.PagingQuery(skip: startIndex, limit: pageSize, sortOrder: .asc)\n)\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.851Z",
        "size": 852
      }
    },
    {
      "pageContent": "## Reading Entries Files\n\nFiles from Entries can be read by non-public connections created using `PrivmxEndpoint` class\n\n```swift\nlet inboxID = \"INBOX_ID\"\nlet entryID = \"ENTRY_ID\"\nlet startIndex:Int64 = 0\nlet pageSize:Int64 = 100\n\nlet inboxEntry = try? endpointSession?.inboxApi?.readEntry(entryID)\n\nvar files =  inboxEntry?.files\nvar filesContents = files.map { file in\n    try? endpointSession?.inboxApi?.openFile(\"\\(file[0].info.fileId)\")\n}?.map{ fileHandle in\nvar content = Data()\nvar chunk : Data\nrepeat {\n    chunk = (try? endpointSession?.inboxApi?.readFromFile(withHandle: fileHandle, length: PrivMXStoreFileHandler.RecommendedChunkSize)) ?? Data()\n    content.append(chunk)\n} while chunk.count == PrivMXStoreFileHandler.RecommendedChunkSize\nreturn content\n}\n\n```",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/swift/entries.mdx",
        "type": "mdx",
        "chunkIndex": 6,
        "headers": [
          "Reading Entries Files"
        ],
        "title": "Reading Entries Files",
        "codeBlocks": [
          "```swift\nlet inboxID = \"INBOX_ID\"\nlet entryID = \"ENTRY_ID\"\nlet startIndex:Int64 = 0\nlet pageSize:Int64 = 100\n\nlet inboxEntry = try? endpointSession?.inboxApi?.readEntry(entryID)\n\nvar files =  inboxEntry?.files\nvar filesContents = files.map { file in\n    try? endpointSession?.inboxApi?.openFile(\"\\(file[0].info.fileId)\")\n}?.map{ fileHandle in\nvar content = Data()\nvar chunk : Data\nrepeat {\n    chunk = (try? endpointSession?.inboxApi?.readFromFile(withHandle: fileHandle, length: PrivMXStoreFileHandler.RecommendedChunkSize)) ?? Data()\n    content.append(chunk)\n} while chunk.count == PrivMXStoreFileHandler.RecommendedChunkSize\nreturn content\n}\n\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.851Z",
        "size": 771
      }
    },
    {
      "pageContent": "---\ntitle: Overview\n---\n\nEvents enable your application to react dynamically to changes within user context. \\\n\\\nThese events are triggered automatically when a relevant change occurs. \nYou can subscribe to them by registering event listeners. This allows you to respond to changes as they happen in real-time.\n\n\n## Caveats\n\n- All callback are related to the connection on which they were registered.\n- Calling [`endpointContainer.stopListening()`](../reference/privmx-endpoint-swift-extra/core/privmx-endpoint-container) does not delete event listeners.\n- Disconnecting deletes all event listeners related to the connection.",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/swift/events.mdx",
        "type": "mdx",
        "chunkIndex": 0,
        "headers": [
          "Caveats"
        ],
        "title": "Caveats",
        "lastModified": "2025-06-05T19:33:57.851Z",
        "size": 625
      }
    },
    {
      "pageContent": "## Quick Start\n\n<div className={'fd-steps'}>\n   <div className={'fd-step'}>\n       Start the event loop:\n\n       ```swift\n       endpointContainer.startListening()\n       ```\n   </div>\n    <div className={'fd-step'}>\n        Add event listener for `StoreFileUpdatedEvent` related with `callbackID`:\n\n        ```swift\n        var storeId = \"STORE_ID\"\n        _ = try? endpointSession?.registerCallback(\n        for: privmx.endpoint.store.StoreFileUpdatedEvent.self,\n        from: EventChannel.storeFiles(storeID: storeId)\n        ) {\n        eventData in\n    }\n        ```\n    </div>\n    <div className={'fd-step'}>\n        Remove the event listener when no longer needed:\n\n        ```swift\n        var storeId = \"STORE_ID\"\n        guard let callbackId = try? endpointSession?.registerCallback(\n        for: privmx.endpoint.store.StoreFileUpdatedEvent.self,\n        from: EventChannel.storeFiles(storeID: storeId),\n        { eventData in\n        }\n        ) else {return}\n\n        // when no longer needed\n        endpointSession?.deleteCallback(callbackId)\n        ```\n    </div>\n</div>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/swift/events.mdx",
        "type": "mdx",
        "chunkIndex": 1,
        "headers": [
          "Quick Start"
        ],
        "title": "Quick Start",
        "codeBlocks": [
          "```swift\n       endpointContainer.startListening()\n       ```",
          "```swift\n        var storeId = \"STORE_ID\"\n        _ = try? endpointSession?.registerCallback(\n        for: privmx.endpoint.store.StoreFileUpdatedEvent.self,\n        from: EventChannel.storeFiles(storeID: storeId)\n        ) {\n        eventData in\n    }\n        ```",
          "```swift\n        var storeId = \"STORE_ID\"\n        guard let callbackId = try? endpointSession?.registerCallback(\n        for: privmx.endpoint.store.StoreFileUpdatedEvent.self,\n        from: EventChannel.storeFiles(storeID: storeId),\n        { eventData in\n        }\n        ) else {return}\n\n        // when no longer needed\n        endpointSession?.deleteCallback(callbackId)\n        ```"
        ],
        "lastModified": "2025-06-05T19:33:57.851Z",
        "size": 1086
      }
    },
    {
      "pageContent": "## Unregister Callbacks\n\n<Tabs groupId=\"variant\" items={[\"Specific Callbacks\",\"All Callbacks\"]}>\n<Tab>\nUnregister specific callbacks from the connection:\n```swift\nendpointSession?.clearCallbacks(for: .platform )\n```\n</Tab>\n<Tab>\nUnregister all callbacks from the connection:\n```swift\nendpointSession?.clearAllCallbacks()\n```\n</Tab>\n\n</Tabs>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/swift/events.mdx",
        "type": "mdx",
        "chunkIndex": 2,
        "headers": [
          "Unregister Callbacks"
        ],
        "title": "Unregister Callbacks",
        "codeBlocks": [
          "```swift\nendpointSession?.clearCallbacks(for: .platform )\n```",
          "```swift\nendpointSession?.clearAllCallbacks()\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.851Z",
        "size": 340
      }
    },
    {
      "pageContent": "---\ntitle: Files\n---\n\nStores provide encrypted block storage, enabling simple file uploading and downloading. \n\n:::info\n\nBefore working with Stores, follow our [Getting Started Guide](./getting-started). It will show you how to set up your project to work with PrivMX Bridge.\\\n\\\nThe sample code on this page is based on the **[initial assumptions](./getting-started#initial-assumptions)**.\\\n\\\nAll policies in the following examples can be build with [Policy Builders](./policy-builders), according to [Policies overview](../start/concepts/policies). \\\n\\\n`publicMeta` and `privateMeta` fields in Stores support any kind of data formats encoded to byte arrays.\nExamples in this section use JSON format serialization, which is available directly in Swift.\n\n:::",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/swift/files.mdx",
        "type": "mdx",
        "chunkIndex": 0,
        "lastModified": "2025-06-05T19:33:57.852Z",
        "size": 757
      }
    },
    {
      "pageContent": "## Working with Stores\n\nTo access Store methods, get the field `storeApi` from active connection. Connection should be initialized with `[.store]` passed to [`PrivmxEndpoint`](../reference/privmx-endpoint-swift-extra/core/privmx-endpoint).\n\n<Tabs groupId=\"variant\" items={[\"Swift\"]}>\n<Tab>\n```swift\nprivmxSession.storeApi?.... // instance of StoreApi\n```\n</Tab>\n</Tabs>\n\n### Assumptions\n\nIn further examples, the following structures are used:\n```swift\nstruct StorePublicMeta:Codable{\n    let tags: [String]\n}\n```",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/swift/files.mdx",
        "type": "mdx",
        "chunkIndex": 1,
        "headers": [
          "Working with Stores",
          "Assumptions"
        ],
        "title": "Working with Stores",
        "codeBlocks": [
          "```swift\nprivmxSession.storeApi?.... // instance of StoreApi\n```",
          "```swift\nstruct StorePublicMeta:Codable{\n    let tags: [String]\n}\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.852Z",
        "size": 513
      }
    },
    {
      "pageContent": "## Creating Stores\n\n<Tabs groupId=\"variant\" items={[\"Basic\",\"With a Name\",\"With a publicName\"]}>\n<Tab>\nCreating a basic, unnamed Store, which can act as an encrypted data container:\n```swift\nlet contextId = \"CONTEXT_ID\"\n         \nlet users = [privmx.endpoint.core.UserWithPubKey]() //should be prepared by developer\nlet managers = [privmx.endpoint.core.UserWithPubKey]() //should be prepared by developer\nlet publicMeta = Data()\nlet privateMeta = Data()\n\nlet storeId = try? endpointSession?.storeApi?\n    .createStore(in: contextId,\n        for: users,\n        managedBy: managers,\n        withPublicMeta: publicMeta,\n        withPrivateMeta: privateMeta,\n        withPolicies: nil)\n```\n</Tab>\n\n<Tab>\nYou can assign any data to private and public meta fields (e.g. the Store's name), as long as they are serialized to byte array:\n```swift\nlet contextId = \"CONTEXT_ID\"\n        \nlet users = [privmx.endpoint.core.UserWithPubKey]() //should be prepared by developer\nlet managers = [privmx.endpoint.core.UserWithPubKey]() //should be prepared by developer\nlet publicMeta = Data()\nguard let storeNameAsPrivateMeta =  \"New store\".data(using: .utf8) else {return}",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/swift/files.mdx",
        "type": "mdx",
        "chunkIndex": 2,
        "headers": [
          "Creating Stores"
        ],
        "title": "Creating Stores",
        "codeBlocks": [
          "```swift\nlet contextId = \"CONTEXT_ID\"\n         \nlet users = [privmx.endpoint.core.UserWithPubKey]() //should be prepared by developer\nlet managers = [privmx.endpoint.core.UserWithPubKey]() //should be prepared by developer\nlet publicMeta = Data()\nlet privateMeta = Data()\n\nlet storeId = try? endpointSession?.storeApi?\n    .createStore(in: contextId,\n        for: users,\n        managedBy: managers,\n        withPublicMeta: publicMeta,\n        withPrivateMeta: privateMeta,\n        withPolicies: nil)\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.852Z",
        "size": 1156
      }
    },
    {
      "pageContent": "let storeId = try? endpointSession?.storeApi?\n    .createStore(in: contextId,\n                    for: users,\n                    managedBy: managers,\n                    withPublicMeta: publicMeta,\n                    withPrivateMeta: storeNameAsPrivateMeta,\n                    withPolicies: nil)\n```\n</Tab>\n<Tab>\nYou can implement a tag system which allows you to create Stores with arbitrary tags. Putting them inside `publicMeta` gives your own server the ability to access it using [PrivMX Bridge API](https://bridge.privmx.dev/):\n\n```swift\nlet contextId = \"CONTEXT_ID\"\n         \nlet users = [privmx.endpoint.core.UserWithPubKey]() //should be prepared by developer\nlet managers = [privmx.endpoint.core.UserWithPubKey]() //should be prepared by developer\n\nlet storePublicMeta = StorePublicMeta(tags: [\"TAG1\",\"TAG2\",\"TAG3\"])\nguard let storePublicMetaData = try? JSONEncoder().encode(storePublicMeta) else {return}\n\nguard let storeNameAsPrivateMeta =  \"New store\".data(using: .utf8) else {return}",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/swift/files.mdx",
        "type": "mdx",
        "chunkIndex": 3,
        "codeBlocks": [
          "```\n</Tab>\n<Tab>\nYou can implement a tag system which allows you to create Stores with arbitrary tags. Putting them inside `publicMeta` gives your own server the ability to access it using [PrivMX Bridge API](https://bridge.privmx.dev/):\n\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.852Z",
        "size": 1000
      }
    },
    {
      "pageContent": "guard let storeNameAsPrivateMeta =  \"New store\".data(using: .utf8) else {return}\n\nlet storeId = try? endpointSession?.storeApi?\n    .createStore(in: contextId,\n                for: users,\n                managedBy: managers,\n                withPublicMeta: storePublicMetaData,\n                withPrivateMeta: storeNameAsPrivateMeta,\n                withPolicies: nil)\n```\n</Tab>\n</Tabs>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/swift/files.mdx",
        "type": "mdx",
        "chunkIndex": 4,
        "lastModified": "2025-06-05T19:33:57.852Z",
        "size": 388
      }
    },
    {
      "pageContent": "## Getting Stores\n\n<Tabs groupId=\"variant\" items={[\"Most Recent\",\"Oldest\",\"By Store ID\"]}>\n<Tab>\nFetching the most recent Stores in given Context:\n```swift\nvar startIndex:Int64 = 0\nvar pageSize:Int64 = 100\n\nlet contextId = \"CONTEXT_ID\"\n\n    \nguard let pagingList = try? endpointSession?.storeApi?\n    .listStores(\n        from:contextId,\n        basedOn: .init(skip: startIndex, limit: pageSize, sortOrder: .asc)) else {return}\n\nlet stores =\npagingList.readItems.map { $0 }\n```\n</Tab>\n\n<Tab>\nFetching the oldest Stores (by creation date) in given Context:\n```swift\nvar startIndex:Int64 = 0\nvar pageSize:Int64 = 100\n\nlet contextId = \"CONTEXT_ID\"\n\n    \nguard let pagingList = try? endpointSession?.storeApi?\n    .listStores(\n        from:contextId,\n        basedOn: .init(skip: startIndex, limit: pageSize, sortOrder: .desc)) else {return}\n\nlet stores =\npagingList.readItems.map { $0 }\n```\n</Tab>\n<Tab>\nYou can get info about a Store using its `storeId`:\n```swift\nvar storeID = \"STORE_ID\"\n            \n\nguard let file = try? endpointSession?.storeApi?\n    .getStore(storeID) else {return}\n```\n</Tab>\n</Tabs>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/swift/files.mdx",
        "type": "mdx",
        "chunkIndex": 5,
        "headers": [
          "Getting Stores"
        ],
        "title": "Getting Stores",
        "codeBlocks": [
          "```swift\nvar startIndex:Int64 = 0\nvar pageSize:Int64 = 100\n\nlet contextId = \"CONTEXT_ID\"\n\n    \nguard let pagingList = try? endpointSession?.storeApi?\n    .listStores(\n        from:contextId,\n        basedOn: .init(skip: startIndex, limit: pageSize, sortOrder: .asc)) else {return}\n\nlet stores =\npagingList.readItems.map { $0 }\n```",
          "```swift\nvar startIndex:Int64 = 0\nvar pageSize:Int64 = 100\n\nlet contextId = \"CONTEXT_ID\"\n\n    \nguard let pagingList = try? endpointSession?.storeApi?\n    .listStores(\n        from:contextId,\n        basedOn: .init(skip: startIndex, limit: pageSize, sortOrder: .desc)) else {return}\n\nlet stores =\npagingList.readItems.map { $0 }\n```",
          "```swift\nvar storeID = \"STORE_ID\"\n            \n\nguard let file = try? endpointSession?.storeApi?\n    .getStore(storeID) else {return}\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.852Z",
        "size": 1105
      }
    },
    {
      "pageContent": "## Managing Stores\n\n<Tabs groupId=\"variant\" items={[\"Renaming Store\",\"Renaming User\",\"Deleting Store\"]}>\n<Tab>\nTo update a Store you must always provide its current version, as well as:\n- list of users\n- list of managers\n- new private and public meta (even if it didn't change)\n- Store's current version\n- `true` if update action should be forced\n\n```swift\n guard let store = try? endpointSession?.storeApi?\n    .getStore(storeId) else {return}\n\n//users list to be extracted from store\nlet users = store.users\n    .map{\n    //Your application must provide a way,\n    //to get user's public key from their userId.\n    privmx.endpoint.core.UserWithPubKey(userId: $0, pubKey: \"PUB\")\n}\n//managers list to be extracted from store\nlet managers = store.managers.map{\n    //Your application must provide a way,\n    //to get user's public key from their userId.\n    privmx.endpoint.core.UserWithPubKey(userId: $0, pubKey: \"PUB\")\n}\n\nguard let newPrivateMeta = \"New store name\".data(using: .utf8) else {return}",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/swift/files.mdx",
        "type": "mdx",
        "chunkIndex": 6,
        "headers": [
          "Managing Stores"
        ],
        "title": "Managing Stores",
        "lastModified": "2025-06-05T19:33:57.852Z",
        "size": 999
      }
    },
    {
      "pageContent": "guard let newPrivateMeta = \"New store name\".data(using: .utf8) else {return}\n\n_ = try? endpointSession?.storeApi?.updateStore(\n    storeId,\n    atVersion: store.version,\n    replacingUsers: users,\n    replacingManagers: managers,\n    replacingPublicMeta: store.publicMeta.getData() ?? Data(),\n    replacingPrivateMeta: newPrivateMeta,\n    force:false,\n    forceGenerateNewKey: false,\n    replacingPolicies:nil)\n\n```\n</Tab>\n\n<Tab>\nTo remove a user from a Store you must provide:\n- list of all the users, without the user you want to remove\n- list of managers\n- new private and public meta (even if it didn't change)\n- Store's current version\n- `true` if update action should be forced\n\n```swift\n var storeId = \"STORE_ID\"\n\nguard let store = try? endpointSession?.storeApi?\n    .getStore(storeId) else {return}",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/swift/files.mdx",
        "type": "mdx",
        "chunkIndex": 7,
        "codeBlocks": [
          "```\n</Tab>\n\n<Tab>\nTo remove a user from a Store you must provide:\n- list of all the users, without the user you want to remove\n- list of managers\n- new private and public meta (even if it didn't change)\n- Store's current version\n- `true` if update action should be forced\n\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.852Z",
        "size": 807
      }
    },
    {
      "pageContent": "```swift\n var storeId = \"STORE_ID\"\n\nguard let store = try? endpointSession?.storeApi?\n    .getStore(storeId) else {return}\n\n//users list to be extracted from store\nlet users = store.users\n    .filter{\n        $0 != \"username-to-remove\"\n    }\n    .map{\n    //Your application must provide a way,\n    //to get user's public key from their userId.\n    privmx.endpoint.core.UserWithPubKey(userId: $0, pubKey: \"PUB\")\n}\n//managers list to be extracted from store\nlet managers = store.managers.map{\n    //Your application must provide a way,\n    //to get user's public key from their userId.\n    privmx.endpoint.core.UserWithPubKey(userId: $0, pubKey: \"PUB\")\n}\n\nguard let newPrivateMeta = \"New store name\".data(using: .utf8) else {return}\n\n_ = try? endpointSession?.storeApi?.updateStore(\n    storeId,\n    atVersion: store.version,\n    replacingUsers: users,\n    replacingManagers: managers,\n    replacingPublicMeta: store.publicMeta.getData() ?? Data(),\n    replacingPrivateMeta: store.privateMeta.getData() ?? Data(),\n    force:false,\n    forceGenerateNewKey: false,\n    replacingPolicies: nil)\n\n```\n</Tab>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/swift/files.mdx",
        "type": "mdx",
        "chunkIndex": 8,
        "codeBlocks": [
          "```swift\n var storeId = \"STORE_ID\"\n\nguard let store = try? endpointSession?.storeApi?\n    .getStore(storeId) else {return}\n\n//users list to be extracted from store\nlet users = store.users\n    .filter{\n        $0 != \"username-to-remove\"\n    }\n    .map{\n    //Your application must provide a way,\n    //to get user's public key from their userId.\n    privmx.endpoint.core.UserWithPubKey(userId: $0, pubKey: \"PUB\")\n}\n//managers list to be extracted from store\nlet managers = store.managers.map{\n    //Your application must provide a way,\n    //to get user's public key from their userId.\n    privmx.endpoint.core.UserWithPubKey(userId: $0, pubKey: \"PUB\")\n}\n\nguard let newPrivateMeta = \"New store name\".data(using: .utf8) else {return}\n\n_ = try? endpointSession?.storeApi?.updateStore(\n    storeId,\n    atVersion: store.version,\n    replacingUsers: users,\n    replacingManagers: managers,\n    replacingPublicMeta: store.publicMeta.getData() ?? Data(),\n    replacingPrivateMeta: store.privateMeta.getData() ?? Data(),\n    force:false,\n    forceGenerateNewKey: false,\n    replacingPolicies: nil)\n\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.852Z",
        "size": 1101
      }
    },
    {
      "pageContent": "```\n</Tab>\n\n<Tab>\nThe snippet below deletes Store and all its data. This action is irreversible.\n```swift\nvar storeId = \"STORE_ID\"\n         \ntry? endpointSession?.storeApi?.deleteStore(storeId)\n```\n</Tab>\n\n</Tabs>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/swift/files.mdx",
        "type": "mdx",
        "chunkIndex": 9,
        "codeBlocks": [
          "```\n</Tab>\n\n<Tab>\nThe snippet below deletes Store and all its data. This action is irreversible.\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.852Z",
        "size": 213
      }
    },
    {
      "pageContent": "---\ntitle: Getting Started\n---\n\n## Initial Requirements\n\nTo start developing using PrivMX Endpoint Swift follow our [quick start guide](../start/quick-start) first\n\nTo connect it to your environment, you need:\n  - `Bridge URL` - URL address of the instance of your PrivMX Bridge\n  - `Solution ID` - ID of the Solution provided by PrivMX Bridge during its initialization process\n  - `User Private Key` - the private key from the user's public-private key pair\n\nYou also need to use your own application server to manage users (and their keys) and Contexts.",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/swift/getting-started.mdx",
        "type": "mdx",
        "chunkIndex": 0,
        "headers": [
          "Initial Requirements"
        ],
        "title": "Initial Requirements",
        "lastModified": "2025-06-05T19:33:57.853Z",
        "size": 555
      }
    },
    {
      "pageContent": "## Installation\n\nOur Swift packages contain all the necessary assets and helpers to get started with PrivMX Endpoint. Select which level is the best for you. \nGo to [Swift overview](../swift) to see the descriptions of each package.\n\n### Swift Dependencies\nSwift Dependencies are managed by Swift Package Manager, and published on Simplito's [Github](https://github.com/simplito).\n\n1. Add `privmx-endpoint-swift-extra` package to your project using Xcode's built-in package management:\n\n```\nhttps://github.com/simplito/privmx-endpoint-swift-extra\n```\n\nIt should be present in Package Dependencies as well as in target's \"Link Binary With Libraries\" section.\n\n2. Everywhere you want to use PrivMX Package, you need to import:\n\n```swift\nimport PrivMXEndpointSwift\nimport PrivMXEndpointSwiftExtra\nimport PrivMXEndpointSwiftNative\n```\n\n### Shared Libraries\nOur `privmx-endpoint-swift-extra` package depends on `privmx-endpoint-swift` package, \nwhich depends on a set of native libraries, which are downloaded automatically by Xcode.\nThey are all compiled for arm and Intel architectures for using with iOS, macOS and simulator environments.",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/swift/getting-started.mdx",
        "type": "mdx",
        "chunkIndex": 1,
        "headers": [
          "Installation",
          "Swift Dependencies",
          "Shared Libraries"
        ],
        "title": "Installation",
        "codeBlocks": [
          "```\nhttps://github.com/simplito/privmx-endpoint-swift-extra\n```",
          "```swift\nimport PrivMXEndpointSwift\nimport PrivMXEndpointSwiftExtra\nimport PrivMXEndpointSwiftNative\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.853Z",
        "size": 1136
      }
    },
    {
      "pageContent": "## Initial Assumptions\n\nThe initial assumptions for all the code examples below are as follows:\n\n```swift\n/*\n    All the values below like BRIDGE_URL, SOLUTION_ID, CONTEXT_ID\n    should be replaced by the ones corresponding to your Bridge Server instance.\n    \n    The private keys here are for demonstration purposes only.\n    Normally, they should be kept separately by each user and stored in a safe place,\n    or generated from a password (see the derivePrivateKey2() method in the Crypto API)\n    */\n\nlet BRIDGE_URL = \"YOUR_BRIDGE_URL\";\nlet SOLUTION_ID = \"YOUR_SOLUTION_ID\";\nlet CONTEXT_ID = \"YOUR_CONTEXT_ID\";\n\nlet USER1_ID = \"USER_ID_1\";\nlet USER1_PUBLIC_KEY = \"PUBLIC_KEY_1\";\nlet USER1_PRIV = \"PRIVATE_KEY_1\";\n\nlet USER2_ID = \"USER_ID_2\";\nlet USER2_PUBLIC_KEY = \"PUBLIC_KEY_2\";\n\nlet USER3_ID = \"USER_ID_3\";\nlet USER3_PUBLIC_KEY = \"PUBLIC_KEY_3\";\n```",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/swift/getting-started.mdx",
        "type": "mdx",
        "chunkIndex": 2,
        "headers": [
          "Initial Assumptions"
        ],
        "title": "Initial Assumptions",
        "codeBlocks": [
          "```swift\n/*\n    All the values below like BRIDGE_URL, SOLUTION_ID, CONTEXT_ID\n    should be replaced by the ones corresponding to your Bridge Server instance.\n    \n    The private keys here are for demonstration purposes only.\n    Normally, they should be kept separately by each user and stored in a safe place,\n    or generated from a password (see the derivePrivateKey2() method in the Crypto API)\n    */\n\nlet BRIDGE_URL = \"YOUR_BRIDGE_URL\";\nlet SOLUTION_ID = \"YOUR_SOLUTION_ID\";\nlet CONTEXT_ID = \"YOUR_CONTEXT_ID\";\n\nlet USER1_ID = \"USER_ID_1\";\nlet USER1_PUBLIC_KEY = \"PUBLIC_KEY_1\";\nlet USER1_PRIV = \"PRIVATE_KEY_1\";\n\nlet USER2_ID = \"USER_ID_2\";\nlet USER2_PUBLIC_KEY = \"PUBLIC_KEY_2\";\n\nlet USER3_ID = \"USER_ID_3\";\nlet USER3_PUBLIC_KEY = \"PUBLIC_KEY_3\";\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.853Z",
        "size": 857
      }
    },
    {
      "pageContent": "## Connecting to PrivMX Bridge\n\nTo use any of the library's elements, you must first connect to PrivMX Bridge.\nUse the API keys mentioned [earlier](#initial-requirements). You can use `PrivMXEndpointContainer` and its helper functions or manually instantiate `PrivMXEndpoint`.\nThis is the most recommended approach.\n\n<Tabs groupId=\"variant\" items={[\"Swift Extra\",\"Swift Basic\"]}>\n<Tab>\n```swift\n // Initialize the endpoint container\nvar endpointContainer = PrivMXEndpointContainer()\n\n// Set the path to the certificate matching Your installation\nguard let pathToCerts = Bundle.main.path(forResource: \"cacert\", ofType: \"pem\") else { return }\ntry endpointContainer.setCertsPath(to: pathToCerts)",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/swift/getting-started.mdx",
        "type": "mdx",
        "chunkIndex": 3,
        "headers": [
          "Connecting to PrivMX Bridge"
        ],
        "title": "Connecting to PrivMX Bridge",
        "lastModified": "2025-06-05T19:33:57.853Z",
        "size": 692
      }
    },
    {
      "pageContent": "// Establish a new endpoint session\nvar endpointSession = try await endpointContainer.newEndpoint(\n    enabling: [.thread,.store,.inbox],\n    connectingAs: USER1_PRIVATE_KEY,\n    to: SOLUTION_ID,\n    on: BRIDGE_URL\n)\t\t\n```\n</Tab>\n<Tab>\n```swift\n// Set the path to the certificate matching Your installation\nguard let pathToCerts = Bundle.main.path(forResource: \"cacert\", ofType: \"pem\") else {return}\ntry? Connection.setCertsPath(pathToCerts)\n// Establish a new endpoint session\nvar endpointSession = try? PrivMXEndpoint(\n    modules: [.thread,.store,.inbox],\n    userPrivKey: USER1_PRIVATE_KEY,\n    solutionId: SOLUTION_ID,\n    bridgeUrl: BRIDGE_URL)",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/swift/getting-started.mdx",
        "type": "mdx",
        "chunkIndex": 4,
        "codeBlocks": [
          "```\n</Tab>\n<Tab>\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.853Z",
        "size": 650
      }
    },
    {
      "pageContent": "```\n\nAlternatively: \n```swift\n// Set the path to the certificate matching Your installation\nguard let pathToCerts = Bundle.main.path(forResource: \"cacert\", ofType: \"pem\") else {return}\ntry? Connection.setCertsPath(pathToCerts)\n// Establish connection\nguard var connection = try? Connection.connect(\n    as: USER1_PRIVATE_KEY,\n    to: BRIDGE_URL,\n    on: CONTEXT_ID) as? Connection\nelse {return}\n// Init required API's\nguard var storeApi = try? StoreApi.create(connection: &connection) else {return}\nguard var threadApi = try? ThreadApi.create(connection: &connection) else {return}\nguard let inboxApi = try? InboxApi.create(\n    connection: &connection,\n    threadApi: &threadApi,\n    storeApi: &storeApi) else {return}\n                                    \n```\n</Tab>\n</Tabs>\n\nCertificates should be set up accordingly to the Local Bridge Installation. More details are available [here](../start/certificates).",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/swift/getting-started.mdx",
        "type": "mdx",
        "chunkIndex": 5,
        "codeBlocks": [
          "```\n\nAlternatively: \n```"
        ],
        "lastModified": "2025-06-05T19:33:57.853Z",
        "size": 910
      }
    },
    {
      "pageContent": "Certificates should be set up accordingly to the Local Bridge Installation. More details are available [here](../start/certificates).\n\nThe active connection is kept by [`endpointContainer`](../reference/privmx-endpoint-swift-extra/core/privmx-endpoint-container) and can be accessed with `getPrivmxEndpoint()` function.\n<Tabs groupId=\"variant\" items={[\"Swift\"]}>\n<Tab>\n```swift\nlet endpointSessionId:Int64 = 0 //need to be initialized during session setup\nlet endpointSession = endpointContainer?.getEndpoint(endpointSessionId)\n//by passing value indexed by connectionID\n```\n</Tab>\n</Tabs>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/swift/getting-started.mdx",
        "type": "mdx",
        "chunkIndex": 6,
        "codeBlocks": [
          "```swift\nlet endpointSessionId:Int64 = 0 //need to be initialized during session setup\nlet endpointSession = endpointContainer?.getEndpoint(endpointSessionId)\n//by passing value indexed by connectionID\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.853Z",
        "size": 589
      }
    },
    {
      "pageContent": "## Disconnecting from PrivMX Bridge\n\nWhile using `PrivMXEndpointContainer`, you can run disconnect on `endpointContainer` object. It ends all underlying connections.\n\n<Tabs groupId=\"variant\" items={[\"Swift\"]}>\n<Tab>\n```swift\n try? endpointContainer?.disconnectAll()\n```\n</Tab>\n</Tabs>\n\n## Compilation\n\nCompilation requires C++ interoperability turned on in the project settings, which can be found here:\n\n```\nProject > Target > Build Settings > C++ and Objective-C interoperability = C++ / Objective-C++\n```\n\n## Next Steps\n\nWith everything ready to go, now it's time to start using all of the Platform's capabilities. \n\nLearn how to use:\n\n-   [**Threads**](../start/threads/overview) - for exchanging encrypted messages;\n-   [**Stores**](../start/stores/overview) - for saving and sharing encrypted file;\n-   [**Inboxes**](../start/inboxes/overview) - for one way communication with external users.",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/swift/getting-started.mdx",
        "type": "mdx",
        "chunkIndex": 7,
        "headers": [
          "Disconnecting from PrivMX Bridge",
          "Compilation",
          "Next Steps"
        ],
        "title": "Disconnecting from PrivMX Bridge",
        "codeBlocks": [
          "```swift\n try? endpointContainer?.disconnectAll()\n```",
          "```\nProject > Target > Build Settings > C++ and Objective-C interoperability = C++ / Objective-C++\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.853Z",
        "size": 898
      }
    },
    {
      "pageContent": "---\ntitle: Handling Events\n---\n\nHow to subscribe to events, assuming you have already started listening.\n\n## Connection\n\n```swift\n_ = try? endpointSession?.registerCallback(\n    for: privmx.endpoint.core.LibConnectedEvent.self,\n    from: .platform, identified: \"SOME_UNIQUE_IDENTIFIER\",\n    { eventData in\n        // some actions when lib connect\n    })\n    \n_ = try? endpointSession?.registerCallback(\n    for: privmx.endpoint.core.LibDisconnectedEvent.self,\n    from: .platform, identified: \"SOME_UNIQUE_IDENTIFIER\",\n    { eventData in\n        // some actions when lib disconnects\n    })\n```",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/swift/handling-events.mdx",
        "type": "mdx",
        "chunkIndex": 0,
        "headers": [
          "Connection"
        ],
        "title": "Connection",
        "codeBlocks": [
          "```swift\n_ = try? endpointSession?.registerCallback(\n    for: privmx.endpoint.core.LibConnectedEvent.self,\n    from: .platform, identified: \"SOME_UNIQUE_IDENTIFIER\",\n    { eventData in\n        // some actions when lib connect\n    })\n    \n_ = try? endpointSession?.registerCallback(\n    for: privmx.endpoint.core.LibDisconnectedEvent.self,\n    from: .platform, identified: \"SOME_UNIQUE_IDENTIFIER\",\n    { eventData in\n        // some actions when lib disconnects\n    })\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.853Z",
        "size": 593
      }
    },
    {
      "pageContent": "## Threads\n\n<Tabs items={[\"Threads\",\"Messages\"]}>\n<Tab>\n```swift\n_ = try? endpointSession?.registerCallback(\n    for: privmx.endpoint.thread.ThreadCreatedEvent.self,\n    from: .thread, identified: \"SOME_UNIQUE_IDENTIFIER\",\n    { eventData in\n        // some actions when new thread created\n    })\n    \n_ = try? endpointSession?.registerCallback(\n    for: privmx.endpoint.thread.ThreadUpdatedEvent.self,\n    from: .thread, identified: \"SOME_UNIQUE_IDENTIFIER\",\n    { eventData in\n        // some actions when thread updated\n    })\n\n_ = try? endpointSession?.registerCallback(\n    for: privmx.endpoint.thread.ThreadStatsChangedEvent.self,\n    from: .thread, identified: \"SOME_UNIQUE_IDENTIFIER\",\n    { eventData in\n        // some actions when  thread stats changes\n    })\n    \n_ = try? endpointSession?.registerCallback(\n    for: privmx.endpoint.thread.ThreadDeletedEvent.self,\n    from: .thread, identified: \"SOME_UNIQUE_IDENTIFIER\",\n    { eventData in\n        // some actions when thread deleted\n    })\n```\n</Tab>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/swift/handling-events.mdx",
        "type": "mdx",
        "chunkIndex": 1,
        "headers": [
          "Threads"
        ],
        "title": "Threads",
        "codeBlocks": [
          "```swift\n_ = try? endpointSession?.registerCallback(\n    for: privmx.endpoint.thread.ThreadCreatedEvent.self,\n    from: .thread, identified: \"SOME_UNIQUE_IDENTIFIER\",\n    { eventData in\n        // some actions when new thread created\n    })\n    \n_ = try? endpointSession?.registerCallback(\n    for: privmx.endpoint.thread.ThreadUpdatedEvent.self,\n    from: .thread, identified: \"SOME_UNIQUE_IDENTIFIER\",\n    { eventData in\n        // some actions when thread updated\n    })\n\n_ = try? endpointSession?.registerCallback(\n    for: privmx.endpoint.thread.ThreadStatsChangedEvent.self,\n    from: .thread, identified: \"SOME_UNIQUE_IDENTIFIER\",\n    { eventData in\n        // some actions when  thread stats changes\n    })\n    \n_ = try? endpointSession?.registerCallback(\n    for: privmx.endpoint.thread.ThreadDeletedEvent.self,\n    from: .thread, identified: \"SOME_UNIQUE_IDENTIFIER\",\n    { eventData in\n        // some actions when thread deleted\n    })\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.853Z",
        "size": 1014
      }
    },
    {
      "pageContent": "<Tab>\n```swift\nvar threadId = \"THREAD_ID\"\n\t\t\t\t\n_ = try? endpointSession?.registerCallback(\n    for: privmx.endpoint.thread.ThreadNewMessageEvent.self,\n    from: .threadMessages(threadID: threadId), identified: \"SOME_UNIQUE_IDENTIFIER\",\n    { eventData in\n        // some actions on new message\n    })\n    \n_ = try? endpointSession?.registerCallback(\n    for: privmx.endpoint.thread.ThreadMessageDeletedEvent.self,\n    from: .threadMessages(threadID: threadId), identified: \"SOME_UNIQUE_IDENTIFIER\",\n    { eventData in\n        // some actions when message deleted\n    })\n\n_ = try? endpointSession?.registerCallback(\n    for: privmx.endpoint.thread.ThreadMessageDeletedEvent.self,\n    from: .threadMessages(threadID: threadId), identified: \"SOME_UNIQUE_IDENTIFIER\",\n    { eventData in\n        // some actions when message updated\n    })\n```\n</Tab>\n\n</Tabs>\n\n[Read more](../start/threads/listening-for-changes) about Thread events.",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/swift/handling-events.mdx",
        "type": "mdx",
        "chunkIndex": 2,
        "codeBlocks": [
          "```swift\nvar threadId = \"THREAD_ID\"\n\t\t\t\t\n_ = try? endpointSession?.registerCallback(\n    for: privmx.endpoint.thread.ThreadNewMessageEvent.self,\n    from: .threadMessages(threadID: threadId), identified: \"SOME_UNIQUE_IDENTIFIER\",\n    { eventData in\n        // some actions on new message\n    })\n    \n_ = try? endpointSession?.registerCallback(\n    for: privmx.endpoint.thread.ThreadMessageDeletedEvent.self,\n    from: .threadMessages(threadID: threadId), identified: \"SOME_UNIQUE_IDENTIFIER\",\n    { eventData in\n        // some actions when message deleted\n    })\n\n_ = try? endpointSession?.registerCallback(\n    for: privmx.endpoint.thread.ThreadMessageDeletedEvent.self,\n    from: .threadMessages(threadID: threadId), identified: \"SOME_UNIQUE_IDENTIFIER\",\n    { eventData in\n        // some actions when message updated\n    })\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.853Z",
        "size": 928
      }
    },
    {
      "pageContent": "## Stores\n\n<Tabs items={[\"Stores\",\"Files\"]}>\n\n<Tab>\n```swift\n_ = try? endpointSession?.registerCallback(\n    for: privmx.endpoint.store.StoreCreatedEvent.self,\n    from: .store, identified: \"SOME_UNIQUE_IDENTIFIER\",\n    { eventData in\n        // some actions when new store created\n    })\n    \n_ = try? endpointSession?.registerCallback(\n    for: privmx.endpoint.store.StoreUpdatedEvent.self,\n    from: .store, identified: \"SOME_UNIQUE_IDENTIFIER\",\n    { eventData in\n        // some actions when store updated\n    })\n\n_ = try? endpointSession?.registerCallback(\n    for: privmx.endpoint.store.StoreStatsChangedEvent.self,\n    from: .store, identified: \"SOME_UNIQUE_IDENTIFIER\",\n    { eventData in\n        // some actions when store stats changes\n    })\n    \n_ = try? endpointSession?.registerCallback(\n    for: privmx.endpoint.store.StoreDeletedEvent.self,\n    from: .store, identified: \"SOME_UNIQUE_IDENTIFIER\",\n    { eventData in\n        // some actions when store deleted\n    })\n```\n</Tab>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/swift/handling-events.mdx",
        "type": "mdx",
        "chunkIndex": 3,
        "headers": [
          "Stores"
        ],
        "title": "Stores",
        "codeBlocks": [
          "```swift\n_ = try? endpointSession?.registerCallback(\n    for: privmx.endpoint.store.StoreCreatedEvent.self,\n    from: .store, identified: \"SOME_UNIQUE_IDENTIFIER\",\n    { eventData in\n        // some actions when new store created\n    })\n    \n_ = try? endpointSession?.registerCallback(\n    for: privmx.endpoint.store.StoreUpdatedEvent.self,\n    from: .store, identified: \"SOME_UNIQUE_IDENTIFIER\",\n    { eventData in\n        // some actions when store updated\n    })\n\n_ = try? endpointSession?.registerCallback(\n    for: privmx.endpoint.store.StoreStatsChangedEvent.self,\n    from: .store, identified: \"SOME_UNIQUE_IDENTIFIER\",\n    { eventData in\n        // some actions when store stats changes\n    })\n    \n_ = try? endpointSession?.registerCallback(\n    for: privmx.endpoint.store.StoreDeletedEvent.self,\n    from: .store, identified: \"SOME_UNIQUE_IDENTIFIER\",\n    { eventData in\n        // some actions when store deleted\n    })\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.853Z",
        "size": 993
      }
    },
    {
      "pageContent": "<Tab>\n```swift\nvar storeId = \"STORE_ID\"\n\t\t\t\t\n_ = try? endpointSession?.registerCallback(\n    for: privmx.endpoint.store.StoreFileCreatedEvent.self,\n    from: .storeFiles(storeID: storeId), identified: \"SOME_UNIQUE_IDENTIFIER\",\n    { eventData in\n        // some actions on new file\n    })\n    \n_ = try? endpointSession?.registerCallback(\n    for: privmx.endpoint.store.StoreFileUpdatedEvent.self,\n    from: .storeFiles(storeID: storeId), identified: \"SOME_UNIQUE_IDENTIFIER\",\n    { eventData in\n        // some actions when file updated\n    })\n\n_ = try? endpointSession?.registerCallback(\n    for: privmx.endpoint.store.StoreFileDeletedEvent.self,\n    from: .storeFiles(storeID: storeId), identified: \"SOME_UNIQUE_IDENTIFIER\",\n    { eventData in\n        // some actions when message updated\n    })\n```\n</Tab>\n\n</Tabs>\n\n[Read more](../start/stores/instant-updating) about Store events.",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/swift/handling-events.mdx",
        "type": "mdx",
        "chunkIndex": 4,
        "codeBlocks": [
          "```swift\nvar storeId = \"STORE_ID\"\n\t\t\t\t\n_ = try? endpointSession?.registerCallback(\n    for: privmx.endpoint.store.StoreFileCreatedEvent.self,\n    from: .storeFiles(storeID: storeId), identified: \"SOME_UNIQUE_IDENTIFIER\",\n    { eventData in\n        // some actions on new file\n    })\n    \n_ = try? endpointSession?.registerCallback(\n    for: privmx.endpoint.store.StoreFileUpdatedEvent.self,\n    from: .storeFiles(storeID: storeId), identified: \"SOME_UNIQUE_IDENTIFIER\",\n    { eventData in\n        // some actions when file updated\n    })\n\n_ = try? endpointSession?.registerCallback(\n    for: privmx.endpoint.store.StoreFileDeletedEvent.self,\n    from: .storeFiles(storeID: storeId), identified: \"SOME_UNIQUE_IDENTIFIER\",\n    { eventData in\n        // some actions when message updated\n    })\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.853Z",
        "size": 884
      }
    },
    {
      "pageContent": "## Inboxes\n\n<Tabs items={[\"Inboxes\",\"Inbox Entries\"]}>\n\n<Tab>\n```swift\n_ = try? endpointSession?.registerCallback(\n    for: privmx.endpoint.inbox.InboxCreatedEvent.self,\n    from: .inbox, identified: \"SOME_UNIQUE_IDENTIFIER\",\n    { eventData in\n        // some actions when new inbox created\n    })\n    \n_ = try? endpointSession?.registerCallback(\n    for: privmx.endpoint.inbox.InboxUpdatedEvent.self,\n    from: .inbox, identified: \"SOME_UNIQUE_IDENTIFIER\",\n    { eventData in\n        // some actions when inbox updated\n    })\n\n_ = try? endpointSession?.registerCallback(\n    for: privmx.endpoint.inbox.InboxUpdatedEvent.self,\n    from: .inbox, identified: \"SOME_UNIQUE_IDENTIFIER\",\n    { eventData in\n        // some actions when inbox updated\n    })\n```\n</Tab>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/swift/handling-events.mdx",
        "type": "mdx",
        "chunkIndex": 5,
        "headers": [
          "Inboxes"
        ],
        "title": "Inboxes",
        "codeBlocks": [
          "```swift\n_ = try? endpointSession?.registerCallback(\n    for: privmx.endpoint.inbox.InboxCreatedEvent.self,\n    from: .inbox, identified: \"SOME_UNIQUE_IDENTIFIER\",\n    { eventData in\n        // some actions when new inbox created\n    })\n    \n_ = try? endpointSession?.registerCallback(\n    for: privmx.endpoint.inbox.InboxUpdatedEvent.self,\n    from: .inbox, identified: \"SOME_UNIQUE_IDENTIFIER\",\n    { eventData in\n        // some actions when inbox updated\n    })\n\n_ = try? endpointSession?.registerCallback(\n    for: privmx.endpoint.inbox.InboxUpdatedEvent.self,\n    from: .inbox, identified: \"SOME_UNIQUE_IDENTIFIER\",\n    { eventData in\n        // some actions when inbox updated\n    })\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.853Z",
        "size": 763
      }
    },
    {
      "pageContent": "<Tab>\n```swift\nvar inboxId = \"INBOX_ID\"\n\t\t\t\t\n_ = try? endpointSession?.registerCallback(\n    for: privmx.endpoint.inbox.InboxEntryCreatedEvent.self,\n    from: .inboxEntries(inboxId: inboxId), identified: \"SOME_UNIQUE_IDENTIFIER\",\n    { eventData in\n        // some actions on new inbox entry\n    })\n    \n_ = try? endpointSession?.registerCallback(\n    for: privmx.endpoint.inbox.InboxEntryDeletedEvent.self,\n    from: .inboxEntries(inboxId: inboxId), identified: \"SOME_UNIQUE_IDENTIFIER\",\n    { eventData in\n        // some actions when inbox entry deleted\n    })\n```\n</Tab>\n</Tabs>\n\n[Read more](../start/inboxes/inbox-updates) about Inbox events.",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/swift/handling-events.mdx",
        "type": "mdx",
        "chunkIndex": 6,
        "codeBlocks": [
          "```swift\nvar inboxId = \"INBOX_ID\"\n\t\t\t\t\n_ = try? endpointSession?.registerCallback(\n    for: privmx.endpoint.inbox.InboxEntryCreatedEvent.self,\n    from: .inboxEntries(inboxId: inboxId), identified: \"SOME_UNIQUE_IDENTIFIER\",\n    { eventData in\n        // some actions on new inbox entry\n    })\n    \n_ = try? endpointSession?.registerCallback(\n    for: privmx.endpoint.inbox.InboxEntryDeletedEvent.self,\n    from: .inboxEntries(inboxId: inboxId), identified: \"SOME_UNIQUE_IDENTIFIER\",\n    { eventData in\n        // some actions when inbox entry deleted\n    })\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.853Z",
        "size": 647
      }
    },
    {
      "pageContent": "---\ntitle: Overview\n---\n\nInboxes are a secure way for assigned members to receive encrypted inbound traffic from public sources.\nInbox is a container, which is designed to be accessed only by the assigned users. It is managed similarly as Threads and Stores.\nHowever, writing to an Inbox is possible with public API, which doesn't require writer registration and access specification.\n\n:::info\n\nBefore working with Inboxes, follow our [Getting Started Guide](./getting-started). It will show you how to set up your project to work with PrivMX Bridge.\\\n\\\nThe sample code on this page is based on the **[initial assumptions](./getting-started#initial-assumptions)**.\\\n\\\nAll policies in the following examples can be build with [Policy Builders](./policy-builders), according to [Policies overview](../start/concepts/policies). \\\n\\\n[`publicMeta` and `privateMeta`](../start/public-private-meta) fields in Inboxes support any kind of data formats encoded to byte arrays.\nExamples in this section use JSON format serialization, which is available directly in Swift.\n\n:::",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/swift/inboxes.mdx",
        "type": "mdx",
        "chunkIndex": 0,
        "lastModified": "2025-06-05T19:33:57.853Z",
        "size": 1065
      }
    },
    {
      "pageContent": "## Working with Inboxes\n\nTo access Inbox methods, get the field `inboxApi` from active connection. Connection should be initialized with `[.inbox]` and passed to [`PrivmxEndpoint`](../reference/privmx-endpoint-swift-extra/core/privmx-endpoint).\n\n<Tabs groupId=\"variant\" items={[\"Swift\"]}>\n<Tab>\n```swift\nguard let endpointSession =\n        try? await endpointContainer?.newEndpoint(\n            enabling: [.inbox],\n            connectingAs: USER1_PRIVATE_KEY,\n            to: SOLUTION_ID,\n            on: BRIDGE_URL ) else {return}\nendpointSession.inboxApi // instance of InboxApi\n```\n</Tab>\n\n</Tabs>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/swift/inboxes.mdx",
        "type": "mdx",
        "chunkIndex": 1,
        "headers": [
          "Working with Inboxes"
        ],
        "title": "Working with Inboxes",
        "codeBlocks": [
          "```swift\nguard let endpointSession =\n        try? await endpointContainer?.newEndpoint(\n            enabling: [.inbox],\n            connectingAs: USER1_PRIVATE_KEY,\n            to: SOLUTION_ID,\n            on: BRIDGE_URL ) else {return}\nendpointSession.inboxApi // instance of InboxApi\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.853Z",
        "size": 600
      }
    },
    {
      "pageContent": "## Public session\n\nPublic submissions require using `newPublicEndpoint` function, provided by the `EndpointContainer` class, to establish a public connection to the Platform.\nAfter connecting, create an `InboxApi` instance, which allows to operate on Inboxes.\n\n\n```swift\nguard let publicEndpointSession =\n        try? await endpointContainer?.newPublicEndpoint(\n            enabling: [.inbox],\n            to: SOLUTION_ID,\n            on: BRIDGE_URL ) else {return}\npublicEndpointSession.inboxApi // instance of Public InboxApi\n```\n\nAlternatively You can init `publicInboxApi` by:\n\n```swift\nguard var publicConnection =\n        try? Connection.connectPublic(\n            to: SOLUTION_ID,\n            on: BRIDGE_URL) as? Connection\n        \nelse {return}\n\nguard var publicStoreApi =\n        try? StoreApi.create(\n            connection: &publicConnection) else {return}\nguard var publicThreadApi =\n        try? ThreadApi.create(\n            connection: &publicConnection) else {return}\nguard let publicInboxApi =\n        try? InboxApi.create(\n            connection: &publicConnection,\n            threadApi: &publicThreadApi,\n            storeApi: &publicStoreApi) else {return}\n```",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/swift/inboxes.mdx",
        "type": "mdx",
        "chunkIndex": 2,
        "headers": [
          "Public session"
        ],
        "title": "Public session",
        "codeBlocks": [
          "```swift\nguard let publicEndpointSession =\n        try? await endpointContainer?.newPublicEndpoint(\n            enabling: [.inbox],\n            to: SOLUTION_ID,\n            on: BRIDGE_URL ) else {return}\npublicEndpointSession.inboxApi // instance of Public InboxApi\n```",
          "```swift\nguard var publicConnection =\n        try? Connection.connectPublic(\n            to: SOLUTION_ID,\n            on: BRIDGE_URL) as? Connection\n        \nelse {return}\n\nguard var publicStoreApi =\n        try? StoreApi.create(\n            connection: &publicConnection) else {return}\nguard var publicThreadApi =\n        try? ThreadApi.create(\n            connection: &publicConnection) else {return}\nguard let publicInboxApi =\n        try? InboxApi.create(\n            connection: &publicConnection,\n            threadApi: &publicThreadApi,\n            storeApi: &publicStoreApi) else {return}\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.853Z",
        "size": 1182
      }
    },
    {
      "pageContent": "## Getting Public View\n\nUsers with public connection have access to the Public View which shares not encrypted fields of the Inbox, such as `publicMeta`.\n\n```swift\n    let inboxID = \"INBOX_ID\" \n    guard let inboxPublicView = try? publicEndpointSession?.inboxApi?.getInboxPublicView(for: inboxID) else {return}\n    guard let inboxPublicMetaData = inboxPublicView.publicMeta.getData() else {return}\n    let inboxPublicMetaDecoded = try? JSONDecoder().decode(InboxPublicMeta.self, from: inboxPublicMetaData)\n```\n\n\n\n### Assumptions \nWe use some structures in following examples:\n```swift\nstruct InboxPublicMeta:Codable{\n    let tags: [String]\n    //definition by developer\n}\n```",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/swift/inboxes.mdx",
        "type": "mdx",
        "chunkIndex": 3,
        "headers": [
          "Getting Public View",
          "Assumptions"
        ],
        "title": "Getting Public View",
        "codeBlocks": [
          "```swift\n    let inboxID = \"INBOX_ID\" \n    guard let inboxPublicView = try? publicEndpointSession?.inboxApi?.getInboxPublicView(for: inboxID) else {return}\n    guard let inboxPublicMetaData = inboxPublicView.publicMeta.getData() else {return}\n    let inboxPublicMetaDecoded = try? JSONDecoder().decode(InboxPublicMeta.self, from: inboxPublicMetaData)\n```",
          "```swift\nstruct InboxPublicMeta:Codable{\n    let tags: [String]\n    //definition by developer\n}\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.853Z",
        "size": 675
      }
    },
    {
      "pageContent": "## Creating Inboxes\n\n<Tabs groupId=\"variant\" items={[\"Basic\",\"With Config\",\"With Name\",\"With publicMeta\"]}>\n<Tab>\nCreating a basic, unnamed Inbox, which can act as an encrypted data container:\n```swift\n let users = [privmx.endpoint.core.UserWithPubKey]() //should be prepared by developer\nlet managers = [privmx.endpoint.core.UserWithPubKey]() //should be prepared by developer\nlet publicMeta = Data()\nlet privateMeta = Data()\n\nlet inboxId = try? endpointSession?.inboxApi?.createInbox(\n    in: contextId,\n    for: users,\n    managedBy: managers,\n    withPublicMeta: publicMeta,\n    withPrivateMeta: privateMeta,\n    withFilesConfig: nil,\n    withPolicies: nil\n    )\n```\n</Tab>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/swift/inboxes.mdx",
        "type": "mdx",
        "chunkIndex": 4,
        "headers": [
          "Creating Inboxes"
        ],
        "title": "Creating Inboxes",
        "codeBlocks": [
          "```swift\n let users = [privmx.endpoint.core.UserWithPubKey]() //should be prepared by developer\nlet managers = [privmx.endpoint.core.UserWithPubKey]() //should be prepared by developer\nlet publicMeta = Data()\nlet privateMeta = Data()\n\nlet inboxId = try? endpointSession?.inboxApi?.createInbox(\n    in: contextId,\n    for: users,\n    managedBy: managers,\n    withPublicMeta: publicMeta,\n    withPrivateMeta: privateMeta,\n    withFilesConfig: nil,\n    withPolicies: nil\n    )\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.853Z",
        "size": 677
      }
    },
    {
      "pageContent": "<Tab>\nFirst, you need to specify constraints for inbound traffic size limits:\n```swift\nlet privMXFilesConfig = privmx.endpoint.inbox.FilesConfig(\n    minCount:0,\n    maxCount:10,\n    maxFileSize:500,\n    maxWholeUploadSize:2000\n    )\n```\nCreating a basic, unnamed Inbox, which can act as an encrypted data container:\n```swift\nlet users = [privmx.endpoint.core.UserWithPubKey]() //should be prepared by developer\nlet managers = [privmx.endpoint.core.UserWithPubKey]() //should be prepared by developer\nlet publicMeta = Data()\nlet privateMeta = Data()\n\nlet inboxId = try? endpointSession?.inboxApi?.createInbox(\n    in: contextId,\n    for: users,\n    managedBy: managers,\n    withPublicMeta: publicMeta,\n    withPrivateMeta: privateMeta,\n    withFilesConfig:privMXFilesConfig,\n    withPolicies: nil\n    )\n\n```\n</Tab>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/swift/inboxes.mdx",
        "type": "mdx",
        "chunkIndex": 5,
        "codeBlocks": [
          "```swift\nlet privMXFilesConfig = privmx.endpoint.inbox.FilesConfig(\n    minCount:0,\n    maxCount:10,\n    maxFileSize:500,\n    maxWholeUploadSize:2000\n    )\n```",
          "```swift\nlet users = [privmx.endpoint.core.UserWithPubKey]() //should be prepared by developer\nlet managers = [privmx.endpoint.core.UserWithPubKey]() //should be prepared by developer\nlet publicMeta = Data()\nlet privateMeta = Data()\n\nlet inboxId = try? endpointSession?.inboxApi?.createInbox(\n    in: contextId,\n    for: users,\n    managedBy: managers,\n    withPublicMeta: publicMeta,\n    withPrivateMeta: privateMeta,\n    withFilesConfig:privMXFilesConfig,\n    withPolicies: nil\n    )\n\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.853Z",
        "size": 814
      }
    },
    {
      "pageContent": "```\n</Tab>\n\n<Tab>\nYou can assign any data to private and public meta fields (e.g. the Inbox's name), as long as it is serialized to byte array:\n```swift\nlet users = [privmx.endpoint.core.UserWithPubKey]() //should be prepared by developer\nlet managers = [privmx.endpoint.core.UserWithPubKey]() //should be prepared by developer\nlet publicMeta = Data()\nguard let privateMeta = \"Inbox Name\".data(using: .utf8) else {return}\n\nlet inboxId = try? endpointSession?.inboxApi?.createInbox(\n    in: contextId,\n    for: users,\n    managedBy: managers,\n    withPublicMeta: publicMeta,\n    withPrivateMeta: privateMeta,\n    withFilesConfig:nil,\n    withPolicies:nil\n)",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/swift/inboxes.mdx",
        "type": "mdx",
        "chunkIndex": 6,
        "codeBlocks": [
          "```\n</Tab>\n\n<Tab>\nYou can assign any data to private and public meta fields (e.g. the Inbox's name), as long as it is serialized to byte array:\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.853Z",
        "size": 655
      }
    },
    {
      "pageContent": "```\n</Tab>\n<Tab>\nYou can implement a tag system, which allows you to create Inboxes with arbitrary tags. Putting them inside `publicMeta` gives your own server the ability to access it using Bridge REST API.\n```swift\nlet inboxPublicMeta = InboxPublicMeta(tags: [\"TAG1\",\"TAG2\",\"TAG3\"])\n        \nlet users = [privmx.endpoint.core.UserWithPubKey]() //should be prepared by developer\nlet managers = [privmx.endpoint.core.UserWithPubKey]() //should be prepared by developer\nguard let inboxPublicMetaData =   try? JSONEncoder().encode(inboxPublicMeta) else {return}\nguard let privateMeta = \"Inbox Name\".data(using: .utf8) else {return}\n\nlet inboxId = try? endpointSession?.inboxApi?.createInbox(\n    in: contextId,\n    for: users,\n    managedBy: managers,\n    withPublicMeta: inboxPublicMetaData,\n    withPrivateMeta: privateMeta,\n    withFilesConfig:nil,\n    withPolicies:nil\n)\n```\n</Tab>\n</Tabs>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/swift/inboxes.mdx",
        "type": "mdx",
        "chunkIndex": 7,
        "codeBlocks": [
          "```\n</Tab>\n<Tab>\nYou can implement a tag system, which allows you to create Inboxes with arbitrary tags. Putting them inside `publicMeta` gives your own server the ability to access it using Bridge REST API.\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.854Z",
        "size": 891
      }
    },
    {
      "pageContent": "## Getting Inboxes\n\n\n<Tabs groupId=\"variant\" items={[\"Most Recent\",\"Oldest\",\"By `inboxId`\"]}>\n<Tab>\nFetching the most recent Inboxes in given Context:\n```swift\nlet startIndex:Int64 = 0\nlet pageSize:Int64 = 100\n\nguard let pagingList = try? endpointSession?.inboxApi?\n    .listInboxes(\n        from:contextId,\n        basedOn: .init(skip: startIndex, limit: pageSize, sortOrder: .desc)) else {return}\n\nlet inboxes = pagingList.readItems.map { $0 }\n\n```\n</Tab>\n\n<Tab>\nFetching the oldest Inboxes (by creation date) in given Context:\n```swift\nlet startIndex:Int64 = 0\nlet pageSize:Int64 = 100\n    \nguard let pagingList = try? endpointSession?.inboxApi?\n    .listInboxes(\n        from:contextId,\n        basedOn: .init(skip: startIndex, limit: pageSize, sortOrder: .asc)) else {return}\n\nlet inboxes = pagingList.readItems.map { $0 }\n```\n</Tab>\n<Tab>\nYou can get info about an Inbox using its `inboxId`:\n```swift\nvar inboxID = \"INBOX_ID\"\nguard let inbox = try? endpointSession?.inboxApi?\n    .getInbox(inboxID) else {return}\n```\n</Tab>\n</Tabs>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/swift/inboxes.mdx",
        "type": "mdx",
        "chunkIndex": 8,
        "headers": [
          "Getting Inboxes"
        ],
        "title": "Getting Inboxes",
        "codeBlocks": [
          "```swift\nlet startIndex:Int64 = 0\nlet pageSize:Int64 = 100\n\nguard let pagingList = try? endpointSession?.inboxApi?\n    .listInboxes(\n        from:contextId,\n        basedOn: .init(skip: startIndex, limit: pageSize, sortOrder: .desc)) else {return}\n\nlet inboxes = pagingList.readItems.map { $0 }\n\n```",
          "```swift\nlet startIndex:Int64 = 0\nlet pageSize:Int64 = 100\n    \nguard let pagingList = try? endpointSession?.inboxApi?\n    .listInboxes(\n        from:contextId,\n        basedOn: .init(skip: startIndex, limit: pageSize, sortOrder: .asc)) else {return}\n\nlet inboxes = pagingList.readItems.map { $0 }\n```",
          "```swift\nvar inboxID = \"INBOX_ID\"\nguard let inbox = try? endpointSession?.inboxApi?\n    .getInbox(inboxID) else {return}\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.854Z",
        "size": 1037
      }
    },
    {
      "pageContent": "## Managing Inboxes\n\n<Tabs groupId=\"variant\" items={[\"Renaming Inbox\",\"Removing User\",\"Deleting Inbox\"]}>\n<Tab>\nTo update an Inbox you must always provide its current version, as well as:\n- list of users\n- list of managers\n- new private and public meta (even if it didn't change)\n- Inbox's current version\n- Inbox FilesConfig\n- `true` if update action should be forced\n\n```swift\nlet inboxId = \"INBOX_ID\"\n        let inboxPublicMeta = InboxPublicMeta(tags: [\"TAG1\",\"TAG2\",\"TAG3\"])\n        guard let publicMeta = try? JSONEncoder().encode(inboxPublicMeta) else {return}\n        guard let inbox = try? endpointSession?.inboxApi?\n            .getInbox(inboxId) else {return}",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/swift/inboxes.mdx",
        "type": "mdx",
        "chunkIndex": 9,
        "headers": [
          "Managing Inboxes"
        ],
        "title": "Managing Inboxes",
        "lastModified": "2025-06-05T19:33:57.854Z",
        "size": 670
      }
    },
    {
      "pageContent": "//users list to be extracted from inbox\n        let users = inbox.users.map{\n            //Your application must provide a way,\n            //to get user's public key from their userId.\n            privmx.endpoint.core.UserWithPubKey(userId: $0, pubKey: \"PUB\")\n        }\n        //managers list to be extracted from inbox\n        let managers = inbox.managers.map{\n            //Your application must provide a way,\n            //to get user's public key from their userId.\n            privmx.endpoint.core.UserWithPubKey(userId: $0, pubKey: \"PUB\")\n        }\n\n        guard let newPrivateMeta = \"New Inbox name\".data(using: .utf8) else {return}\n        guard let filesConfig:privmx.endpoint.inbox.FilesConfig = inbox.filesConfig.value else {return}",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/swift/inboxes.mdx",
        "type": "mdx",
        "chunkIndex": 10,
        "lastModified": "2025-06-05T19:33:57.854Z",
        "size": 748
      }
    },
    {
      "pageContent": "guard let newPrivateMeta = \"New Inbox name\".data(using: .utf8) else {return}\n        guard let filesConfig:privmx.endpoint.inbox.FilesConfig = inbox.filesConfig.value else {return}\n\n        _ = try? endpointSession?.inboxApi?.updateInbox(\n            inboxId,\n            replacingUsers: users,\n            replacingManagers: managers,\n            replacingPublicMeta: inbox.publicMeta.getData() ?? Data(),\n            replacingPrivateMeta: newPrivateMeta,\n            replacingFilesConfig: filesConfig,\n            atVersion: inbox.version,\n            force:false,\n            forceGenerateNewKey: false,\n            replacingPolicies:nil)\n\n\n```\n</Tab>\n\n<Tab>\nTo remove a user from an Inbox you must provide:\n- list of all the users, without the user you want to remove\n- list of managers\n- new private and public meta (even if it didn't change)\n- Inbox's current version\n- Inbox FilesConfig\n- `true` if update action should be forced\n\n```swift\nlet inboxId = \"INBOX_ID\"",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/swift/inboxes.mdx",
        "type": "mdx",
        "chunkIndex": 11,
        "codeBlocks": [
          "```\n</Tab>\n\n<Tab>\nTo remove a user from an Inbox you must provide:\n- list of all the users, without the user you want to remove\n- list of managers\n- new private and public meta (even if it didn't change)\n- Inbox's current version\n- Inbox FilesConfig\n- `true` if update action should be forced\n\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.854Z",
        "size": 971
      }
    },
    {
      "pageContent": "```swift\nlet inboxId = \"INBOX_ID\"\n\nlet inboxPublicMeta = InboxPublicMeta(tags: [\"TAG1\",\"TAG2\",\"TAG3\"])\nguard let publicMeta = try? JSONEncoder().encode(inboxPublicMeta) else {return}\nguard let inbox = try? endpointSession?.inboxApi?\n    .getInbox(inboxId) else {return}\n\n//users list to be extracted from inbox\nlet users = inbox.users.filter{\n    $0 != \"username-to-remove\"\n}.map{\n    //Your application must provide a way,\n    //to get user's public key from their userId.\n    privmx.endpoint.core.UserWithPubKey(userId: $0, pubKey: \"PUB\")\n}\n//managers list to be extracted from inbox\nlet managers = inbox.managers.map{\n    //Your application must provide a way,\n    //to get user's public key from their userId.\n    privmx.endpoint.core.UserWithPubKey(userId: $0, pubKey: \"PUB\")\n}\n\nguard let newPrivateMeta = \"New Inbox name\".data(using: .utf8) else {return}\nguard let filesConfig:privmx.endpoint.inbox.FilesConfig = inbox.filesConfig.value else {return}",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/swift/inboxes.mdx",
        "type": "mdx",
        "chunkIndex": 12,
        "lastModified": "2025-06-05T19:33:57.854Z",
        "size": 956
      }
    },
    {
      "pageContent": "guard let newPrivateMeta = \"New Inbox name\".data(using: .utf8) else {return}\nguard let filesConfig:privmx.endpoint.inbox.FilesConfig = inbox.filesConfig.value else {return}\n\n_ = try? endpointSession?.inboxApi?.updateInbox(\n    inboxId,\n    replacingUsers: users,\n    replacingManagers: managers,\n    replacingPublicMeta: inbox.publicMeta.getData() ?? Data(),\n    replacingPrivateMeta: newPrivateMeta,\n    replacingFilesConfig: filesConfig,\n    atVersion: inbox.version,\n    force:false,\n    forceGenerateNewKey: false,\n    replacingPolicies:nil)\n\n```\n</Tab>\n\n<Tab>\nThe snippet below deletes Inbox and all its data. This action is irreversible.\n```swift\ntry? endpointSession?.inboxApi?.deleteInbox(inboxID)\n\t\t\t\t\t\n```\n</Tab>\n\n</Tabs>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/swift/inboxes.mdx",
        "type": "mdx",
        "chunkIndex": 13,
        "codeBlocks": [
          "```\n</Tab>\n\n<Tab>\nThe snippet below deletes Inbox and all its data. This action is irreversible.\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.854Z",
        "size": 731
      }
    },
    {
      "pageContent": "---\ntitle: Overview\n---\n\nThis part of the documentation describes our solutions to simplify working with PrivMX Endpoint C++ library inside Swift projects.",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/swift/index.mdx",
        "type": "mdx",
        "chunkIndex": 0,
        "lastModified": "2025-06-05T19:33:57.854Z",
        "size": 155
      }
    },
    {
      "pageContent": "## Libraries\n\n### PrivMX Endpoint Swift Extra\n\nPrivMX Endpoint Swift Extra is the basic **recommended library** for using the Platform in most cases. \nIt contains all the logic that makes using our libraries simple and secure. \nIt can be used on any Apple platform (iOS/macOS/simulators).\n\nThis library implements:\n\n- Enums and static fields to reduce errors while using the methods.\n- [`PrivmxEndpoint`](./reference/privmx-endpoint-swift-extra/core/privmx-endpoint) for managing connection and registering callbacks on any events.\n- [`PrivmxEndpointContainer`](./reference/privmx-endpoint-swift-extra/core/privmx-endpoint-container) for managing global session with implemented event loop.\n- Classes to simplify reading/writing to files using byte arrays and FileHandles.\n\n[Go to Reference](./reference/privmx-endpoint-swift-extra/core/privmx-endpoint) for a detailed description of each class.",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/swift/index.mdx",
        "type": "mdx",
        "chunkIndex": 1,
        "headers": [
          "Libraries",
          "PrivMX Endpoint Swift Extra"
        ],
        "title": "Libraries",
        "lastModified": "2025-06-05T19:33:57.854Z",
        "size": 895
      }
    },
    {
      "pageContent": "### PrivMX Endpoint Swift\n\nPrivMX Endpoint Swift is the minimal wrapper library, crucial for the Platform's functioning. It declares native functions in Swift using C++ interoperability, so it's crucial to turn it on in compiler Settings.\n\nThis library implements models, exception catching, and the following modules:\n- `CryptoApi` - Cryptographic methods used to encrypt/decrypt and sign your data or generate keys to work with PrivMX Bridge.\n- `Connection` - Methods for managing connection with PrivMX Bridge.\n- `ThreadApi` - Methods for managing Threads and sending/reading messages.\n- `StoreApi` - Methods for managing Stores and sending/reading files.\n- `InboxApi` - Methods for managing Inboxes and entries.\n\n[PrivMX Endpoint Swift API Reference](../reference/privmx-endpoint-swift/core/backend-requester)",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/swift/index.mdx",
        "type": "mdx",
        "chunkIndex": 2,
        "headers": [
          "PrivMX Endpoint Swift"
        ],
        "title": "PrivMX Endpoint Swift",
        "lastModified": "2025-06-05T19:33:57.854Z",
        "size": 813
      }
    },
    {
      "pageContent": "---\ntitle: Messages\n---\n\nSending messages in Threads.\n\n:::info\n\nBefore working with messages, follow our [Getting Started Guide](./getting-started). It will show you how to set up your project to work with PrivMX Bridge.\\\n\\\nThe sample code on this page is based on the **[initial assumptions](./getting-started#initial-assumptions)**.\\\n\\\nAll policies in the following examples can be build with [Policy Builders](./policy-builders), according to [Policies overview](../start/concepts/policies). \\\n\\\nMessage `data`, `publicMeta` and `privateMeta` fields support any kind of data formats encoded to byte arrays. Examples in this section use JSON format serialization which is available directly in Swift.\n\n:::\n\n\n## Messages inside Threads\nMessages inside Threads are sent in binary format. Before sending a message, you need to decide on the message format and choose the appropriate data serialization method.\n\nFor more information about the Threads architecture and best practices for sending messages, visit the [Threads Documentation](../start/threads/messages)",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/swift/messages.mdx",
        "type": "mdx",
        "chunkIndex": 0,
        "headers": [
          "Messages inside Threads"
        ],
        "title": "Messages inside Threads",
        "lastModified": "2025-06-05T19:33:57.854Z",
        "size": 1063
      }
    },
    {
      "pageContent": "## Sending Messages\n\n<Tabs groupId=\"variant\" items={[\"Plain Text\",\"With Public Meta\"]}>\n<Tab>\nExample of sending a message in Plain Text:\n```swift\nlet threadId = \"SOME_THREAD_ID\"\nguard let messageData = \"\".data(using: .utf8) else {return}\n// In this example, both publicMeta and privateMeta are empty.\nlet messageID = try? endpointSession?.threadApi?.sendMessage(\n    in: threadId,\n    withPublicMeta: Data(),\n    withPrivateMeta: Data(),\n    containing: messageData)\n```\n</Tab>\n<Tab>\nThe snippet below shows how to set up a feature allowing users to respond to messages and define message public meta structure:\n```swift\n let threadId = \"SOME_THREAD_ID\"\n        \n//As an example we can put in publicMeta a reference to message we are respoding to\n//This structure is entirely optional and is contingent upon the developer’s decisions.\nlet messageIdToRespond = \"MESSAGE_ID_TO_RESPOND\"\nstruct MessagePublicMeta:Codable{\n    let responseTo: String\n}\n\nguard let messageData = \"Message text\".data(using: .utf8) else {return}\n\nlet publicMeta = MessagePublicMeta(responseTo: messsageIdToRespond)\nguard let publicMetaData = try? JSONEncoder().encode(publicMeta) else {return}",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/swift/messages.mdx",
        "type": "mdx",
        "chunkIndex": 1,
        "headers": [
          "Sending Messages"
        ],
        "title": "Sending Messages",
        "codeBlocks": [
          "```swift\nlet threadId = \"SOME_THREAD_ID\"\nguard let messageData = \"\".data(using: .utf8) else {return}\n// In this example, both publicMeta and privateMeta are empty.\nlet messageID = try? endpointSession?.threadApi?.sendMessage(\n    in: threadId,\n    withPublicMeta: Data(),\n    withPrivateMeta: Data(),\n    containing: messageData)\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.854Z",
        "size": 1168
      }
    },
    {
      "pageContent": "let publicMeta = MessagePublicMeta(responseTo: messsageIdToRespond)\nguard let publicMetaData = try? JSONEncoder().encode(publicMeta) else {return}\n\nlet messageID = try? endpointSession?.threadApi?\n    .sendMessage(in: threadId,\n                    withPublicMeta: publicMetaData,\n                    withPrivateMeta:  Data(),\n                    containing: messageData)\n\n```\n</Tab>\n</Tabs>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/swift/messages.mdx",
        "type": "mdx",
        "chunkIndex": 2,
        "lastModified": "2025-06-05T19:33:57.854Z",
        "size": 390
      }
    },
    {
      "pageContent": "## Getting Messages\n\nDefine message item struct with decoded `data` and `publicMeta`. This time we use some decoding of Data fields and mapping generic message to struct used within developed App:\n\n```swift\nstruct MessagePublicMeta:Codable{\n    let responseTo: String\n}\nstruct MessageData:Codable{\n    let content: String\n    let type: String\n}\nstruct MessageItem:Codable{\n    let messageId: String\n    let publicMeta: MessagePublicMeta?\n    let data: MessageData?\n}",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/swift/messages.mdx",
        "type": "mdx",
        "chunkIndex": 3,
        "headers": [
          "Getting Messages"
        ],
        "title": "Getting Messages",
        "lastModified": "2025-06-05T19:33:57.854Z",
        "size": 466
      }
    },
    {
      "pageContent": "```\n\n<Tabs groupId=\"variant\" items={[\"Most Recent\",\"Oldest\",\"By Message ID\"]}>\n<Tab>\nFetching the most recent messages in given Thread:\n\n```swift\nlet threadId = \"THREAD_ID\"\nlet startIndex:Int64 = 0\nlet pageSize:Int64 = 100\n    \nguard let pagingList = try? endpointSession?.threadApi?\n    .listMessages(\n        from:threadId,\n        basedOn: .init(skip: startIndex, limit: pageSize, sortOrder: .desc)) else {return}\n\nlet messages =\n    pagingList.readItems.map {\n        \n        MessageItem(messageId: $0.id,\n                publicMeta: try? JSONDecoder().decode(MessagePublicMeta.self, from: $0.publicMeta.getData() ?? Data()),\n                data: try? JSONDecoder().decode(MessageData.self, from: $0.data.getData() ?? Data()))\n        \n    }\n```\n</Tab>\n\n<Tab>\nFetching the oldest messages (by creation date) in given Thread:\n\n```swift\nlet threadId = \"THREAD_ID\"\nlet startIndex:Int64 = 0\nlet pageSize:Int64 = 100\n\nguard let pagingList = try? endpointSession?.threadApi?\n    .listMessages(\n        from:threadId,\n        basedOn: .init(skip: startIndex, limit: pageSize, sortOrder: .asc)) else {return}",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/swift/messages.mdx",
        "type": "mdx",
        "chunkIndex": 4,
        "codeBlocks": [
          "```\n\n<Tabs groupId=\"variant\" items={[\"Most Recent\",\"Oldest\",\"By Message ID\"]}>\n<Tab>\nFetching the most recent messages in given Thread:\n\n```",
          "```\n</Tab>\n\n<Tab>\nFetching the oldest messages (by creation date) in given Thread:\n\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.854Z",
        "size": 1106
      }
    },
    {
      "pageContent": "guard let pagingList = try? endpointSession?.threadApi?\n    .listMessages(\n        from:threadId,\n        basedOn: .init(skip: startIndex, limit: pageSize, sortOrder: .asc)) else {return}\n\nlet messages =\n    pagingList.readItems.map {\n    MessageItem(messageId: $0.id,\n            publicMeta: try? JSONDecoder().decode(MessagePublicMeta.self, from: $0.publicMeta.getData() ?? Data()),\n            data: try? JSONDecoder().decode(MessageData.self, from: $0.data.getData() ?? Data()))\n    \n    }\n```\n</Tab>\n<Tab>\nYou can get info about a Message using its `messageId`:\n\n```swift\nlet messageId = \"MESSAGE_ID\"\nguard let message = try? endpointSession?.threadApi?\n.getMessage(messageId) else {return}\n\nlet messageItem =\n    MessageItem(\n        messageId: message.id,\n        publicMeta: try? JSONDecoder().decode(MessagePublicMeta.self, from: message.publicMeta.getData() ?? Data()),\n        data: try? JSONDecoder().decode(MessageData.self, from: message.data.getData() ?? Data()))\n\n```\n</Tab>\n</Tabs>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/swift/messages.mdx",
        "type": "mdx",
        "chunkIndex": 5,
        "codeBlocks": [
          "```\n</Tab>\n<Tab>\nYou can get info about a Message using its `messageId`:\n\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.854Z",
        "size": 998
      }
    },
    {
      "pageContent": "## Managing Messages\n\n<Tabs groupId=\"variant\" items={[\"Updating Message\",\"Deleting Message\"]}>\n<Tab>\nExample of updating the message content:\n\n```swift\nvar messageId = \"MESSAGE_ID\"\n         \nguard let message = try? endpointSession?.threadApi?\n    .getMessage(messageId) else {return}\nlet newMessage = MessageData(content: \"Hello World\", type: \"text\")\nguard let newMessageData = try?  JSONEncoder().encode(newMessage) else {return}\nguard let privateMeta = message.privateMeta.getData() else {return}\nguard let publicMeta = message.publicMeta.getData() else {return}\n\ntry? endpointSession?.threadApi?\n    .updateMessage(message.id,\n                    replacingData: newMessageData ,\n                    replacingPublicMeta: privateMeta,\n                    replacingPrivateMeta: publicMeta)\n\n\n```\n</Tab>\n\n<Tab>\nThe snippet below deletes Message and all its data. This action is irreversible.\n```swift\nvar messageId = \"MESSAGE_ID\"\ntry? endpointSession?.threadApi?.deleteMessage(messageId)\n```\n</Tab>\n\n</Tabs>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/swift/messages.mdx",
        "type": "mdx",
        "chunkIndex": 6,
        "headers": [
          "Managing Messages"
        ],
        "title": "Managing Messages",
        "codeBlocks": [
          "```swift\nvar messageId = \"MESSAGE_ID\"\n         \nguard let message = try? endpointSession?.threadApi?\n    .getMessage(messageId) else {return}\nlet newMessage = MessageData(content: \"Hello World\", type: \"text\")\nguard let newMessageData = try?  JSONEncoder().encode(newMessage) else {return}\nguard let privateMeta = message.privateMeta.getData() else {return}\nguard let publicMeta = message.publicMeta.getData() else {return}\n\ntry? endpointSession?.threadApi?\n    .updateMessage(message.id,\n                    replacingData: newMessageData ,\n                    replacingPublicMeta: privateMeta,\n                    replacingPrivateMeta: publicMeta)\n\n\n```",
          "```swift\nvar messageId = \"MESSAGE_ID\"\ntry? endpointSession?.threadApi?.deleteMessage(messageId)\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.854Z",
        "size": 1007
      }
    },
    {
      "pageContent": "---\ntitle: Policy Builders\n---\n\n\n\n\nPrivMX Endpoint has configurable policies that determine who can perform specified actions in Containers and Items. To learn more about them see the [Policies documentation](../start/concepts/policies).\n\n\nPrivMX Endpoint Swift Extra package provides an enumeration of possible policy values in `ItemPolicyValue`, `ContainerPolicyValue` and `SpecialPolicyValue` enums; as well as `ItemPolicyBuilder` and `ContainerPolicyBuilder` classes for configuring the respective Policies.\n\n## Combining Policy Values\n\nSome policy values like `ContainerPolicyComplexValue` or `ItemPolicyComplexValue` can be combined\nwith the same type of policy value using `.AND()` or `.OR()` methods.",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/swift/policy-builders.mdx",
        "type": "mdx",
        "chunkIndex": 0,
        "headers": [
          "Combining Policy Values"
        ],
        "title": "Combining Policy Values",
        "lastModified": "2025-06-05T19:33:57.855Z",
        "size": 708
      }
    },
    {
      "pageContent": "## Configuring a Container Policy\n\nNot configured builder will create an empty policy, which is equivalent to setting `inherit` in all fields. To configure it, call the methods responsible for setting particular policies.\nThose calls can be chained together, since each of the methods setting a policy value returns the reference to the builder.\nThe `ContainerPolicyBuilder` can build both `ContainerPolicy` and `ContainerPolicyWithoutItem` by calling `.build()` and `.buildWithoutItem()` respectively.\n\nTo build the `ItemPolicy`, use `ItemPolicyBuilder` which works in the same way as `ContainerPolicyBuilder`:\n\n\n<Tabs groupId=\"variant\" items={[\"Container Policy\",\"Container Policy without Item\",\"Item Policy\"]}>\n<Tab>\n```swift\n ContainerPolicyBuilder()\n                .setUpdate(.all)\n                .setGet(.all)\n                .setItem(ItemPolicyBuilder()\n                        .setUpdate(\n                            .itemOwner\n                            .or(.manager)\n                            .or(.owner.and(.user)))\n                        .setGet(.all)\n                        .build())\n                .build()\n```\n</Tab>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/swift/policy-builders.mdx",
        "type": "mdx",
        "chunkIndex": 1,
        "headers": [
          "Configuring a Container Policy"
        ],
        "title": "Configuring a Container Policy",
        "codeBlocks": [
          "```swift\n ContainerPolicyBuilder()\n                .setUpdate(.all)\n                .setGet(.all)\n                .setItem(ItemPolicyBuilder()\n                        .setUpdate(\n                            .itemOwner\n                            .or(.manager)\n                            .or(.owner.and(.user)))\n                        .setGet(.all)\n                        .build())\n                .build()\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.855Z",
        "size": 1139
      }
    },
    {
      "pageContent": "<Tab>\n```swift\n ContainerPolicyBuilder()\n            .setUpdate(.all)\n            .setGet(.all)\n            .buildWithoutItem()\n```\n</Tab>\n\n<Tab>\n```swift\nItemPolicyBuilder()\n\t.setUpdate(\n\t    .itemOwner\n        .or(.manager)\n        .or(.owner\n            .and(.user)\n            )\n        )\n\t.setGet(.all)\n\t.build()\n```\n</Tab>\n</Tabs>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/swift/policy-builders.mdx",
        "type": "mdx",
        "chunkIndex": 2,
        "codeBlocks": [
          "```swift\n ContainerPolicyBuilder()\n            .setUpdate(.all)\n            .setGet(.all)\n            .buildWithoutItem()\n```",
          "```swift\nItemPolicyBuilder()\n\t.setUpdate(\n\t    .itemOwner\n        .or(.manager)\n        .or(.owner\n            .and(.user)\n            )\n        )\n\t.setGet(.all)\n\t.build()\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.855Z",
        "size": 336
      }
    },
    {
      "pageContent": "---\ntitle: Overview\n---\n\nStores provide encrypted block storage, enabling simple file uploading and downloading. \n\n:::info\n\nBefore working with Stores, follow our [Getting Started Guide](./getting-started). It will show you how to set up your project to work with PrivMX Bridge.\\\n\\\nThe sample code on this page is based on the **[initial assumptions](./getting-started#initial-assumptions)**.\\\n\\\nAll policies in the following examples can be build with [Policy Builders](./policy-builders), according to [Policies overview](../start/concepts/policies). \\\n\\\n`publicMeta` and `privateMeta` fields in Stores support any kind of data formats encoded to byte arrays.\nExamples in this section use JSON format serialization, which is available directly in Swift.\n\n:::",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/swift/stores.mdx",
        "type": "mdx",
        "chunkIndex": 0,
        "lastModified": "2025-06-05T19:33:57.856Z",
        "size": 760
      }
    },
    {
      "pageContent": "## Working with Stores\n\nTo access Store methods, get the field `storeApi` from active connection. Connection should be initialized with `[.store]` passed to [`PrivmxEndpoint`](../reference/privmx-endpoint-swift-extra/core/privmx-endpoint).\n\n<Tabs groupId=\"variant\" items={[\"Swift\"]}>\n<Tab>\n```swift\nprivmxSession.storeApi?.... // instance of StoreApi\n```\n</Tab>\n</Tabs>\n\n### Assumptions\n\nIn further examples, the following structures are used:\n```swift\nstruct StorePublicMeta:Codable{\n    let tags: [String]\n}\n```",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/swift/stores.mdx",
        "type": "mdx",
        "chunkIndex": 1,
        "headers": [
          "Working with Stores",
          "Assumptions"
        ],
        "title": "Working with Stores",
        "codeBlocks": [
          "```swift\nprivmxSession.storeApi?.... // instance of StoreApi\n```",
          "```swift\nstruct StorePublicMeta:Codable{\n    let tags: [String]\n}\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.856Z",
        "size": 513
      }
    },
    {
      "pageContent": "## Creating Stores\n\n<Tabs groupId=\"variant\" items={[\"Basic\",\"With a Name\",\"With publicMeta\"]}>\n<Tab>\nCreating a basic, unnamed Store, which can act as an encrypted data container:\n```swift\nlet contextId = \"CONTEXT_ID\"\n         \nlet users = [privmx.endpoint.core.UserWithPubKey]() //should be prepared by developer\nlet managers = [privmx.endpoint.core.UserWithPubKey]() //should be prepared by developer\nlet publicMeta = Data()\nlet privateMeta = Data()\n\nlet storeId = try? endpointSession?.storeApi?\n    .createStore(in: contextId,\n        for: users,\n        managedBy: managers,\n        withPublicMeta: publicMeta,\n        withPrivateMeta: privateMeta,\n        withPolicies: nil)\n```\n</Tab>\n\n<Tab>\nYou can assign any data to private and public meta fields (e.g. the Store's name), as long as they are serialized to byte array:\n```swift\nlet contextId = \"CONTEXT_ID\"\n        \nlet users = [privmx.endpoint.core.UserWithPubKey]() //should be prepared by developer\nlet managers = [privmx.endpoint.core.UserWithPubKey]() //should be prepared by developer\nlet publicMeta = Data()\nguard let storeNameAsPrivateMeta =  \"New store\".data(using: .utf8) else {return}",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/swift/stores.mdx",
        "type": "mdx",
        "chunkIndex": 2,
        "headers": [
          "Creating Stores"
        ],
        "title": "Creating Stores",
        "codeBlocks": [
          "```swift\nlet contextId = \"CONTEXT_ID\"\n         \nlet users = [privmx.endpoint.core.UserWithPubKey]() //should be prepared by developer\nlet managers = [privmx.endpoint.core.UserWithPubKey]() //should be prepared by developer\nlet publicMeta = Data()\nlet privateMeta = Data()\n\nlet storeId = try? endpointSession?.storeApi?\n    .createStore(in: contextId,\n        for: users,\n        managedBy: managers,\n        withPublicMeta: publicMeta,\n        withPrivateMeta: privateMeta,\n        withPolicies: nil)\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.856Z",
        "size": 1154
      }
    },
    {
      "pageContent": "let storeId = try? endpointSession?.storeApi?\n    .createStore(in: contextId,\n                    for: users,\n                    managedBy: managers,\n                    withPublicMeta: publicMeta,\n                    withPrivateMeta: storeNameAsPrivateMeta,\n                    withPolicies: nil)\n```\n</Tab>\n<Tab>\nYou can implement a tag system which allows you to create Stores with arbitrary tags. Putting them inside `publicMeta` gives your own server the ability to access it using [PrivMX Bridge API](https://bridge.privmx.dev/):\n\n```swift\nlet contextId = \"CONTEXT_ID\"\n         \nlet users = [privmx.endpoint.core.UserWithPubKey]() //should be prepared by developer\nlet managers = [privmx.endpoint.core.UserWithPubKey]() //should be prepared by developer\n\nlet storePublicMeta = StorePublicMeta(tags: [\"TAG1\",\"TAG2\",\"TAG3\"])\nguard let storePublicMetaData = try? JSONEncoder().encode(storePublicMeta) else {return}\n\nguard let storeNameAsPrivateMeta =  \"New store\".data(using: .utf8) else {return}",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/swift/stores.mdx",
        "type": "mdx",
        "chunkIndex": 3,
        "codeBlocks": [
          "```\n</Tab>\n<Tab>\nYou can implement a tag system which allows you to create Stores with arbitrary tags. Putting them inside `publicMeta` gives your own server the ability to access it using [PrivMX Bridge API](https://bridge.privmx.dev/):\n\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.856Z",
        "size": 1000
      }
    },
    {
      "pageContent": "guard let storeNameAsPrivateMeta =  \"New store\".data(using: .utf8) else {return}\n\nlet storeId = try? endpointSession?.storeApi?\n    .createStore(in: contextId,\n                for: users,\n                managedBy: managers,\n                withPublicMeta: storePublicMetaData,\n                withPrivateMeta: storeNameAsPrivateMeta,\n                withPolicies: nil)\n```\n</Tab>\n</Tabs>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/swift/stores.mdx",
        "type": "mdx",
        "chunkIndex": 4,
        "lastModified": "2025-06-05T19:33:57.856Z",
        "size": 388
      }
    },
    {
      "pageContent": "## Getting Stores\n\n<Tabs groupId=\"variant\" items={[\"Most Recent\",\"Oldest\",\"By Store ID\"]}>\n<Tab>\nFetching the most recent Stores in given Context:\n```swift\nvar startIndex:Int64 = 0\nvar pageSize:Int64 = 100\n\nlet contextId = \"CONTEXT_ID\"\n\n    \nguard let pagingList = try? endpointSession?.storeApi?\n    .listStores(\n        from:contextId,\n        basedOn: .init(skip: startIndex, limit: pageSize, sortOrder: .asc)) else {return}\n\nlet stores =\npagingList.readItems.map { $0 }\n```\n</Tab>\n\n<Tab>\nFetching the oldest Stores (by creation date) in given Context:\n```swift\nvar startIndex:Int64 = 0\nvar pageSize:Int64 = 100\n\nlet contextId = \"CONTEXT_ID\"\n\n    \nguard let pagingList = try? endpointSession?.storeApi?\n    .listStores(\n        from:contextId,\n        basedOn: .init(skip: startIndex, limit: pageSize, sortOrder: .desc)) else {return}\n\nlet stores =\npagingList.readItems.map { $0 }\n```\n</Tab>\n<Tab>\nYou can get info about a Store using its `storeId`:\n```swift\nvar storeID = \"STORE_ID\"\n            \n\nguard let file = try? endpointSession?.storeApi?\n    .getStore(storeID) else {return}\n```\n</Tab>\n</Tabs>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/swift/stores.mdx",
        "type": "mdx",
        "chunkIndex": 5,
        "headers": [
          "Getting Stores"
        ],
        "title": "Getting Stores",
        "codeBlocks": [
          "```swift\nvar startIndex:Int64 = 0\nvar pageSize:Int64 = 100\n\nlet contextId = \"CONTEXT_ID\"\n\n    \nguard let pagingList = try? endpointSession?.storeApi?\n    .listStores(\n        from:contextId,\n        basedOn: .init(skip: startIndex, limit: pageSize, sortOrder: .asc)) else {return}\n\nlet stores =\npagingList.readItems.map { $0 }\n```",
          "```swift\nvar startIndex:Int64 = 0\nvar pageSize:Int64 = 100\n\nlet contextId = \"CONTEXT_ID\"\n\n    \nguard let pagingList = try? endpointSession?.storeApi?\n    .listStores(\n        from:contextId,\n        basedOn: .init(skip: startIndex, limit: pageSize, sortOrder: .desc)) else {return}\n\nlet stores =\npagingList.readItems.map { $0 }\n```",
          "```swift\nvar storeID = \"STORE_ID\"\n            \n\nguard let file = try? endpointSession?.storeApi?\n    .getStore(storeID) else {return}\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.856Z",
        "size": 1105
      }
    },
    {
      "pageContent": "## Managing Stores\n\n<Tabs groupId=\"variant\" items={[\"Renaming Store\",\"Removing User\",\"Deleting Store\"]}>\n<Tab>\nTo update a Store you must always provide its current version, as well as:\n- list of users\n- list of managers\n- new private and public meta (even if it didn't change)\n- Store's current version\n- `true` if update action should be forced\n\n```swift\n guard let store = try? endpointSession?.storeApi?\n    .getStore(storeId) else {return}\n\n//users list to be extracted from store\nlet users = store.users\n    .map{\n    //Your application must provide a way,\n    //to get user's public key from their userId.\n    privmx.endpoint.core.UserWithPubKey(userId: $0, pubKey: \"PUB\")\n}\n//managers list to be extracted from store\nlet managers = store.managers.map{\n    //Your application must provide a way,\n    //to get user's public key from their userId.\n    privmx.endpoint.core.UserWithPubKey(userId: $0, pubKey: \"PUB\")\n}\n\nguard let newPrivateMeta = \"New store name\".data(using: .utf8) else {return}",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/swift/stores.mdx",
        "type": "mdx",
        "chunkIndex": 6,
        "headers": [
          "Managing Stores"
        ],
        "title": "Managing Stores",
        "lastModified": "2025-06-05T19:33:57.856Z",
        "size": 999
      }
    },
    {
      "pageContent": "guard let newPrivateMeta = \"New store name\".data(using: .utf8) else {return}\n\n_ = try? endpointSession?.storeApi?.updateStore(\n    storeId,\n    atVersion: store.version,\n    replacingUsers: users,\n    replacingManagers: managers,\n    replacingPublicMeta: store.publicMeta.getData() ?? Data(),\n    replacingPrivateMeta: newPrivateMeta,\n    force:false,\n    forceGenerateNewKey: false,\n    replacingPolicies:nil)\n\n```\n</Tab>\n\n<Tab>\nTo remove a user from a Store you must provide:\n- list of all the users, without the user you want to remove\n- list of managers\n- new private and public meta (even if it didn't change)\n- Store's current version\n- `true` if update action should be forced\n\n```swift\n var storeId = \"STORE_ID\"\n\nguard let store = try? endpointSession?.storeApi?\n    .getStore(storeId) else {return}",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/swift/stores.mdx",
        "type": "mdx",
        "chunkIndex": 7,
        "codeBlocks": [
          "```\n</Tab>\n\n<Tab>\nTo remove a user from a Store you must provide:\n- list of all the users, without the user you want to remove\n- list of managers\n- new private and public meta (even if it didn't change)\n- Store's current version\n- `true` if update action should be forced\n\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.856Z",
        "size": 807
      }
    },
    {
      "pageContent": "```swift\n var storeId = \"STORE_ID\"\n\nguard let store = try? endpointSession?.storeApi?\n    .getStore(storeId) else {return}\n\n//users list to be extracted from store\nlet users = store.users\n    .filter{\n        $0 != \"username-to-remove\"\n    }\n    .map{\n    //Your application must provide a way,\n    //to get user's public key from their userId.\n    privmx.endpoint.core.UserWithPubKey(userId: $0, pubKey: \"PUB\")\n}\n//managers list to be extracted from store\nlet managers = store.managers.map{\n    //Your application must provide a way,\n    //to get user's public key from their userId.\n    privmx.endpoint.core.UserWithPubKey(userId: $0, pubKey: \"PUB\")\n}\n\nguard let newPrivateMeta = \"New store name\".data(using: .utf8) else {return}\n\n_ = try? endpointSession?.storeApi?.updateStore(\n    storeId,\n    atVersion: store.version,\n    replacingUsers: users,\n    replacingManagers: managers,\n    replacingPublicMeta: store.publicMeta.getData() ?? Data(),\n    replacingPrivateMeta: store.privateMeta.getData() ?? Data(),\n    force:false,\n    forceGenerateNewKey: false,\n    replacingPolicies: nil)\n\n```\n</Tab>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/swift/stores.mdx",
        "type": "mdx",
        "chunkIndex": 8,
        "codeBlocks": [
          "```swift\n var storeId = \"STORE_ID\"\n\nguard let store = try? endpointSession?.storeApi?\n    .getStore(storeId) else {return}\n\n//users list to be extracted from store\nlet users = store.users\n    .filter{\n        $0 != \"username-to-remove\"\n    }\n    .map{\n    //Your application must provide a way,\n    //to get user's public key from their userId.\n    privmx.endpoint.core.UserWithPubKey(userId: $0, pubKey: \"PUB\")\n}\n//managers list to be extracted from store\nlet managers = store.managers.map{\n    //Your application must provide a way,\n    //to get user's public key from their userId.\n    privmx.endpoint.core.UserWithPubKey(userId: $0, pubKey: \"PUB\")\n}\n\nguard let newPrivateMeta = \"New store name\".data(using: .utf8) else {return}\n\n_ = try? endpointSession?.storeApi?.updateStore(\n    storeId,\n    atVersion: store.version,\n    replacingUsers: users,\n    replacingManagers: managers,\n    replacingPublicMeta: store.publicMeta.getData() ?? Data(),\n    replacingPrivateMeta: store.privateMeta.getData() ?? Data(),\n    force:false,\n    forceGenerateNewKey: false,\n    replacingPolicies: nil)\n\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.856Z",
        "size": 1101
      }
    },
    {
      "pageContent": "```\n</Tab>\n\n<Tab>\nThe snippet below deletes Store and all its data. This action is irreversible.\n```swift\nvar storeId = \"STORE_ID\"\n         \ntry? endpointSession?.storeApi?.deleteStore(storeId)\n```\n</Tab>\n\n</Tabs>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/swift/stores.mdx",
        "type": "mdx",
        "chunkIndex": 9,
        "codeBlocks": [
          "```\n</Tab>\n\n<Tab>\nThe snippet below deletes Store and all its data. This action is irreversible.\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.856Z",
        "size": 213
      }
    },
    {
      "pageContent": "---\ntitle: Overview\n---\n\n\n\nThreads are a secure way for assigned members to exchange encrypted messages.\n\n:::info\n\nBefore working with Threads, follow our [Getting Started Guide](./getting-started). It will show you how to set up your project to work with PrivMX Bridge.\\\n\\\nThe sample code on this page is based on the **[initial assumptions](./getting-started#initial-assumptions)**.\\\n\\\nAll policies in the following examples can be build with [Policy Builders](./policy-builders), according to [Policies overview](../start/concepts/policies).\n\n:::\n\n## Working with Threads\n\nTo access Threads methods, get the field [`threadApi`](../../reference/privmx-endpoint-swift/threads/thread-api/) from the active `endpointSession`. Session should be initialized with `[.thread]` and passed to `PrivmxEndpoint`.\n\n<Tabs groupId=\"variant\" items={[\"Swift\"]}>\n<Tab>\n```swift\nendpointSession?.threadApi? // instance of ThreadApi\n```\n</Tab>\n\n</Tabs>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/swift/threads.mdx",
        "type": "mdx",
        "chunkIndex": 0,
        "headers": [
          "Working with Threads"
        ],
        "title": "Working with Threads",
        "codeBlocks": [
          "```swift\nendpointSession?.threadApi? // instance of ThreadApi\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.856Z",
        "size": 935
      }
    },
    {
      "pageContent": "## Creating Threads\n\n<Tabs groupId=\"variant\" items={[\"Basic\",\"With a Name\",\"With publicMeta\"]}>\n<Tab>\nCreating a basic, unnamed Thread, which can act as an encrypted data container.\n```swift\nlet users = [privmx.endpoint.core.UserWithPubKey]() //should be prepared by developer\nlet managers = [privmx.endpoint.core.UserWithPubKey]() //should be prepared by developer\nlet publicMeta = Data()\nlet privateMeta = Data()\n\n_ = try? endpointSession?.threadApi?.createThread(\n    in: contextId,\n    for: users,\n    managedBy: managers,\n    withPublicMeta: publicMeta,\n    withPrivateMeta: privateMeta,\n    withPolicies: nil\n    )\n```\n</Tab>\n\n<Tab>\nYou can assign any data to private and public meta fields (e.g. the Thread's name), as long as they are serialized to byte array.\n```swift\nlet users = [privmx.endpoint.core.UserWithPubKey]() //should be prepared by developer\nlet managers = [privmx.endpoint.core.UserWithPubKey]() //should be prepared by developer\nguard let publicMeta = \"Title\".data(using: .utf8) else {return}\nlet privateMeta = Data()",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/swift/threads.mdx",
        "type": "mdx",
        "chunkIndex": 1,
        "headers": [
          "Creating Threads"
        ],
        "title": "Creating Threads",
        "codeBlocks": [
          "```swift\nlet users = [privmx.endpoint.core.UserWithPubKey]() //should be prepared by developer\nlet managers = [privmx.endpoint.core.UserWithPubKey]() //should be prepared by developer\nlet publicMeta = Data()\nlet privateMeta = Data()\n\n_ = try? endpointSession?.threadApi?.createThread(\n    in: contextId,\n    for: users,\n    managedBy: managers,\n    withPublicMeta: publicMeta,\n    withPrivateMeta: privateMeta,\n    withPolicies: nil\n    )\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.856Z",
        "size": 1041
      }
    },
    {
      "pageContent": "_ = try? endpointSession?.threadApi?.createThread(\n    in: contextId,\n    for: users,\n    managedBy: managers,\n    withPublicMeta: publicMeta,\n    withPrivateMeta: privateMeta,\n    withPolicies: nil)\n```\n</Tab>\n<Tab>\nYou can implement a tag system which allows you to create Threads with arbitrary tags. Putting them inside `publicMeta` gives your own server the ability to access it using [PrivMX Bridge API](https://bridge.privmx.dev/).\n\nDefine Thread public meta structure:\n```swift\nstruct ThreadPublicMeta: Codable{\n    let tags: [String]\n}\n\n        \nlet users = [privmx.endpoint.core.UserWithPubKey]() //should be prepared by developer\nlet managers = [privmx.endpoint.core.UserWithPubKey]() //should be prepared by developer\nlet threadPublicMeta = ThreadPublicMeta(tags: [\"TAG1\",\"TAG2\",\"TAG3\"])\nguard let privateMeta = \"Title\".data(using: .utf8) else {return}\nguard let publicMeta = try? JSONEncoder().encode(threadPublicMeta) else {return}\n\n_ = try? endpointSession?.threadApi?.createThread(\n    in: contextId,\n    for: users,\n    managedBy: managers,\n    withPublicMeta: publicMeta,\n    withPrivateMeta: privateMeta,\n    withPolicies: nil)\n```\n</Tab>\n</Tabs>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/swift/threads.mdx",
        "type": "mdx",
        "chunkIndex": 2,
        "codeBlocks": [
          "```\n</Tab>\n<Tab>\nYou can implement a tag system which allows you to create Threads with arbitrary tags. Putting them inside `publicMeta` gives your own server the ability to access it using [PrivMX Bridge API](https://bridge.privmx.dev/).\n\nDefine Thread public meta structure:\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.856Z",
        "size": 1165
      }
    },
    {
      "pageContent": "## Getting Threads\n\n\n<Tabs groupId=\"variant\" items={[\"Most Recent\",\"Oldest\",\"By `threadId`\"]}>\n<Tab>\nFetching the most recent Threads in given Context:\n```swift\nvar startIndex:Int64 = 0\nvar pageSize:Int64 = 100\n\nguard let pagingList = try? endpointSession?.threadApi?\n.listThreads(\n    from:contextId,\n    basedOn: .init(skip: startIndex, limit: pageSize, sortOrder: .desc)) else {return}\n\nlet threads = pagingList.readItems.map { $0 }\n```\n</Tab>\n\n<Tab>\nFetching the oldest Threads (by creation date) in given Context:\n```swift\nvar startIndex:Int64 = 0\nvar pageSize:Int64 = 100\n        \nguard let pagingList = try? endpointSession?.threadApi?\n.listThreads(\n    from:contextId,\n    basedOn: .init(skip: startIndex, limit: pageSize, sortOrder: .asc)) else {return}\n\nlet threads =\npagingList.readItems.map { $0 }\n```\n</Tab>\n<Tab>\nYou can get info about a Thread using its `threadId`:\n```swift\nvar threadID = \"THREAD_ID\"\n\nguard let thread = try? endpointSession?.threadApi?\n    .getThread(threadID) else {return}\n\n```\n</Tab>\n</Tabs>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/swift/threads.mdx",
        "type": "mdx",
        "chunkIndex": 3,
        "headers": [
          "Getting Threads"
        ],
        "title": "Getting Threads",
        "codeBlocks": [
          "```swift\nvar startIndex:Int64 = 0\nvar pageSize:Int64 = 100\n\nguard let pagingList = try? endpointSession?.threadApi?\n.listThreads(\n    from:contextId,\n    basedOn: .init(skip: startIndex, limit: pageSize, sortOrder: .desc)) else {return}\n\nlet threads = pagingList.readItems.map { $0 }\n```",
          "```swift\nvar startIndex:Int64 = 0\nvar pageSize:Int64 = 100\n        \nguard let pagingList = try? endpointSession?.threadApi?\n.listThreads(\n    from:contextId,\n    basedOn: .init(skip: startIndex, limit: pageSize, sortOrder: .asc)) else {return}\n\nlet threads =\npagingList.readItems.map { $0 }\n```",
          "```swift\nvar threadID = \"THREAD_ID\"\n\nguard let thread = try? endpointSession?.threadApi?\n    .getThread(threadID) else {return}\n\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.856Z",
        "size": 1028
      }
    },
    {
      "pageContent": "## Managing Threads\n\n<Tabs groupId=\"variant\" items={[\"Renaming Thread\",\"Removing User\",\"Deleting Thread\"]}>\n<Tab>\nTo update a Thread you must always provide its current version, as well as:\n- list of users\n- list of managers\n- new private and public meta (even if it didn't change)\n- Thread's current version\n- `true` if update action should be forced\n\n```swift\nstruct ThreadPublicMeta:Codable{\n    let tags: [String]\n}\nvar threadID = \"THREAD_ID\"\n\n        \nlet threadPublicMeta = ThreadPublicMeta(tags: [\"TAG1\",\"TAG2\",\"TAG3\"])\nguard let publicMeta = try? JSONEncoder().encode(threadPublicMeta) else {return}\nguard let thread = try? endpointSession?.threadApi?\n    .getThread(threadID) else {return}\n\n//users list to be extracted from thread\nlet users = thread.users.map{\n    //Your application must provide a way,\n    //to get user's public key from their userId.\n    privmx.endpoint.core.UserWithPubKey(userId: $0, pubKey: \"PUB\")\n}\n//managers list to be extracted from thread\nlet managers = thread.managers.map{\n    //Your application must provide a way,\n    //to get user's public key from their userId.\n    privmx.endpoint.core.UserWithPubKey(userId: $0, pubKey: \"PUB\")\n}",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/swift/threads.mdx",
        "type": "mdx",
        "chunkIndex": 4,
        "headers": [
          "Managing Threads"
        ],
        "title": "Managing Threads",
        "lastModified": "2025-06-05T19:33:57.856Z",
        "size": 1174
      }
    },
    {
      "pageContent": "guard let newPrivateMeta = \"New thread name\".data(using: .utf8) else {return}\n\n_ = try? endpointSession?.threadApi?.updateThread(\n    threadID,\n    atVersion: thread.version,\n    replacingUsers: users,\n    replacingManagers: managers,\n    replacingPublicMeta: thread.publicMeta.getData() ?? Data(),\n    replacingPrivateMeta: newPrivateMeta,\n    force:false,\n    forceGenerateNewKey: false,\n    replacingPolicies: nil)\n\n```\n</Tab>\n\n<Tab>\nTo remove a user from a Thread you must provide:\n- list of all the users, without the user you want to remove\n- list of managers\n- new private and public meta (even if it didn't change)\n- Thread's current version\n- `true` if update action should be forced\n\n```swift\nstruct ThreadPublicMeta:Codable{\n    let tags: [String]\n}\nvar threadID = \"THREAD_ID\"\n        \nlet threadPublicMeta = ThreadPublicMeta(tags: [\"TAG1\",\"TAG2\",\"TAG3\"])\nguard let publicMeta = try? JSONEncoder().encode(threadPublicMeta) else {return}\nguard let thread = try? endpointSession?.threadApi?\n    .getThread(threadID) else {return}",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/swift/threads.mdx",
        "type": "mdx",
        "chunkIndex": 5,
        "codeBlocks": [
          "```\n</Tab>\n\n<Tab>\nTo remove a user from a Thread you must provide:\n- list of all the users, without the user you want to remove\n- list of managers\n- new private and public meta (even if it didn't change)\n- Thread's current version\n- `true` if update action should be forced\n\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.856Z",
        "size": 1038
      }
    },
    {
      "pageContent": "//users list to be extracted from thread\nlet users = thread.users.filter{\n    $0 != \"username-to-remove\"\n}.map{\n    //Your application must provide a way,\n    //to get user's public key from their userId.\n    privmx.endpoint.core.UserWithPubKey(userId: $0, pubKey: \"PUB\")\n}\n//managers list to be extracted from thread\nlet managers = thread.managers.map{\n    //Your application must provide a way,\n    //to get user's public key from their userId.\n    privmx.endpoint.core.UserWithPubKey(userId: $0, pubKey: \"PUB\")\n}\n\nguard let newPrivateMeta = \"New thread name\".data(using: .utf8) else {return}\n\n_ = try? endpointSession?.threadApi?.updateThread(\n    threadID,\n    atVersion: thread.version,\n    replacingUsers: users,\n    replacingManagers: managers,\n    replacingPublicMeta: thread.publicMeta.getData() ?? Data(),\n    replacingPrivateMeta: newPrivateMeta,\n    force:false,\n    forceGenerateNewKey: false,\n    replacingPolicies: nil)\n\n```\n</Tab>\n\n<Tab>\nThe snippet below deletes Thread and all its data. This action is irreversible.\n```swift\nvar threadID = \"THREAD_ID\"\ntry? endpointSession?.threadApi?.deleteThread(threadID)\n\n```\n</Tab>\n\n</Tabs>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/swift/threads.mdx",
        "type": "mdx",
        "chunkIndex": 6,
        "codeBlocks": [
          "```\n</Tab>\n\n<Tab>\nThe snippet below deletes Thread and all its data. This action is irreversible.\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.856Z",
        "size": 1146
      }
    },
    {
      "pageContent": "---\ntitle: API Reference\n---\n\n## PrivMX Endpoint API\nUse PrivMX Endpoint API to develop and manage client apps using any of our libraries and wrappers.\n\n[PrivMX Endpoint API Reference](../reference/start)\n\n\n## PrivMX Bridge API\nUse PrivMX Bridge API to manage your Bridge server instance, manage Solutions and Contexts, create containers and more.\n\n[PrivMX Bridge API Reference](https://bridge.privmx.dev/)",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/api-reference.mdx",
        "type": "mdx",
        "chunkIndex": 0,
        "headers": [
          "PrivMX Endpoint API",
          "PrivMX Bridge API"
        ],
        "title": "PrivMX Endpoint API",
        "lastModified": "2025-06-05T19:33:57.856Z",
        "size": 406
      }
    },
    {
      "pageContent": "---\ntitle: Architecture\n---",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/architecture.mdx",
        "type": "mdx",
        "chunkIndex": 0,
        "lastModified": "2025-06-05T19:33:57.857Z",
        "size": 27
      }
    },
    {
      "pageContent": "## PrivMX Bridge: Fundamentals\nWithin PrivMX Bridge there are fundamental concepts defining it's architecture:",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/architecture.mdx",
        "type": "mdx",
        "chunkIndex": 1,
        "headers": [
          "PrivMX Bridge: Fundamentals"
        ],
        "title": "PrivMX Bridge: Fundamentals",
        "lastModified": "2025-06-05T19:33:57.857Z",
        "size": 110
      }
    },
    {
      "pageContent": "### Solutions\n\nA Solution represents an isolated data environment, **designed for specific applications or IT solutions**.\nEach Solution is completely separate from the others, to ensure that data, user interactions, and [Contexts](#contexts) do not leak between them.\n\nA key architectural feature is that PrivMX Endpoint requires a specific Solution ID during connection. As a result, the Endpoint must first identify and request access\nto a particular Solution to interact with its internal resources.",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/architecture.mdx",
        "type": "mdx",
        "chunkIndex": 2,
        "headers": [
          "Solutions"
        ],
        "title": "Solutions",
        "lastModified": "2025-06-05T19:33:57.857Z",
        "size": 503
      }
    },
    {
      "pageContent": "#### Key Features\n\n- **Solution Separation:** All the data inside Solutions is strictly isolated. There is no automatic sharing or access between Solutions, even though they are hosted within the same PrivMX Bridge instance.\n\n- **Creation and Management:** Each new Solution is created with its own unique ID, which is provided while connecting to PrivMX Bridge.\n\n- **Security Model:** Each Solution operates with its own Contexts and keys, ensuring strong data integrity and separation.\nThe Solution itself does not manage or store information about its users; this is delegated to the Contexts.\n\n- **User Management:** Importantly, the Solution itself does not maintain a global user list.\nUsers are associated only with the specific Contexts. This enhances the security and privacy model by minimizing exposure to unnecessary information about other Contexts or users.\n\nIn summary, a Solution provides a compartmentalized space for managing resources relevant to specific IT environments or applications, ensuring clear and strict separation of data.",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/architecture.mdx",
        "type": "mdx",
        "chunkIndex": 3,
        "headers": [
          "Key Features"
        ],
        "title": "Key Features",
        "lastModified": "2025-06-05T19:33:57.857Z",
        "size": 1053
      }
    },
    {
      "pageContent": "### Contexts\n\nContexts provide another level of organization and are crucial for **user management** and **data access control**.\nEach Context represents a distinct space within a [Solution](#solutions), where users can be assigned specific roles and permissions using public keys. Every Context has to be assigned to a Solution.",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/architecture.mdx",
        "type": "mdx",
        "chunkIndex": 4,
        "headers": [
          "Contexts"
        ],
        "title": "Contexts",
        "lastModified": "2025-06-05T19:33:57.857Z",
        "size": 329
      }
    },
    {
      "pageContent": "#### Key Features\n\n- **Public Key Assignment**: a Context is defined by the developer (it could be referring to a specific app feature or area).\nUsers are associated with a Context by registering their public keys through the REST API provided by PrivMX Bridge.\n\n- **User Authentication and Authorization**: once users are assigned to a Context, they can authenticate themselves using their private keys.\nAuthentication involves the verification of a digital signature, which is generated by the user’s private key, and verified using their public key stored in the Context.\nIt is a seamless process for the developer, as it is fully handled by **PrivMX Endpoint**.\n\n- **Access Control**: user permissions within the Context are determined by Access Control Lists (ACL).\nThese permissions define the actions users can perform within the Context, such as creating, updating, or accessing resources like Threads, Stores, and Inboxes.\nThe ACL model ensures that each user has appropriate rights based on their role and the requirements of a particular Context.",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/architecture.mdx",
        "type": "mdx",
        "chunkIndex": 5,
        "headers": [
          "Key Features"
        ],
        "title": "Key Features",
        "lastModified": "2025-06-05T19:33:57.857Z",
        "size": 1057
      }
    },
    {
      "pageContent": "- **Resource Creation**: Within a Context, authorized users can create different types of encrypted tools:\n    - [Threads](./threads/overview): Secure chat spaces where users can exchange messages. Threads are end-to-end encrypted and accessible only for users with proper permissions.\n    - [Stores](./stores/overview): Encrypted containers for file storage, allowing non-sequential access and efficient file streaming.\n    - [Inboxes](./inboxes/overview): Containers used for one way communication with external users, useful for scenarios like receiving encrypted data from web forms.\n\nThe diagram below visualizes the structure and corelation between Contexts and Solutions:\n\n![Solutions and Contexts](/img/privmx-solution-context.png)",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/architecture.mdx",
        "type": "mdx",
        "chunkIndex": 6,
        "lastModified": "2025-06-05T19:33:57.857Z",
        "size": 739
      }
    },
    {
      "pageContent": "---\ntitle: Authorization\n---",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/authorization.mdx",
        "type": "mdx",
        "chunkIndex": 0,
        "lastModified": "2025-06-05T19:33:57.857Z",
        "size": 28
      }
    },
    {
      "pageContent": "## API Keys\nYou can access the API methods using API Keys. These keys have no time-to-live (TTL) but can be disabled or deleted.\nEach key is assigned a specific scope. You can create up to 10 API Keys by calling the method `manager/createApiKey`.\n\n:::info\n\nWhen you install PrivMX Bridge, you receive your first API Key with full API access.\n\n:::",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/authorization.mdx",
        "type": "mdx",
        "chunkIndex": 1,
        "headers": [
          "API Keys"
        ],
        "title": "API Keys",
        "lastModified": "2025-06-05T19:33:57.857Z",
        "size": 346
      }
    },
    {
      "pageContent": "An API Key can be created without public key:\n```shell\ncurl -X POST -H \"Content-Type: application/json\" \\\n    -H \"Authorization: one-of-our-authorization-methods\" \\\n    --data-binary '{\n        \"jsonrpc\": \"2.0\",\n        \"id\": 0,\n        \"method\": \"manager/createApiKey\",\n        \"params\": {\n            \"name\": \"My ApiKey\",\n            \"scope\": [\"apikey\", \"context\", \"solution\"],\n        }\n    }' \\\n    https://my-privmx-bridge-instance/api\n```\nOr with an ED25519 PEM-encoded public key:\n```shell\ncurl -X POST -H \"Content-Type: application/json\" \\\n    -H \"Authorization: one-of-our-authorization-methods\" \\\n    --data-binary '{\n        \"jsonrpc\": \"2.0\",\n        \"id\": 0,\n        \"method\": \"manager/createApiKey\",\n        \"params\": {\n            \"name\": \"My ApiKey\",\n            \"scope\": [\"apikey\", \"context\", \"solution\"],\n            \"publicKey\": \"-----BEGIN PUBLIC KEY-----\\nMCowBQYDK2VwAyEADsSTjY2wnm1iwWamIWwLTPVhtTIb8TVlI8tts3wkhkQ=\\n-----END PUBLIC KEY-----\",\n        }\n    }' \\\n    https://my-privmx-bridge-instance/api\n```\nYou will receive an ID and secret of API Key:\n```json\n{\n    \"jsonrpc\":\"2.0\",\n    \"id\":0,\n    \"result\": {\n        \"id\": \"hysd62jsd7823nasd03\",",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/authorization.mdx",
        "type": "mdx",
        "chunkIndex": 2,
        "codeBlocks": [
          "```shell\ncurl -X POST -H \"Content-Type: application/json\" \\\n    -H \"Authorization: one-of-our-authorization-methods\" \\\n    --data-binary '{\n        \"jsonrpc\": \"2.0\",\n        \"id\": 0,\n        \"method\": \"manager/createApiKey\",\n        \"params\": {\n            \"name\": \"My ApiKey\",\n            \"scope\": [\"apikey\", \"context\", \"solution\"],\n        }\n    }' \\\n    https://my-privmx-bridge-instance/api\n```",
          "```shell\ncurl -X POST -H \"Content-Type: application/json\" \\\n    -H \"Authorization: one-of-our-authorization-methods\" \\\n    --data-binary '{\n        \"jsonrpc\": \"2.0\",\n        \"id\": 0,\n        \"method\": \"manager/createApiKey\",\n        \"params\": {\n            \"name\": \"My ApiKey\",\n            \"scope\": [\"apikey\", \"context\", \"solution\"],\n            \"publicKey\": \"-----BEGIN PUBLIC KEY-----\\nMCowBQYDK2VwAyEADsSTjY2wnm1iwWamIWwLTPVhtTIb8TVlI8tts3wkhkQ=\\n-----END PUBLIC KEY-----\",\n        }\n    }' \\\n    https://my-privmx-bridge-instance/api\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.857Z",
        "size": 1171
      }
    },
    {
      "pageContent": "}' \\\n    https://my-privmx-bridge-instance/api\n```\nYou will receive an ID and secret of API Key:\n```json\n{\n    \"jsonrpc\":\"2.0\",\n    \"id\":0,\n    \"result\": {\n        \"id\": \"hysd62jsd7823nasd03\",\n        \"secret\": \"759a1d8edba555badf1216b0f381b94950141\"\n    }\n}",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/authorization.mdx",
        "type": "mdx",
        "chunkIndex": 3,
        "codeBlocks": [
          "```\nYou will receive an ID and secret of API Key:\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.857Z",
        "size": 258
      }
    },
    {
      "pageContent": "```\n\nYou can now authorize requests using your API Key in one of the following ways:",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/authorization.mdx",
        "type": "mdx",
        "chunkIndex": 4,
        "lastModified": "2025-06-05T19:33:57.857Z",
        "size": 84
      }
    },
    {
      "pageContent": "### Signatures\nYou can sign your request using your API Key.\n\n1. First, prepare the data to be signed:\n ```js\n apiKeyId = \"6XMc4VMf3q54YNarSn9CWUn4htStNu1ry9ajamemdo23sS1y21\";\n requestPayload = '{\"jsonrpc\":\"2.0\",\"id\":0,\"method\":\"solution/listSolutions\",\"params\":{}}';\n requestData = `POST\\n/api\\n${requestPayload}\\n`; // UPPERCASE(HTTP_METHOD()) + \"\\n\" + URI() + \"\\n\" + RequestBody + \"\\n\";\n timestamp = 1702555410352;\n nonce = \"3xUee4EA0gr8dg==\";\n dataToSign = `${timestamp};${nonce};${requestData}`;\n    ```\n\n2. Next, generate a signature corresponding to your API Key credentials:\n\n - HMAC signature:\n  ```\n  apiKeySecret = \"CspXxVtTyE3sf6jB7z4CSjxoymuS2H67ZjNDfovTu3i8\";\n  signature = BASE64(HMACSHA256(apiKeySecret, dataToSign).SUBARRAY(0, 20))\n        ```\n - If you provided a `publicKey` – ECC signature:\n  ```\n  privateKey = \"-----BEGIN PRIVATE KEY-----\\nMC4CAQAwBQYDK2VwBCIEIOBVFGaSFtfqbNvZWctFKg3k+I0T5YXRavpKAD9+BgCX\\n-----END PRIVATE KEY-----\";\n  signature = BASE64(SIGN(dataToSign, privateKey))\n        ```\n\n3. To sign a request, include the following in the `Authorization` header:\n\n ```js\n `pmx-hmac-sha256 ${apiKeyId};1;${timestamp};${nonce};${signature}`",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/authorization.mdx",
        "type": "mdx",
        "chunkIndex": 5,
        "headers": [
          "Signatures"
        ],
        "title": "Signatures",
        "codeBlocks": [
          "```js\n apiKeyId = \"6XMc4VMf3q54YNarSn9CWUn4htStNu1ry9ajamemdo23sS1y21\";\n requestPayload = '{\"jsonrpc\":\"2.0\",\"id\":0,\"method\":\"solution/listSolutions\",\"params\":{}}';\n requestData = `POST\\n/api\\n${requestPayload}\\n`; // UPPERCASE(HTTP_METHOD()) + \"\\n\" + URI() + \"\\n\" + RequestBody + \"\\n\";\n timestamp = 1702555410352;\n nonce = \"3xUee4EA0gr8dg==\";\n dataToSign = `${timestamp};${nonce};${requestData}`;\n    ```",
          "```\n  apiKeySecret = \"CspXxVtTyE3sf6jB7z4CSjxoymuS2H67ZjNDfovTu3i8\";\n  signature = BASE64(HMACSHA256(apiKeySecret, dataToSign).SUBARRAY(0, 20))\n        ```",
          "```\n  privateKey = \"-----BEGIN PRIVATE KEY-----\\nMC4CAQAwBQYDK2VwBCIEIOBVFGaSFtfqbNvZWctFKg3k+I0T5YXRavpKAD9+BgCX\\n-----END PRIVATE KEY-----\";\n  signature = BASE64(SIGN(dataToSign, privateKey))\n        ```"
        ],
        "lastModified": "2025-06-05T19:33:57.857Z",
        "size": 1170
      }
    },
    {
      "pageContent": "```\n\n3. To sign a request, include the following in the `Authorization` header:\n\n ```js\n `pmx-hmac-sha256 ${apiKeyId};1;${timestamp};${nonce};${signature}`\n    ```\n\n ```shell\n curl -X POST -H \"Content-Type: application/json\" \\\n     -H \"Authorization: pmx-hmac-sha256 6XMc4VMf3q54YNarSn9CWUn4htStNu1ry9ajamemdo23sS1y21;1;1702555410352;3xUee4EA0gr8dg;JN5llLladWZ+1rGu6yrkbIQzme0=\" \\\n     --data-binary '{\n         \"jsonrpc\": \"2.0\",\n         \"id\": 0,\n         \"method\": \"solution/listSolutions\",\n         \"params\": {}\n     }' \\\n     https://my-privmx-bridge-instance/api\n    ```",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/authorization.mdx",
        "type": "mdx",
        "chunkIndex": 6,
        "codeBlocks": [
          "```\n\n3. To sign a request, include the following in the `Authorization` header:\n\n ```",
          "```\n\n ```"
        ],
        "lastModified": "2025-06-05T19:33:57.857Z",
        "size": 575
      }
    },
    {
      "pageContent": "### API Key Credentials\nYou can authorize the request by placing your API Key credentials in the `Authorization` header:\n```js\nbasicAuthorization = BASE64(`${apiKeyId}:${apiKeySecret}`);\nauthorizationHeaderValue = `Basic ${basicAuthorization}`;\n```\n\n```shell\ncurl -X POST -H \"Content-Type: application/json\" \\\n    -H \"Authorization: Basic YWxpY2U6dGhlc2NlcmV0\" \\\n    --data-binary '{\n        \"jsonrpc\": \"2.0\",\n        \"id\": 0,\n        \"method\": \"solution/listSolutions\",\n        \"params\": {}\n    }' \\\n    https://my-privmx-bridge-instance/api\n```\n\n:::info\n\nNote that you cannot use this authorization method if your API Key includes a public key.\nIn such a case, only ECC signatures are available for this API Key.\n\n:::",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/authorization.mdx",
        "type": "mdx",
        "chunkIndex": 7,
        "headers": [
          "API Key Credentials"
        ],
        "title": "API Key Credentials",
        "codeBlocks": [
          "```js\nbasicAuthorization = BASE64(`${apiKeyId}:${apiKeySecret}`);\nauthorizationHeaderValue = `Basic ${basicAuthorization}`;\n```",
          "```shell\ncurl -X POST -H \"Content-Type: application/json\" \\\n    -H \"Authorization: Basic YWxpY2U6dGhlc2NlcmV0\" \\\n    --data-binary '{\n        \"jsonrpc\": \"2.0\",\n        \"id\": 0,\n        \"method\": \"solution/listSolutions\",\n        \"params\": {}\n    }' \\\n    https://my-privmx-bridge-instance/api\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.857Z",
        "size": 719
      }
    },
    {
      "pageContent": "### Access Tokens\nAccess tokens have a TTL but can be refreshed using refresh tokens. You can generate them by calling [manager/auth](https://bridge.privmx.dev/#manager-auth):\n\n```shell\ncurl -X POST \\\n    -H \"Content-Type: application/json\" \\\n    --data-binary '{\n        \"jsonrpc\": \"2.0\",\n        \"id\": 128,\n        \"method\": \"manager/auth\",\n        \"params\": {\n            \"scope\": [\"apikey\", \"solution\"],\n            \"grantType\": \"api_key_credentials\",\n            \"apiKeyId\": \"65ad8f6b2e4f4f1adb40bf68\",\n            \"apiKeySecret\": \"5ZTUQ7VBxoqRKn3pEyPjHeavXHVw7JcJF3MvAV43yfsR\"\n        }\n    }' \\\n    https://my-privmx-bridge-instance/api\n```\nYou will receive an `access_token` and a `refresh_token`:",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/authorization.mdx",
        "type": "mdx",
        "chunkIndex": 8,
        "headers": [
          "Access Tokens"
        ],
        "title": "Access Tokens",
        "codeBlocks": [
          "```shell\ncurl -X POST \\\n    -H \"Content-Type: application/json\" \\\n    --data-binary '{\n        \"jsonrpc\": \"2.0\",\n        \"id\": 128,\n        \"method\": \"manager/auth\",\n        \"params\": {\n            \"scope\": [\"apikey\", \"solution\"],\n            \"grantType\": \"api_key_credentials\",\n            \"apiKeyId\": \"65ad8f6b2e4f4f1adb40bf68\",\n            \"apiKeySecret\": \"5ZTUQ7VBxoqRKn3pEyPjHeavXHVw7JcJF3MvAV43yfsR\"\n        }\n    }' \\\n    https://my-privmx-bridge-instance/api\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.857Z",
        "size": 705
      }
    },
    {
      "pageContent": "```json\n{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 128,\n    \"result\": {\n        \"accessToken\": \"SXRzIGEgcmFuZG9tIHRleHQgZW5jb2RlZCBmb3IgdGhlIHRlc3RpbmcgcHVycG9zZSwgaWYgeW91IGRlY29kZWQgdGhpcyB0ZXh0LCB0cmVhdCBpcyBhcyBhIHNvcnQgb2YgZWFzdGVyIGVnZyA6KS4=\",\n        \"accessTokenExpiry\": 1726652150623,\n        \"refreshToken\": \"TG9yZW0gaXBzdW1Mb3JlbSBpcHN1bUxvcmVtIGlwc3VtTG9yZW0gaXBzdW1Mb3JlbSBpcHN1bUxvcmVtIGlwc3VtTG9yZW0gaXBzdW0=\",\n        \"refreshTokenExpiry\": 1726952150623,\n        \"tokenType\": \"Bearer\",\n        \"scope\": [\n            \"apiKey\",\n            \"solution\",\n            \"context\"\n        ]\n    }\n}\n```\nThe access token can be used to authorize your request by placing it in the `Authorization` header:",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/authorization.mdx",
        "type": "mdx",
        "chunkIndex": 9,
        "codeBlocks": [
          "```json\n{\n    \"jsonrpc\": \"2.0\",\n    \"id\": 128,\n    \"result\": {\n        \"accessToken\": \"SXRzIGEgcmFuZG9tIHRleHQgZW5jb2RlZCBmb3IgdGhlIHRlc3RpbmcgcHVycG9zZSwgaWYgeW91IGRlY29kZWQgdGhpcyB0ZXh0LCB0cmVhdCBpcyBhcyBhIHNvcnQgb2YgZWFzdGVyIGVnZyA6KS4=\",\n        \"accessTokenExpiry\": 1726652150623,\n        \"refreshToken\": \"TG9yZW0gaXBzdW1Mb3JlbSBpcHN1bUxvcmVtIGlwc3VtTG9yZW0gaXBzdW1Mb3JlbSBpcHN1bUxvcmVtIGlwc3VtTG9yZW0gaXBzdW0=\",\n        \"refreshTokenExpiry\": 1726952150623,\n        \"tokenType\": \"Bearer\",\n        \"scope\": [\n            \"apiKey\",\n            \"solution\",\n            \"context\"\n        ]\n    }\n}\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.857Z",
        "size": 702
      }
    },
    {
      "pageContent": "```shell\ncurl -X POST \\\n    -H \"Content-Type: application/json\" \\\n    -H \"Authorization: Bearer SXRzIGEgcmFuZG9tIHRleHQgZW5jb2RlZCBmb3IgdGhlIHRlc3RpbmcgcHVycG9zZSwgaWYgeW91IGRlY29kZWQgdGhpcyB0ZXh0LCB0cmVhdCBpcyBhcyBhIHNvcnQgb2YgZWFzdGVyIGVnZyA6KS4=\" \\\n    --data-binary '{\n        \"jsonrpc\": \"2.0\",\n        \"id\": 128,\n        \"method\": \"solution/listSolutions\",\n        \"params\": {}\n    }' \\\n    https://my-privmx-bridge-instance/api\n```\nAccess tokens can be refreshed using refresh tokens by calling the [manager/auth](https://bridge.privmx.dev/#manager-auth) method:\n\n```shell\ncurl -X POST \\\n    -H \"Content-Type: application/json\" \\\n    --data-binary '{\n        \"jsonrpc\": \"2.0\",\n        \"id\": 128,\n        \"method\": \"manager/auth\",\n        \"params\": {\n            \"grantType\": \"refresh_token\",\n            \"refreshToken\": \"TG9yZW0gaXBzdW1Mb3JlbSBpcHN1bUxvcmVtIGlwc3VtTG9yZW0gaXBzdW0=\",\n        }\n    }' \\\n    https://my-privmx-bridge-instance/api\n```\nIn response, you will receive a new pair of tokens, and the old pair will be revoked.",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/authorization.mdx",
        "type": "mdx",
        "chunkIndex": 10,
        "codeBlocks": [
          "```shell\ncurl -X POST \\\n    -H \"Content-Type: application/json\" \\\n    -H \"Authorization: Bearer SXRzIGEgcmFuZG9tIHRleHQgZW5jb2RlZCBmb3IgdGhlIHRlc3RpbmcgcHVycG9zZSwgaWYgeW91IGRlY29kZWQgdGhpcyB0ZXh0LCB0cmVhdCBpcyBhcyBhIHNvcnQgb2YgZWFzdGVyIGVnZyA6KS4=\" \\\n    --data-binary '{\n        \"jsonrpc\": \"2.0\",\n        \"id\": 128,\n        \"method\": \"solution/listSolutions\",\n        \"params\": {}\n    }' \\\n    https://my-privmx-bridge-instance/api\n```",
          "```shell\ncurl -X POST \\\n    -H \"Content-Type: application/json\" \\\n    --data-binary '{\n        \"jsonrpc\": \"2.0\",\n        \"id\": 128,\n        \"method\": \"manager/auth\",\n        \"params\": {\n            \"grantType\": \"refresh_token\",\n            \"refreshToken\": \"TG9yZW0gaXBzdW1Mb3JlbSBpcHN1bUxvcmVtIGlwc3VtTG9yZW0gaXBzdW0=\",\n        }\n    }' \\\n    https://my-privmx-bridge-instance/api\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.857Z",
        "size": 1040
      }
    },
    {
      "pageContent": "### API Scopes\nWhen requesting an access token, you can specify the scope, which defines the level of granted access.\nHere's a breakdown of the available scopes:",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/authorization.mdx",
        "type": "mdx",
        "chunkIndex": 11,
        "headers": [
          "API Scopes"
        ],
        "title": "API Scopes",
        "lastModified": "2025-06-05T19:33:57.857Z",
        "size": 161
      }
    },
    {
      "pageContent": "| **Scope**        | **Description**                                                                                                                                                                                                                                                                                                                                                             |\n|--------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| `session:NAME` | Creates a new session with the provided name, generating tokens bound to that session. Access is granted for the session's lifetime. A user can have up to 16 sessions; when this limit is reached, the oldest session is removed. |",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/authorization.mdx",
        "type": "mdx",
        "chunkIndex": 12,
        "lastModified": "2025-06-05T19:33:57.857Z",
        "size": 1013
      }
    },
    {
      "pageContent": "| `ipAddr:ADDR`  | Restricts the token to connections from a specific IPv4 address (ADDR).                                                                                                                                                                                                                                                                                                                                                                      |\n|`expiresIn:NUMBER` | Access token will expire after `NUMBER` of milliseconds. Max value is TTL of the refresh token. |\n| `solution` | Restricts the token to Solution API scope. |\n| `context` | Restricts the token to Context API scope. |\n|`thread`\t|Restricts the token to Thread API scope.|\n|`store`\t|Restricts the token to Store API scope.|\n|`inbox`\t|Restricts the token to Inbox API scope.|\n|`stream`\t|Restricts the token to Stream API scope.|\n|`solution:SOLUTION_ID`\t|Restricts the token to manage Contexts only under given `SOLUTION_ID`.|\n|`solution:*`\t|Restricts the token to manage all Contexts.|",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/authorization.mdx",
        "type": "mdx",
        "chunkIndex": 13,
        "lastModified": "2025-06-05T19:33:57.857Z",
        "size": 1052
      }
    },
    {
      "pageContent": "These scopes allow fine-grained control over what actions can be performed with the generated tokens,\nmaking it easier to manage permissions across different parts of the system.",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/authorization.mdx",
        "type": "mdx",
        "chunkIndex": 14,
        "lastModified": "2025-06-05T19:33:57.857Z",
        "size": 178
      }
    },
    {
      "pageContent": "---\ntitle: Certificates\n---\n\nEach wrapper uses SSL connection for all the communication between PrivMX Endpoint and PrivMX Bridge.\nSince Bridge is locally installed by the developer, it's necessary to provide certificates for this connection.\n\nYou can use proper function in each language for setting the certificates:\n\n<Tabs groupId=\"variant\" items={[\"Swift\",\"Kotlin\"]}>\n<Tab >\n```swift\nvar endpointContainer: PrivMXEndpointContainer = PrivMXEndpointContainer()\n\t\t\nguard let pathToCerts = FileManager.default\n    .urls(for: .documentDirectory, in: .userDomainMask)\n    .first?.appendingPathComponent(\"cert.pem\").path()\nelse {return}\n\ntry? endpointContainer.setCertsPath(to: pathToCerts)\n\n```\n</Tab>\n<Tab >\n```kotlin\nval endpointContainer = PrivmxEndpointContainer()\nendpointContainer.setCertsPath(\"YOUR-PATH-TO-CERTS-FILE.pem\")\n```\n</Tab>\n</Tabs>\n\n## Source of Certificates\n\nIf you use properly signed certificates issued by a trusted CA, you can provide them for the Endpoint. For example CA Certificates from Mozilla:\n\n- [Mozilla's Included Certificates](https://wiki.mozilla.org/CA/Included_Certificates)\n- [CURL - CA certificates extracted from Mozilla](https://curl.se/docs/caextract.html)",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/certificates.mdx",
        "type": "mdx",
        "chunkIndex": 0,
        "headers": [
          "Source of Certificates"
        ],
        "title": "Source of Certificates",
        "codeBlocks": [
          "```swift\nvar endpointContainer: PrivMXEndpointContainer = PrivMXEndpointContainer()\n\t\t\nguard let pathToCerts = FileManager.default\n    .urls(for: .documentDirectory, in: .userDomainMask)\n    .first?.appendingPathComponent(\"cert.pem\").path()\nelse {return}\n\ntry? endpointContainer.setCertsPath(to: pathToCerts)\n\n```",
          "```kotlin\nval endpointContainer = PrivmxEndpointContainer()\nendpointContainer.setCertsPath(\"YOUR-PATH-TO-CERTS-FILE.pem\")\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.858Z",
        "size": 1195
      }
    },
    {
      "pageContent": "## Custom Certificates\n\nIf your Bridge has custom signed certificates, provide them accordingly.\n\n\n<Callout type={\"info\"} title={\"On the Web\"}>\n    If you use PrivMX Endpoint in web environment with custom certificates, you should add them as trusted to your system.\n</Callout>\n\n## Using PrivMX Endpoint with a Non-Secure Bridge Installation\n\nFor development purposes, the Bridge can be installed locally and accessed by a non-secure HTTP connection.\nIn such a case, you can omit adding certificates to PrivMX Endpoint and configure your app properly by editing the `Info.plist` file:\n\n```\nApp Transport Security Settings > Allow Arbitrary Loads > YES\n```",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/certificates.mdx",
        "type": "mdx",
        "chunkIndex": 1,
        "headers": [
          "Custom Certificates",
          "Using PrivMX Endpoint with a Non-Secure Bridge Installation"
        ],
        "title": "Custom Certificates",
        "codeBlocks": [
          "```\nApp Transport Security Settings > Allow Arbitrary Loads > YES\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.858Z",
        "size": 655
      }
    },
    {
      "pageContent": "---\ntitle: Encryption\n---\n\nPrivMX uses **elliptic curve cryptography** (ECC), a public-key cryptography technique that leverages the mathematical properties of elliptic curves. ECC enables secure cryptographic operations such as key exchange, digital signatures, and encryption.\n\nHere are the general principles of elliptic curves:\n\n- ECC relies on elliptic curves as the fundamental mathematical technique. These curves are defined by the equation: `y^2=x^3+ax+b`, where `a` and `b` are constant parameters. Elliptic curves have unique properties that make them suitable for cryptography. ECC is a core component of the digital signature system used in Bitcoin.\n\n- ECC security is based on the computational complexity of discrete logarithms on elliptic curves (known as the Elliptic Curve Discrete Logarithm Problem, ECDLP). The digital signature algorithm using ECC is called ECDSA. ECC offers comparable security to the RSA algorithm but with significantly shorter key lengths.\n\n- ECC is an attractive algorithm for applications that require high-performance asymmetric encryption. It is particularly useful in resource-constrained computational environments, such as microprocessor cards.",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/encryption.mdx",
        "type": "mdx",
        "chunkIndex": 0,
        "lastModified": "2025-06-05T19:33:57.858Z",
        "size": 1193
      }
    },
    {
      "pageContent": "PrivMX uses a 256-bit ECC key, and keys required for private or public key input should be provided in Wallet Import Format (WIF).\n\nLearn more about [keys and how to generate them](../start/generating-keys).",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/encryption.mdx",
        "type": "mdx",
        "chunkIndex": 1,
        "lastModified": "2025-06-05T19:33:57.858Z",
        "size": 207
      }
    },
    {
      "pageContent": "## User's Keys\n\nPrivMX Endpoint uses a private-public key pair to encrypt data before sending it to PrivMX Bridge.\n\n**Private key** is a string of characters accessible only to its owner,\neither explicitly e.g. stored in a password manager, or discreetly e.g. produced deterministically from a password.\n\n**Public key** is derived from the private key, it is publicly available to all members of the data exchange.\nIn PrivMX, the Bridge stores public keys.",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/encryption.mdx",
        "type": "mdx",
        "chunkIndex": 2,
        "headers": [
          "User's Keys"
        ],
        "title": "User's Keys",
        "lastModified": "2025-06-05T19:33:57.858Z",
        "size": 456
      }
    },
    {
      "pageContent": "## Detailed Encryption Scenario\n\nIn the Bridge, end users can create Containers such as [Threads](./threads/overview), [Stores](./stores/overview), and [Inboxes](./inboxes/overview).\nOnly an end user can create a Container, by providing a set of public keys for the users who should have access to the Container.\nA symmetric key for the Container (Container Encryption Key) is then **generated by the Container author** and securely stored on the server, encrypted using public keys of **users assigned to the Container**.\nThis ensures that only the authorized users have access to the Container's Encryption Key. **Unencrypted keys never leave User Endpoints.**\n\nWhen accessing a Container, the encrypted Container Encryption Key is sent to each user based on their assignment to the Container. Only the users with proper Private Keys can decrypt this key.\nUsing the decrypted key, messages are encrypted and signed with the users’ Private Keys before being sent to the Bridge.\n\nThis process is handled by the PrivMX Endpoint Library and is completely seamless for PrivMX Endpoint users.\n\nHere's a visual reference for the encryption process in PrivMX:\n\n![encryption](/img/privmx-encryption.svg)",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/encryption.mdx",
        "type": "mdx",
        "chunkIndex": 3,
        "headers": [
          "Detailed Encryption Scenario"
        ],
        "title": "Detailed Encryption Scenario",
        "lastModified": "2025-06-05T19:33:57.858Z",
        "size": 1196
      }
    },
    {
      "pageContent": "---\ntitle: Events\n---\n\nThis document provides a comprehensive guide on working with events in PrivMX, covering how to set up connections and event queues, listen for specific types of events like Thread or Store actions, and understand the structure of these events.",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/events.mdx",
        "type": "mdx",
        "chunkIndex": 0,
        "lastModified": "2025-06-05T19:33:57.858Z",
        "size": 266
      }
    },
    {
      "pageContent": "## Working with Events\n\nTo start working with Events, you must:\n\n<div className={'fd-steps'}>\n   <div className={'fd-step'}>\n       Create connection to PrivMX Bridge instance.\n       <Tabs groupId={'lang'} items={[\"JavaScript\"]}>\n           <Tab>\n               ```ts\n               const connection = await Endpoint.connect(PRIVATE_KEY,SOLUTION_ID,BRIDGE_URL)\n               ```\n           </Tab>\n       </Tabs>\n   </div>\n    <div className={'fd-step'}>\n        Create Event Queue.\n        <Tabs groupId={'lang'} items={[\"JavaScript\"]}>\n            <Tab>\n                ```ts\n                const eventQueue = await Endpoint.getEventQueue()\n                ```\n            </Tab>\n        </Tabs>\n    </div>\n    <div className={'fd-step'}>\n        Start listening for events using `waitEvent`.\n        `EventQueue` provides `waitEvent` method that blocks main browser's thread.\n        To avoid freezing the entire app:\n\n        <Tabs groupId={'lang'} items={[\"JavaScript\"]}>\n            <Tab>\n                ```js\n                //previous code\n                const eventQueue = await EndpointFactory.getEventQueue();",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/events.mdx",
        "type": "mdx",
        "chunkIndex": 1,
        "headers": [
          "Working with Events"
        ],
        "title": "Working with Events",
        "codeBlocks": [
          "```ts\n               const connection = await Endpoint.connect(PRIVATE_KEY,SOLUTION_ID,BRIDGE_URL)\n               ```",
          "```ts\n                const eventQueue = await Endpoint.getEventQueue()\n                ```"
        ],
        "lastModified": "2025-06-05T19:33:57.858Z",
        "size": 1124
      }
    },
    {
      "pageContent": "//map containing pairs of event type - list of callbacks\n                const callbacks = new Map()\n\n                //Wait event is blocking and must be executed in promise loop,\n                //to prevent blocking the main thread.\n                let listenForEventsPromise = null;\n                function listenForEvents(queue) {\n                    if (!listenForEventsPromise) {\n                        listenForEventsPromise = queue.waitEvent();\n                        listenForEventsPromise.then(result => {\n                            if(callbacks.has(result.type)){\n                                const eventCallbacks = callbacks.get(result.type)\n                                eventCallbacks.forEach((cb) => cb(result))\n                            }\n                            listenForEventsPromise = null;\n                            listenForEvents(queue);\n                        })\n                    }\n                }",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/events.mdx",
        "type": "mdx",
        "chunkIndex": 2,
        "lastModified": "2025-06-05T19:33:57.858Z",
        "size": 944
      }
    },
    {
      "pageContent": "listenForEvents(eventQueue);\n                ```\n            </Tab>\n        </Tabs>\n    </div>\n    <div className={'fd-step'}>\n        Subscribe to channels.\n        <Tabs groupId={'lang'} items={[\"JavaScript\"]}>\n            <Tab>\n                ```js\n                //using connection from first step\n                const threadApi = await Endpoint.createThreadApi(connection)\n                await threadApi.subscribeForThreadEvents()\n                ```\n            </Tab>\n        </Tabs>\n    </div>\n    <div className={'fd-step'}>\n        Add callback methods. \\\n        Add a list with callback methods that will be called on event with matching event type.\n        In this example it's `threadCreated`:\n        <Tabs groupId={'lang'} items={[\"JavaScript\"]}>\n            <Tab>\n                ```js\n                //previous code\n                callbacks.set(\"threadCreated\",[(payload) => {console.log(payload)}])\n                ```\n            </Tab>\n        </Tabs>\n    </div>\n\n</div>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/events.mdx",
        "type": "mdx",
        "chunkIndex": 3,
        "codeBlocks": [
          "```\n            </Tab>\n        </Tabs>\n    </div>\n    <div className={'fd-step'}>\n        Subscribe to channels.\n        <Tabs groupId={'lang'} items={[\"JavaScript\"]}>\n            <Tab>\n                ```",
          "```\n            </Tab>\n        </Tabs>\n    </div>\n    <div className={'fd-step'}>\n        Add callback methods. \\\n        Add a list with callback methods that will be called on event with matching event type.\n        In this example it's `threadCreated`:\n        <Tabs groupId={'lang'} items={[\"JavaScript\"]}>\n            <Tab>\n                ```"
        ],
        "lastModified": "2025-06-05T19:33:57.858Z",
        "size": 997
      }
    },
    {
      "pageContent": "## Channels\n\nBefore receiving Events, your application must first subscribe to a group of events. Internally those groups\nare called \"Channels\".\n\nChannels can be divided into two types:\n\n- **Container related**: Those channels notify about changes related to a given Container type. After subscribing to these channels, you\n  will receive events when someone creates, updates, or deletes a Container with matching type in your Solution.\n- **Item related**: Those channels are related to a specific Container. When subscribed, you will receive events related\n  to item changes in a given Container.\n\nPrivMX Endpoint provides subscribing methods for each Container.",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/events.mdx",
        "type": "mdx",
        "chunkIndex": 4,
        "headers": [
          "Channels"
        ],
        "title": "Channels",
        "lastModified": "2025-06-05T19:33:57.858Z",
        "size": 663
      }
    },
    {
      "pageContent": "## Types of Events\n\nEvery change in PrivMX corresponds to a specific event type. Event names follow common schema:\n\nExample Container events:\n\n- `Created` - triggers when a new Container is created in your Context\n- `Deleted` - triggers when a Container is deleted from your Context\n- `Updated` - triggers when a Container is updated in your Context\n- `Stats Changed` - triggers when a Container is updated in your Context\n\nExample Item events:\n\n- `Created` - triggers when an item is sent to a Container\n- `Deleted` - triggers when an item is deleted from a Container\n- `Updated` - triggers when an item is deleted from a Container\n\n### Examples\n\n- Inboxes have an `inboxEntryCreated` event triggered when an entry is sent to an Inbox.\n- Stores have a `storeCreated` event triggered when new Store is created in Context.\n\nPrivMX Endpoint provides methods in each Container's API for subscribing to these channels.\nYou can refer to platform-specific documentation on how to subscribe for necessary channels.",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/events.mdx",
        "type": "mdx",
        "chunkIndex": 5,
        "headers": [
          "Types of Events",
          "Examples"
        ],
        "title": "Types of Events",
        "lastModified": "2025-06-05T19:33:57.858Z",
        "size": 1007
      }
    },
    {
      "pageContent": "## Structure\n\nThe main strength of events is that they contain data related to the occurred changes.\nEach Event related to a Container has the following format:\n\n| **Field**    | **Type** | **Description**                                                       |\n| ------------ | -------- | --------------------------------------------------------------------- |\n| channel      | `string` | Name of channel related to this event                                 |\n| connectionId | `string` | ID of one of your current connections                                 |\n| type         | `string` | Type of received event e.g., `\"storeCreated\"` or `\"threadNewMessage\"` |\n| data         | `T`      | `T` depends on `type` of event and contains new/updated data          |\n\nBecause events are triggered after every change, you don't have to constantly refetch all data.\nA good practice is to fetch data on initial user entry and only modify your existing data based on received event.",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/events.mdx",
        "type": "mdx",
        "chunkIndex": 6,
        "headers": [
          "Structure"
        ],
        "title": "Structure",
        "lastModified": "2025-06-05T19:33:57.858Z",
        "size": 973
      }
    },
    {
      "pageContent": "## Next Steps\n\nFor more details, refer to each Container's specific documentation:\n\n- Threads - [Listening for Changes](../start/threads/listening-for-changes)\n- Stores - [Instant Updating](../start/stores/instant-updating)\n- Inboxes - [Inbox Updates](../start/inboxes/inbox-updates)",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/events.mdx",
        "type": "mdx",
        "chunkIndex": 7,
        "headers": [
          "Next Steps"
        ],
        "title": "Next Steps",
        "lastModified": "2025-06-05T19:33:57.858Z",
        "size": 283
      }
    },
    {
      "pageContent": "---\ntitle: Features\n---\n\n## What is PrivMX?\n\nPrivMX is a comprehensive platform designed for developers, enabling seamless integration of end-to-end encrypted communication into any application. It also provides the foundation for building new, encryption-focused communication apps.\n\nPrivMX consists of two key components:\n\n- [PrivMX Bridge](../start/installation) – server deployed within your infrastructure, ensuring secure communication.\n- [PrivMX Endpoint](#privmx-endpoint) – a set of libraries and wrappers ready to be configured and used with various programming languages and frameworks.\n\n### Application Server\n\nPrivMX only provides containers for implementing features, for example Threads, Stores, etc. To create and manage user accounts, you need a basic Application Server, connected to your app built with PrivMX. PrivMX identifies users using their public keys, but your Application Server has to handle them and store information about user profiles etc.",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/features.mdx",
        "type": "mdx",
        "chunkIndex": 0,
        "headers": [
          "What is PrivMX?",
          "Application Server"
        ],
        "title": "What is PrivMX?",
        "lastModified": "2025-06-05T19:33:57.859Z",
        "size": 972
      }
    },
    {
      "pageContent": "## PrivMX Bridge\n\nBridge is a **zero-knowledge server** that intermediates in the **transfer of encrypted data** and notifications\nbetween PrivMX Endpoints and **stores encrypted data** for containers: Threads, Stores, and Inboxes.\n\n[More information and Bridge installation guides](../start/installation)\n\n### Solution\n\nA Solution represents an isolated data environment, **designed for specific applications or IT solutions**.\n\n[Learn more about Solutions in Architecture](./architecture)\n\n### Context\n\nEach Context represents a distinct space within a Solution, where users can be assigned specific roles and permissions\nusing public keys.\n\n[Learn more about Contexts in Architecture](./architecture)\n\n### API keys\n\nYou can use API keys to receive Access Tokens required for authorizing requests between your application backend and PrivMX Bridge.\n\n[More information about API keys and authorization in PrivMX Bridge](../start/authorization)",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/features.mdx",
        "type": "mdx",
        "chunkIndex": 1,
        "headers": [
          "PrivMX Bridge",
          "Solution",
          "Context",
          "API keys"
        ],
        "title": "PrivMX Bridge",
        "lastModified": "2025-06-05T19:33:57.859Z",
        "size": 944
      }
    },
    {
      "pageContent": "## PrivMX Endpoint\n\nPrivMX Endpoint is a set of libraries and wrappers ready to be configured and used with various programming languages and frameworks. Its core is a modular library written in C++.\n\nLearn more about how to use PrivMX Endpoint in your favorite language:\n\n<Cards>\n  <Card\n    href={\"../cpp/introduction\"}\n    title={\"C++\"}\n    icon={<Icon icon={\"cpp\"} />}\n  />\n  <Card\n    href={\"../js/introduction\"}\n    title={\"JavaScript\"}\n    icon={<Icon icon={\"js\"} />}\n  />\n  <Card\n    href={\"../java/getting-started\"}\n    title={\"Java/Kotlin\"}\n    icon={<Icon icon={\"java\"} />}\n  />\n    <Card\n    href={\"../kotlin/introduction\"}\n    title={\"Kotlin\"}\n    icon={<Icon icon={\"kotlin\"} />}\n  />\n  <Card\n    href={\"../swift/getting-started\"}\n    title={\"Swift\"}\n    icon={<Icon icon={\"swift\"} />}\n  />\n    <Card\n    href={\"../csharp/introduction\"}\n    title={\"C#\"}\n    icon={<Icon icon={\"csharp\"} />}\n  />\n</Cards>\n\n### User's Keys\n\nPrivMX Endpoint uses a private-public key pair to encrypt data before sending it to PrivMX Bridge.\n\n[More information about encryption in PrivMX Endpoint](./encryption)",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/features.mdx",
        "type": "mdx",
        "chunkIndex": 2,
        "headers": [
          "PrivMX Endpoint",
          "User's Keys"
        ],
        "title": "PrivMX Endpoint",
        "lastModified": "2025-06-05T19:33:57.859Z",
        "size": 1103
      }
    },
    {
      "pageContent": "## Containers\n\n### Threads\n\nThread container is a structured communication tool used for **message based communication**.\n\nUsers create Threads to organize topic-specific conversations where they can securely **exchange encrypted messages** with designated\nparticipants. All the active users are **notified** right away when a new message arrives or anything within the Thread changes.\n\n[Learn more about working with Threads](../start/threads/overview)\n\n### Stores\n\nStore container is a structured data storage and communication tool used for **file exchange and management**.\n\nUsers create Stores to organize topic-specific spaces where they can securely **upload encrypted files** and share them with designated\nparticipants. All the active users are **notified** right away when a file is uploaded or modified. Stores can be integrated with Threads.\n\n[Learn more about working with Stores](../start/stores/overview)",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/features.mdx",
        "type": "mdx",
        "chunkIndex": 3,
        "headers": [
          "Containers",
          "Threads",
          "Stores"
        ],
        "title": "Containers",
        "lastModified": "2025-06-05T19:33:57.859Z",
        "size": 919
      }
    },
    {
      "pageContent": "### Inboxes\n\nInbox container is a special kind of communication tool used for **one way communication with external users**.\n\nAn authorized PrivMX user can create an Inbox, configure its snippet and place it in a desired place (like a webpage or an app).\n**Anonymous, unregistered users can send data to the Inbox**. This procedure uses Inbox Public Key, which allows to write data to an Inbox.\nOne time access assures that the writer has no possibility of reading the data once it's sent.\n\n[Learn more about working with Inboxes](../start/inboxes/overview)",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/features.mdx",
        "type": "mdx",
        "chunkIndex": 4,
        "headers": [
          "Inboxes"
        ],
        "title": "Inboxes",
        "lastModified": "2025-06-05T19:33:57.859Z",
        "size": 557
      }
    },
    {
      "pageContent": "---\ntitle: Generating Keys\nhide_table_of_contents: false\n---\n\nPrivMX Endpoint supports **Wallet Import Format (WIF)** keys by default and offers tools such as converting PEM keys (OpenSSL) and deterministic private key generation from any text, such as a user's password or a given file.\n\n:::warning\n\n**Private keys should always be known only to their owners.**\nGenerate them client-side and don't save them anywhere.\nThis practice ensures that only the rightful owner has access to their private keys, significantly reducing the risk of unauthorized access or theft.\n\n:::\n\n[Find out more about keys in Encryption](../start/encryption#users-keys)",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/generating-keys.mdx",
        "type": "mdx",
        "chunkIndex": 0,
        "lastModified": "2025-06-05T19:33:57.859Z",
        "size": 647
      }
    },
    {
      "pageContent": "### Generating Keys for PrivMX\n<Tabs items={[\"With PrivMX Bridge\",\"Python\",\"C++\"]}>\n    <Tab>\n        The PrivMX Bridge Docker repo contains helper scripts for generating keys.\n        Clone it by running following script in your favorite terminal\n       ```shell\n        git clone https://github.com/simplito/privmx-bridge-docker\n       ```\n        and go to created `\"privmx-bridge-docker\"` folder.\n\n        Scripts require active running PrivMX Bridge docker container. You can run it using:\n        ```shell\n        ./setup.sh\n        ```\n        or if you already started created one earlier:\n\n        ```shell\n        docker compose -f docker-compose.yaml up",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/generating-keys.mdx",
        "type": "mdx",
        "chunkIndex": 1,
        "headers": [
          "Generating Keys for PrivMX"
        ],
        "title": "Generating Keys for PrivMX",
        "codeBlocks": [
          "```shell\n        git clone https://github.com/simplito/privmx-bridge-docker\n       ```",
          "```shell\n        ./setup.sh\n        ```"
        ],
        "lastModified": "2025-06-05T19:33:57.859Z",
        "size": 664
      }
    },
    {
      "pageContent": "```\n\n        You can generate Endpoint compatible key pair using following script.\n        ```shell\n        ./genKeyPair.sh\n        ```\n        Generated keys will be displayed in your terminal. They aren't stored anywhere, so make sure to copy them.\n\n        In Windows environment you must use bash compatible terminal like WSL or Git Bash.\n\n        You must register **public key** in PrivMX Bridge first, before using it's matching **private key** in PrivMX Endpoint.\n        To do this you can use [`context/addUserToContext`](https://bridge.privmx.dev/#context-addusertocontext) PrivMX Bridge method.\n\n    </Tab>\n    <Tab  >\n\n        Example snippet for generating a pair of keys in Python:\n\n    ```python\n    import hashlib\n    import base58\n    import ecdsa\n    import os\n\n\n    def generate_wif_public_key(hex_public_key):\n        extended_key = bytes.fromhex(hex_public_key)\n        checksum = hashlib.sha256(hashlib.sha256(extended_key).digest()).digest()[:4]\n        wif_key = extended_key + checksum\n        wif_encoded = base58.b58encode(wif_key).decode('utf-8')\n        return wif_encoded",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/generating-keys.mdx",
        "type": "mdx",
        "chunkIndex": 2,
        "codeBlocks": [
          "```\n\n        You can generate Endpoint compatible key pair using following script.\n        ```",
          "```\n        Generated keys will be displayed in your terminal. They aren't stored anywhere, so make sure to copy them.\n\n        In Windows environment you must use bash compatible terminal like WSL or Git Bash.\n\n        You must register **public key** in PrivMX Bridge first, before using it's matching **private key** in PrivMX Endpoint.\n        To do this you can use [`context/addUserToContext`](https://bridge.privmx.dev/#context-addusertocontext) PrivMX Bridge method.\n\n    </Tab>\n    <Tab  >\n\n        Example snippet for generating a pair of keys in Python:\n\n    ```"
        ],
        "lastModified": "2025-06-05T19:33:57.859Z",
        "size": 1102
      }
    },
    {
      "pageContent": "def generate_wif_private_key(hex_private_key, testnet=False):\n        prefix_byte = b'\\xef' if testnet else b'\\x80'\n        extended_key = prefix_byte + bytes.fromhex(hex_private_key)\n        checksum = hashlib.sha256(hashlib.sha256(extended_key).digest()).digest()[:4]\n        wif_key = extended_key + checksum\n        wif_encoded = base58.b58encode(wif_key).decode('utf-8')\n        return wif_encoded\n\n    def generate_public_key(hex_private_key):\n        sk = ecdsa.SigningKey.from_string(bytes.fromhex(hex_private_key), curve=ecdsa.SECP256k1)\n        vk = sk.get_verifying_key()\n        public_key = vk.to_string(\"compressed\").hex()\n        return public_key\n\n\n    print(f\"Generating 32bit hex with openssl\")\n    output = os.popen(\"openssl rand -hex 32\").read()\n    hex_private_key = output.rstrip()",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/generating-keys.mdx",
        "type": "mdx",
        "chunkIndex": 3,
        "lastModified": "2025-06-05T19:33:57.859Z",
        "size": 803
      }
    },
    {
      "pageContent": "print(f\"Generating 32bit hex with openssl\")\n    output = os.popen(\"openssl rand -hex 32\").read()\n    hex_private_key = output.rstrip()\n\n\n    print(f\"Private Key: {hex_private_key}\")\n    wif_private_key = generate_wif_private_key(hex_private_key)\n    hex_public_key = generate_public_key(hex_private_key)\n    wif_public_key = generate_wif_public_key(hex_public_key)\n    print(f\"Private Key in WIF format: {wif_private_key}\")\n    print(f\"Public Key: {hex_public_key}\")\n    print(f\"Public Key in WIF format: {wif_public_key}\")",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/generating-keys.mdx",
        "type": "mdx",
        "chunkIndex": 4,
        "lastModified": "2025-06-05T19:33:57.859Z",
        "size": 523
      }
    },
    {
      "pageContent": "```\n\n        How to run:\n\n    ```python\n    pup install base58\n    pip install ends\n    python generate.py\n    ```\n\n    </Tab>\n    <Tab >\n        Example snippet for generating a pair of keys in C++, using PrivMX Endpoint Library:\n\n        ```cpp\n        #include <optional>\n        #include <iostream>\n        #include <privmx/endpoint/crypto/CryptoApi.hpp>\n\n        using namespace privmx::endpoint::crypto;\n        int main() {\n            auto cryptoApi {CryptoApi::create()};\n            auto priv {cryptoApi.generatePrivateKey(std::nullopt)};\n            auto pub {cryptoApi.derivePublicKey(priv)};\n            std::cout << \"Generated private key: \" << priv << std::endl\n            << \"Generated public key: \" << pub << std::endl;\n            return 0;\n        }\n        ```\n        A full code example can be found on [Simplito's GitHub](https://github.com/simplito/privmx-endpoint/tree/main/examples/CryptoSample).\n    </Tab>\n</Tabs>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/generating-keys.mdx",
        "type": "mdx",
        "chunkIndex": 5,
        "codeBlocks": [
          "```\n\n        How to run:\n\n    ```",
          "```\n\n    </Tab>\n    <Tab >\n        Example snippet for generating a pair of keys in C++, using PrivMX Endpoint Library:\n\n        ```"
        ],
        "lastModified": "2025-06-05T19:33:57.859Z",
        "size": 942
      }
    },
    {
      "pageContent": "---\ntitle: Welcome to PrivMX Docs\ndescription: PrivMX allows developers to build end-to-end encrypted apps used for communication in any environment.\n---\n\n## Client Libraries\nPrivMX Client libraries allow developers to implement PrivMX functionalities using various programming languages and popular frameworks.\n\n<Cards>\n    <Card href={'./cpp/introduction'} title={'C++'} icon={<Icon icon={'cpp'}/> } />\n    <Card href={'./js/introduction'} title={'JavaScript'}  icon={<Icon icon={'js'}/> }/>\n    <Card href={'./java/getting-started'} title={'Java/Kotlin'}  icon={<Icon icon={'java'}/> }/>\n    <Card href={'./kotlin/getting-started'} title={'Kotlin'}  icon={<Icon icon={'kotlin'}/> }/>\n    <Card href={'./swift/getting-started'} title={'Swift'}  icon={<Icon icon={'swift'}/> }/>\n    <Card href={'./csharp/introduction'} title={'C#'}  icon={<Icon icon={'csharp'}/> }/>\n\n</Cards>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/index.mdx",
        "type": "mdx",
        "chunkIndex": 0,
        "headers": [
          "Client Libraries"
        ],
        "title": "Client Libraries",
        "lastModified": "2025-06-05T19:33:57.860Z",
        "size": 878
      }
    },
    {
      "pageContent": "## Containers\nPrivMX enables communication through **text messages**, **secure file storage** and **real-time data streaming**. **PrivMX Containers** are sets of APIs designed to setup your app for specific types of communication.\n\n<Cards>\n    <Card href={'./start/threads/overview'} title={'Thread'}\n              description={\"Sending messages of various formats, between authorized users or devices. \"} icon={<Icon icon={'threads'}/> }/>\n                        <Card href={'./start/stores/overview'} title={'Store'}\n    description={\"Storing different types of data and files and sharing them with authorized users or devices. \"} icon={<Icon icon={'stores'}/> }/>\n                        <Card href={'./start/inboxes/overview'} title={'Inbox'}\n    description={\"One way communication with external users.\"} icon={<Icon icon={'inboxes'}/> }/>\n</Cards>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/index.mdx",
        "type": "mdx",
        "chunkIndex": 1,
        "headers": [
          "Containers"
        ],
        "title": "Containers",
        "lastModified": "2025-06-05T19:33:57.860Z",
        "size": 854
      }
    },
    {
      "pageContent": "---\ntitle: Installation\n---\n\n<Callout>\nBefore you start, make sure you have Docker installed on your machine. If you don't have it yet, you can download it from the [official website](https://www.docker.com/get-started).\nYou might also want to use PrivMX Bridge in non dockerized version, which requires more configuration and is recommended for advanced users. In that case, please refer to the [official repository](https://github.com/simplito/privmx-bridge)\n</Callout>\n\nTo install Bridge on your machine you can use our CLI.\n\n1. Clone Bridge CLI\n     ```shell\n    git clone https://github.com/simplito/privmx-bridge-docker\n    ```\n2. Run setup script\n    ```shell\n    ./setup.sh\n   ```\n\nThis will fetch the necessary Docker images, create Access Keys and your first Context. After a successful setup, CLI\nwill\ndisplay all the API keys necessary for connection. <br/>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/installation.mdx",
        "type": "mdx",
        "chunkIndex": 0,
        "codeBlocks": [
          "```shell\n    git clone https://github.com/simplito/privmx-bridge-docker\n    ```",
          "```shell\n    ./setup.sh\n   ```"
        ],
        "lastModified": "2025-06-05T19:33:57.860Z",
        "size": 869
      }
    },
    {
      "pageContent": "### Registering first users (optionally)\n\nYou can create first two users using provided CLI. This can come handy if you want to just test PrivMX in  one of our example projects.\n\n1. Generate keys\n    In your terminal, generate private-public key pair for your user. The keys must be in WIF format:\n     ```shell\n    ./genKeyPair.sh\n    ```\n2. Register user\n    With the keys ready, register `userId` - public key pair in your Context. Don't forget to replace placeholder values\n    with the ones created earlier:\n    ```shell\n    ./cli.sh context/addUserToContext '{\"contextId\": \"CONTEXT_ID\", \"userId\":\"USER_ID\", \"userPubKey\":\"USER_PUBLIC_KEY\" }'\n    ```\n### After Installing\n\nAfter you've successfully installed a PrivMX Bridge instance, browse our SDKs and APIs to learn what you can do next:\n- [JavaScript](../js/introduction)\n- [Java/Kotlin](../java/introduction)\n- [Swift](../swift/getting-started)\n- [API Reference](../reference/start)",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/installation.mdx",
        "type": "mdx",
        "chunkIndex": 1,
        "headers": [
          "Registering first users (optionally)",
          "After Installing"
        ],
        "title": "Registering first users (optionally)",
        "codeBlocks": [
          "```shell\n    ./genKeyPair.sh\n    ```",
          "```shell\n    ./cli.sh context/addUserToContext '{\"contextId\": \"CONTEXT_ID\", \"userId\":\"USER_ID\", \"userPubKey\":\"USER_PUBLIC_KEY\" }'\n    ```"
        ],
        "lastModified": "2025-06-05T19:33:57.860Z",
        "size": 941
      }
    },
    {
      "pageContent": "## Integrations\n\n• **Server API** - Managing the base of user keys - assigning/removing them to/from Contexts.\n\n• **Server Event Channels** (Coming Soon) - The ability to wait for changes in the Bridge and send notifications about them. The Developer's server could for example react to a new message or file. The server can only access metadata (UUID, User IDs assigned by the Developer), so the information about who, when and where sent or modified data.\n\n• **Server Data Management** (Coming Soon) - Data management based on metadata. The server can list and delete data collected in the Bridge.",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/installation.mdx",
        "type": "mdx",
        "chunkIndex": 2,
        "headers": [
          "Integrations"
        ],
        "title": "Integrations",
        "lastModified": "2025-06-05T19:33:57.860Z",
        "size": 599
      }
    },
    {
      "pageContent": "---\ntitle: Managing Users\ndescription: Learn about how to add and manage users in your app.\n---",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/managing-users.mdx",
        "type": "mdx",
        "chunkIndex": 0,
        "lastModified": "2025-06-05T19:33:57.861Z",
        "size": 95
      }
    },
    {
      "pageContent": "## Introduction\n\nPrivMX does not provide a user management service. However, each application user has to be granted access to specific resources within the Platform.\n\nFor user management, you must provide your own **application server** that can perform the following tasks:\n\n- Registering new user ID - public key pairs in [Context](/docs/start/features#context) (e.g., during a sign-up process).\n- Storing information about user profiles.\n- Providing a set of users with whom the user can establish communication (e.g., creating new Thread).\n\nWhen a user's key pair is generated (which should happen on the user’s device, not the server), **only the public key** needs to be sent to the **application server**.\nThe server can then assign the user to the desired Context.\n\nThis process ensures secure key management while allowing the application to control user access.",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/managing-users.mdx",
        "type": "mdx",
        "chunkIndex": 1,
        "headers": [
          "Introduction"
        ],
        "title": "Introduction",
        "lastModified": "2025-06-05T19:33:57.861Z",
        "size": 872
      }
    },
    {
      "pageContent": "### Requirements\n\nTo enable communication between the application server and PrivMX, the server needs to use an **API Key**.\n\nEach generated API key consists of an `API_KEY_ID` and a **secret** `API_KEY_SECRET`. Both need to be stored in environment variables.\nAPI key also has an associated access control list, which defines the PrivMX functions it can execute.\n\nIf you are using [PrivMX Bridge Docker](https://github.com/simplito/privmx-bridge-docker),\nyour first API Key will be provided after the initial PrivMX Bridge setup.",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/managing-users.mdx",
        "type": "mdx",
        "chunkIndex": 2,
        "headers": [
          "Requirements"
        ],
        "title": "Requirements",
        "lastModified": "2025-06-05T19:33:57.861Z",
        "size": 530
      }
    },
    {
      "pageContent": "### Public Key Registration\n\nFor authorization requests to PrivMX Bridge, use your API Key to request an Access Token.\nAccess Tokens have a TTL but can be refreshed using refresh tokens.\nHere is an example in Node.js:\n\n\n\n  ```ts title=\"TypeScript\"\nasync function getAccessToken() {\n  const requestBody = {\n    jsonrpc: \"2.0\",\n    id: 128,\n    method: \"manager/auth\",\n    params: {\n      scope: [\"solution:*\", \"context\"],\n      grantType: \"api_key_credentials\",\n      apiKeyId: API_KEY_ID,\n      apiKeySecret: API_KEY_SECRET,\n    },\n  };\n\n  const tokenRequest = await fetch(BRIDGE_URL, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n    body: JSON.stringify(requestBody),\n  });\n\n  const response = await tokenRequest.json();\n\n  if (tokenRequest.status === 200) {\n    return response.result.accessToken;\n  } else if (\"error\" in response) {\n    throw new Error(`Unable to get access token`);\n  } else {\n    throw new Error(`Unknown error`);\n  }\n}",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/managing-users.mdx",
        "type": "mdx",
        "chunkIndex": 3,
        "headers": [
          "Public Key Registration"
        ],
        "title": "Public Key Registration",
        "lastModified": "2025-06-05T19:33:57.861Z",
        "size": 982
      }
    },
    {
      "pageContent": "```\n\nThe Access Token can be used to authorize your request by placing it in the Authorization header.\nTo add a public key to a Context use [`context/addUserToContext`](https://bridge.privmx.dev/#context-addusertocontext) Rpc method.\n\n\n\n  ```ts title=\"TypeScript\"\nexport async function addUserToContext(userId: string, pubKey: string) {\n  //using function from earlier\n  const accessToken = await getAccessToken();\n\n  const response = await fetch(YOUR_BRIDGE_URL, {\n    method: \"POST\",\n    body: JSON.stringify({\n      jsonrpc: \"2.0\",\n      id: 128,\n      method: \"context/addUserToContext\",\n      params: {\n        contextId: CONTEXT_ID,\n        userId: USER_ID_ASSOCIATED_WITH_PUBLIC_KEY,\n        userPubKey: PUBLIC_KEY,\n      },\n    }),\n    headers: {\n      \"Content-type\": \"application/json\",\n      Authorization: `Bearer ${accessToken}`,\n    },\n  });\n}",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/managing-users.mdx",
        "type": "mdx",
        "chunkIndex": 4,
        "codeBlocks": [
          "```\n\nThe Access Token can be used to authorize your request by placing it in the Authorization header.\nTo add a public key to a Context use [`context/addUserToContext`](https://bridge.privmx.dev/#context-addusertocontext) Rpc method.\n\n\n\n  ```"
        ],
        "lastModified": "2025-06-05T19:33:57.861Z",
        "size": 857
      }
    },
    {
      "pageContent": "```\n\nYour user can now connect to your PrivMX Bridge providing a matching private key to PrivMX Endpoint in your\nclient app.\nFor guidance on how to do this in your app's stack, refer to our language-specific documentation:\n\n<Cards>\n  <Card\n    href={\"../reference/endpoint/getting-started\"}\n    title={\"C++\"}\n    icon={<Icon icon={\"cpp\"} />}\n  />\n  <Card\n    href={\"/docs/js/introduction\"}\n    title={\"JavaScript\"}\n    icon={<Icon icon={\"js\"} />}\n  />\n  <Card\n    href={\"/docs/java/getting-started\"}\n    title={\"Java/Kotlin\"}\n    icon={<Icon icon={\"java\"} />}\n  />\n  <Card\n    href={\"/docs/swift/getting-started\"}\n    title={\"Swift\"}\n    icon={<Icon icon={\"swift\"} />}\n  />\n</Cards>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/managing-users.mdx",
        "type": "mdx",
        "chunkIndex": 5,
        "lastModified": "2025-06-05T19:33:57.861Z",
        "size": 682
      }
    },
    {
      "pageContent": "---\ntitle: Queries Pagination\n---\n\n<Callout type={\"warn\"}>\n    General documentation for queries pagination is work in progress.\n</Callout>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/pagination.mdx",
        "type": "mdx",
        "chunkIndex": 0,
        "lastModified": "2025-06-05T19:33:57.861Z",
        "size": 139
      }
    },
    {
      "pageContent": "---\ntitle: Performance \n---",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/performance.mdx",
        "type": "mdx",
        "chunkIndex": 0,
        "lastModified": "2025-06-05T19:33:57.861Z",
        "size": 27
      }
    },
    {
      "pageContent": "## Native C++ Version\n\nThe following tables show the estimated PrivMX Endpoint performance on chosen platforms.\nThe assumptions of the tests are as follows:\n- each operation is repeated 100 times\n- the file used for the test (if applicable) has a size of 1 MB\n- network latency is negligible, because the tests are performed using a local server instance\n- `getMessage()/sendMessage` gets/sends a 1KB message\n- entries used by the `readEntry()/sendEntry()` have a 1MB file attached\n\n### Platform: Core i7 12gen\n\n| **Container** | **Operation (x100)**     |**min (ms)**    |**max (ms)**   |**avg (ms)**    |\n|--------|---------------       |------ |-------|-------|\n|Thread |getMessage     |19     |44     |25\n|Thread |sendMessage    |7      |18     |8\n|Store  |readFromFile   |53     |75     |58\n|Store  |writeToFile    |51     |78     |63\n|Inbox    |readEntry      |71     |137    |81\n|Inbox    |sendEntry      |59     |116    |73",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/performance.mdx",
        "type": "mdx",
        "chunkIndex": 1,
        "headers": [
          "Native C++ Version",
          "Platform: Core i7 12gen"
        ],
        "title": "Native C++ Version",
        "lastModified": "2025-06-05T19:33:57.861Z",
        "size": 931
      }
    },
    {
      "pageContent": "### Platform: ARMv7 32bit (RPi2)\n\n| **Container** | **Operation (x100)**     |**min (ms)**    |**max (ms)**   |**avg (ms)**    |\n|--------|---------------       |------ |-------|-------|\n|Thread |getMessage     |122    |163    |142\n|Thread |sendMessage    |119    |161    |136\n|Store  |readFromFile   |1251   |1476   |1292\n|Store  |writeToFile    |763    |851    |801\n|Inbox    |readEntry      |1594   |1853   |1682\n|Inbox    |sendEntry      |817    |900    |854\n\nMore examples on different platforms are in progress, this page will be updated.",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/performance.mdx",
        "type": "mdx",
        "chunkIndex": 2,
        "headers": [
          "Platform: ARMv7 32bit (RPi2)"
        ],
        "title": "Platform: ARMv7 32bit (RPi2)",
        "lastModified": "2025-06-05T19:33:57.861Z",
        "size": 544
      }
    },
    {
      "pageContent": "---\ntitle: Getting Started\n---",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/privmx-bridge.mdx",
        "type": "mdx",
        "chunkIndex": 0,
        "lastModified": "2025-06-05T19:33:57.862Z",
        "size": 30
      }
    },
    {
      "pageContent": "## PrivMX Bridge\n\nServer-side software that intermediates in the transfer of encrypted data and notifications between Endpoints and stores encrypted data for Threads, Stores, and Inboxes.\n\n- PrivMX Bridge is a **Zero-Knowledge software** – it has no possibility of reading (decrypting) data it transmits and stores.\n\n- PrivMX Bridge organizes the structure of the developer's applications (**Solutions**) by offering a universal mechanism of independent access groups called **Contexts**. Each Context is a set of containers (Threads, Stores, Inboxes created by Endpoints) together with a list of users that have rights to create and access them. Each Solution can contain any number of freely configurable Contexts.\n\n- **User’s registration in PrivMX Bridge Contexts requires providing only user’s public key and any textual `userId` assigned by the application.** As a result, PrivMX communication channels can be easily used in existing applications, with no necessary changes to the authorization system currently in use. To learn more about private and public keys, browse our [dedicated section](../start/generating-keys).",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/privmx-bridge.mdx",
        "type": "mdx",
        "chunkIndex": 1,
        "headers": [
          "PrivMX Bridge"
        ],
        "title": "PrivMX Bridge",
        "lastModified": "2025-06-05T19:33:57.862Z",
        "size": 1128
      }
    },
    {
      "pageContent": "- In short: the user's access to a Context and the containers included is granted after the Bridge (using a registered public key) successfully verifies the user's signature sent by PrivMX Endpoint (signature made on the client-side with the valid, corresponding private key).\n\n- Bridge offers an [API](https://bridge.privmx.dev/) and a system of developer keys, so that Solution and Context objects can be managed by developers.",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/privmx-bridge.mdx",
        "type": "mdx",
        "chunkIndex": 2,
        "lastModified": "2025-06-05T19:33:57.862Z",
        "size": 429
      }
    },
    {
      "pageContent": "---\ntitle: Project Map\ndescription: This page is the reference for all the GitHub repositories and projects necessary to work with PrivMX. \n\n---\n## PrivMX Bridge \n- [Bridge](https://github.com/simplito/privmx-bridge): Zero-knowledge server for secure storage and transfer of E2E encrypted data.\n- [Bridge Docker](https://github.com/simplito/privmx-bridge-docker): Docker Compose for PrivMX Bridge.",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/project-map.mdx",
        "type": "mdx",
        "chunkIndex": 0,
        "headers": [
          "PrivMX Bridge"
        ],
        "title": "PrivMX Bridge",
        "lastModified": "2025-06-05T19:33:57.862Z",
        "size": 397
      }
    },
    {
      "pageContent": "## PrivMX Endpoint\n### C++\n- [PrivMX Endpoint](https://github.com/simplito/privmx-endpoint): Library written in C++ allowing applications to build E2EE communication channels.\n- [Example projects](https://github.com/simplito/privmx-endpoint/tree/main/examples): Example use of PrivMX Endpoint in C++.\n#### Dependencies\n- [ECC Driver](https://github.com/simplito/privmx-endpoint-drv-ecc-openssl): Interface for elliptic-curve cryptography for PrivMX Endpoint.\n- [Net Driver](https://github.com/simplito/privmx-endpoint-drv-net-poco): Interface for networking for PrivMX Endpoint.\n- [Crypto Driver](https://github.com/simplito/privmx-endpoint-drv-crypto-openssl): Interface for the base cryptographic functions for PrivMX Endpoint.\n- [pson-cpp](https://github.com/simplito/pson-cpp)",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/project-map.mdx",
        "type": "mdx",
        "chunkIndex": 1,
        "headers": [
          "PrivMX Endpoint",
          "C++",
          "Dependencies"
        ],
        "title": "PrivMX Endpoint",
        "lastModified": "2025-06-05T19:33:57.862Z",
        "size": 780
      }
    },
    {
      "pageContent": "### Wrappers\n#### Web\n- [PrivMX Endpoint Web](https://github.com/simplito/privmx-webendpoint): JavaScript library designed to work in browser environment, used by PrivMX communication channels.\n##### npm\n- [Web Endpoint](https://www.npmjs.com/package/@simplito/privmx-webendpoint)\n- [Web Endpoint Manager](https://www.npmjs.com/package/@simplito/webendpoint-manager): CLI tool for managing PrivMX Endpoint Web assets.\n#### Java\n- [PrivMX Endpoint Java](https://github.com/simplito/privmx-endpoint-java): Java wrappers for the native C++ library used by PrivMX to handle end-to-end encryption.\n- [PrivMX Java Tools](https://github.com/simplito/privmx-endpoint-java-tools): Tools which simplify using PrivMX libraries in JVMs.\n#### Kotlin\n- [PrivMX Endpoint Kotlin](https://github.com/simplito/privmx-endpoint-kotlin): Kotlin wrappers for the native C++ library used by PrivMX to handle end-to-end encryption.",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/project-map.mdx",
        "type": "mdx",
        "chunkIndex": 2,
        "headers": [
          "Wrappers",
          "Web",
          "npm",
          "Java",
          "Kotlin"
        ],
        "title": "Wrappers",
        "lastModified": "2025-06-05T19:33:57.862Z",
        "size": 907
      }
    },
    {
      "pageContent": "#### Kotlin\n- [PrivMX Endpoint Kotlin](https://github.com/simplito/privmx-endpoint-kotlin): Kotlin wrappers for the native C++ library used by PrivMX to handle end-to-end encryption.\n#### Swift\n- [Endpoint Swift](https://github.com/simplito/privmx-endpoint-swift): Swift wrapper for the native C++ library used by PrivMX to handle end-to-end encryption.\n- [Endpoint Swift Extra](https://github.com/simplito/privmx-endpoint-swift-extra): Extension wrapper for PrivMX Endpoint Swift.\n#### C#  \n- [PrivMX Endpoint C# Extra](https://github.com/simplito/privmx-endpoint-csharp-extra): the recommended library for using PrivMX in C#. The package provides asynchronous methods, additional abstraction of event dispatching, reading and writing files, and more.\n- [PrivMX Endpoint C#](https://github.com/simplito/privmx-endpoint-csharp): the fundamental wrapper library, essential for the platform’s operational functionality. As the most minimalist library available, it provides the highest degree of flexibility in customizing PrivMX to meet your specific requirements.",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/project-map.mdx",
        "type": "mdx",
        "chunkIndex": 3,
        "headers": [
          "Kotlin",
          "Swift",
          "C#"
        ],
        "title": "Kotlin",
        "lastModified": "2025-06-05T19:33:57.862Z",
        "size": 1063
      }
    },
    {
      "pageContent": "## Apps\n### Web\n- [Chatee](https://github.com/simplito/privmx-chatee): End-to-end encrypted chat, written in Next.js.\n- [Web Endpoint Examples](https://github.com/simplito/privmx-webendpoint/tree/main/examples): Example usage of PrivMX Endpoint methods in JavaScript/TypeScript.\n### iOS/macOS\n- [Chatee](https://github.com/simplito/privmx-chatee-swift): End-to-end encrypted chat, written in Swift.\n- [Endpoint Minimal Swift](https://github.com/simplito/privmx-endpoint-minimal-swift): Console app written in Swift demonstrating the use of PrivMX Endpoint Swift library to work with PrivMX Bridge.\n### Android\n- [Chatee](https://github.com/simplito/privmx-chatee-android): End-to-end encrypted chat, built for Android.\n### Java Desktop\n- [PrivMX Endpoint Minimal Java](https://github.com/simplito/privmx-endpoint-minimal-java): Console app written in Java demonstrating the use of PrivMX Endpoint Java library to work with PrivMX Bridge.\n### Windows/Unity\nComing soon.\n### VR/Unity\nComing soon.",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/project-map.mdx",
        "type": "mdx",
        "chunkIndex": 4,
        "headers": [
          "Apps",
          "Web",
          "iOS/macOS",
          "Android",
          "Java Desktop",
          "Windows/Unity",
          "VR/Unity"
        ],
        "title": "Apps",
        "lastModified": "2025-06-05T19:33:57.862Z",
        "size": 994
      }
    },
    {
      "pageContent": "---\ntitle: Public/Private Meta\n---\n\nIn PrivMX, you create apps using Containers. Containers are a collection of versatile building blocks that can be used to implement\nanything from a basic chat to an encrypted file storage.\nContainers can contain items; for instance, in the Threads Container, these items are messages.\nBoth Containers and items have two common fields `publicMeta` and `privateMeta`:\n\n| **Field**    | **Encrypted** | **Format**   | **Description**                                         |\n|--------------|---------------|--------------|---------------------------------------------------------|\n| Private Meta | Yes           | Binary Array | Can be read only by Container members.                     |\n| Public Meta  | No            | Binary Array | Can be fetched using PrivMX Bridge API and all members. |",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/public-private-meta.mdx",
        "type": "mdx",
        "chunkIndex": 0,
        "lastModified": "2025-06-05T19:33:57.863Z",
        "size": 829
      }
    },
    {
      "pageContent": "## Defining Structure\nBoth private and public meta is sent as a binary array.\nThis makes the fields very versatile, both in terms of the format they use and the structure they contain.\n\nContainer's architecture does not require you to use a specific data structure inside the public and private meta.\nSo before working with a Container, define what kind of info you will need in your application.\n\nLet's say you want to assign name to your Container.\nYou may decide to put the name in `publicMeta` if it doesn't contain sensitive data,\nor you will need to download it on the server.\nIn case the name contains sensitive user data, a better choice is to place it in `privateMeta`,\nso that it will be encrypted before sending.\n\nThis will greatly increase the security of your application at the cost\nof your application server not having access to this data.",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/public-private-meta.mdx",
        "type": "mdx",
        "chunkIndex": 1,
        "headers": [
          "Defining Structure"
        ],
        "title": "Defining Structure",
        "lastModified": "2025-06-05T19:33:57.863Z",
        "size": 855
      }
    },
    {
      "pageContent": "## Serializing Data\nThe easiest and most common format for serialization is JSON.\nAll modern languages have a way to serialize key-value data structures to a JSON string and from string to a binary array.\n\nFollowing the previous example we can define simple structure with `name` property.\n\n<Tabs items={[\"JavaScript\"]}>\n<Tab>\n\n```ts\nconst privateMeta = {\n   name: NAME_OF_YOUR_CONTAINER\n}\n```\n</Tab>\n</Tabs>\n\nSerialize it to binary array:\n\n<Tabs items={[\"JavaScript\"]}>\n    <Tab>\n        ```ts\n        const privateMeta = {\n            name: NAME_OF_YOUR_CONTAINER\n        }\n        const encoder = new TextEncoder()\n        const serialized = encoder.encode(JSON.stringify(privateMeta))\n        ```\n    </Tab>\n</Tabs>\n\nYou can now pass it while creating your Container, e.g., Thread:\n<Tabs items={[\"JavaScript\"]}>\n    <Tab>\n        ```ts\n        const privateMeta = {\n            name: NAME_OF_YOUR_CONTAINER\n        }\n        const encoder = new TextEncoder()\n        const serialized = encoder.encode(JSON.stringify(privateMeta))",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/public-private-meta.mdx",
        "type": "mdx",
        "chunkIndex": 2,
        "headers": [
          "Serializing Data"
        ],
        "title": "Serializing Data",
        "codeBlocks": [
          "```ts\nconst privateMeta = {\n   name: NAME_OF_YOUR_CONTAINER\n}\n```",
          "```ts\n        const privateMeta = {\n            name: NAME_OF_YOUR_CONTAINER\n        }\n        const encoder = new TextEncoder()\n        const serialized = encoder.encode(JSON.stringify(privateMeta))\n        ```"
        ],
        "lastModified": "2025-06-05T19:33:57.863Z",
        "size": 1033
      }
    },
    {
      "pageContent": "await threadApi.createThread(\n            CONTEXT_ID,\n            [THREAD_MEMBERS],\n            [THREAD_MANAGERS],\n            new Uint8Array() // this thread doesn't have publicMeta so we pass empty Uint8Array\n            serialized,\n        )\n        ```\n    </Tab>\n</Tabs>\n\n\nRemember that it is only an example and you should always consider your app's requirements and limitations.",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/public-private-meta.mdx",
        "type": "mdx",
        "chunkIndex": 3,
        "lastModified": "2025-06-05T19:33:57.863Z",
        "size": 385
      }
    },
    {
      "pageContent": "## Good Practices\n\nWe recommend future-proofing your meta right from the start.\n\n### Using Easily Modifiable Format\nWhile it's possible to pass plain text or a number (encoded to a binary array), it's advised to use\nsomething like JSON or other key-value format.\nIn case of changes in app requirements, it is easier to add or remove a field than change an entire type\nof field.\n\n```json title=\"Bad practice\"\n//rest of container fields\npublicMeta:\"published\"\n```\n\n```json title=\"Good practice\"\n//rest of container fields\npublicMeta:{\n  status:\"published\"\n}\n```\n\n### Adding Schema Version\nThis simplifies adding support for backwards compatibility. Versions can have different fields or may introduce\nchanges in field types.\n\n```json title=\"Good practice\"\n//rest of container fields\npublicMeta:{\n  _ver: 2 // [!code highlight]\n  status:\"published\"\n}\n```",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/public-private-meta.mdx",
        "type": "mdx",
        "chunkIndex": 4,
        "headers": [
          "Good Practices",
          "Using Easily Modifiable Format",
          "Adding Schema Version"
        ],
        "title": "Good Practices",
        "codeBlocks": [
          "```json title=\"Bad practice\"\n//rest of container fields\npublicMeta:\"published\"\n```",
          "```json title=\"Good practice\"\n//rest of container fields\npublicMeta:{\n  status:\"published\"\n}\n```",
          "```json title=\"Good practice\"\n//rest of container fields\npublicMeta:{\n  _ver: 2 // [!code highlight]\n  status:\"published\"\n}\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.863Z",
        "size": 851
      }
    },
    {
      "pageContent": "---\ntitle: Quick Start\n---\nPrivMX is a **Zero-Knowledge software** – it has no possibility of reading (decrypting) data it transmits and stores.\n\n**User’s registration in PrivMX Bridge Contexts requires providing only user’s public key and any textual userId assigned by the application.**\nAs a result, PrivMX communication channels can be easily used in existing applications, with no necessary changes to the authorization system currently in use.",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/quick-start.mdx",
        "type": "mdx",
        "chunkIndex": 0,
        "lastModified": "2025-06-05T19:33:57.863Z",
        "size": 449
      }
    },
    {
      "pageContent": "## Installation\n:::tip\n\nBefore you start, make sure you have Docker installed on your machine. If you don't have it yet, you can download it from the [official website](https://www.docker.com/get-started).\nYou might also want to use PrivMX Bridge in non dockerized version, which requires more configuration and is recommended for advanced users. In that case, please refer to the [official repository](https://github.com/simplito/privmx-bridge)\n\n:::\n\nTo install Bridge on your machine you can use our CLI.\n\n1. Clone Bridge CLI\n     ```shell\n    git clone https://github.com/simplito/privmx-bridge-docker\n    ```\n2. Run setup script\n    ```shell\n    ./setup.sh\n    ```\n    This will fetch the necessary Docker images, create Access Keys and your first Context. After a successful setup, CLI\n    will\n    display all the API keys necessary for connection. <br/>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/quick-start.mdx",
        "type": "mdx",
        "chunkIndex": 1,
        "headers": [
          "Installation"
        ],
        "title": "Installation",
        "codeBlocks": [
          "```shell\n    git clone https://github.com/simplito/privmx-bridge-docker\n    ```",
          "```shell\n    ./setup.sh\n    ```"
        ],
        "lastModified": "2025-06-05T19:33:57.863Z",
        "size": 860
      }
    },
    {
      "pageContent": "### Registering first users (optionally)\n\nYou can create first two users using provided CLI. This can come handy if you want to just test PrivMX in  one of our example projects.\n\n1. Generate keys\n    In your terminal, generate private-public key pair for your user. The keys must be in WIF format\n    To learn more about private and public keys, browse our [dedicated section](../start/generating-keys)\n    ```shell\n    ./genKeyPair.sh\n   ```\n2. Register user\n\n    With the keys ready, register `userId` - public key pair in your Context. Don't forget to replace placeholder values\n    with the ones created earlier:\n    ```shell\n    ./cli.sh context/addUserToContext '{\"contextId\": \"CONTEXT_ID\", \"userId\":\"USER_ID\", \"userPubKey\":\"USER_PUBLIC_KEY\" }'\n    ```\n### After Installing\n\nAfter you've successfully installed a PrivMX Bridge instance, browse our SDKs and APIs to learn what you can do next:\n    - [C++](../cpp/introduction)\n    - [JavaScript](../js/introduction)\n    - [Java](../java/getting-started)\n    - [Kotlin](../kotlin/introduction)\n    - [Swift](../swift/getting-started)\n    - [C#](../csharp/introduction)\n    - [API Reference](../start/api-reference)",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/quick-start.mdx",
        "type": "mdx",
        "chunkIndex": 2,
        "headers": [
          "Registering first users (optionally)",
          "After Installing"
        ],
        "title": "Registering first users (optionally)",
        "codeBlocks": [
          "```shell\n    ./genKeyPair.sh\n   ```",
          "```shell\n    ./cli.sh context/addUserToContext '{\"contextId\": \"CONTEXT_ID\", \"userId\":\"USER_ID\", \"userPubKey\":\"USER_PUBLIC_KEY\" }'\n    ```"
        ],
        "lastModified": "2025-06-05T19:33:57.863Z",
        "size": 1168
      }
    },
    {
      "pageContent": "---\ntitle: Versioning\n---",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/versioning.mdx",
        "type": "mdx",
        "chunkIndex": 0,
        "lastModified": "2025-06-05T19:33:57.864Z",
        "size": 25
      }
    },
    {
      "pageContent": "## A.B.C-rcX versioning\n\nEach version of the project is marked with semantic numbering. Here are the detailed rules:\n\n### New features\n\nChanges in `A` and `B` numbers introduce new features:\n\n• `A` (major): changes in the event of major updates or the introduction of incompatible features.\n\n• `B` (minor): changes in the event of minor updates, which are **in most cases** compatible with previous versions.\n\n### Consistency of numbering\n\nThe main library and all the wrappers use the same `A` and `B` versioning.\n\n### Updates within the version:\n\n• `C` changes consist of fixes and updates that do not introduce new features – they are only bug and optimization fixes.\n\n• `C` does not have to be synchronized between the library and the wrappers.\n\n### Release Candidate (rc)\n\nThe `X` in `A.B.C-rcX` stands for the consecutive release candidates for given version.\n\n### Before official release\n\n• Before making a final release decision in the team, all the components (the library and the wrappers) are released as `A.B.C-rcX`.\n\n• At the `rc` stage, changes connected to the new API are possible and they change the `X`.",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/versioning.mdx",
        "type": "mdx",
        "chunkIndex": 1,
        "headers": [
          "A.B.C-rcX versioning",
          "New features",
          "Consistency of numbering",
          "Updates within the version:",
          "Release Candidate (rc)",
          "Before official release"
        ],
        "title": "A.B.C-rcX versioning",
        "lastModified": "2025-06-05T19:33:57.864Z",
        "size": 1121
      }
    },
    {
      "pageContent": "### Finalizing a version\n\nWhen the main library and the wrappers reach full compatibility in a given version, a stable version of A.B.C is published, with all the components synchronized.\n\n### Minor changes (B)\n\n• Adding small features or items to replace older functionality bumps up the `B` number.\n\n• Replaced and changed functions will be marked as deprecated, but still work until a version with a bumped up `A` number is released.\n\n• However, we do not exclude the **possibility that compatibility will be broken** at this stage. We will inform about it in release-notes.\n\n### Major changes (A)\n\nIntroducing major changes or features, requires the `A` number increase.",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/versioning.mdx",
        "type": "mdx",
        "chunkIndex": 2,
        "headers": [
          "Finalizing a version",
          "Minor changes (B)",
          "Major changes (A)"
        ],
        "title": "Finalizing a version",
        "lastModified": "2025-06-05T19:33:57.864Z",
        "size": 674
      }
    },
    {
      "pageContent": "---\ntitle: Encryption\n---\n## Encryption in Threads\n\nEach message is protected by a synchronous key, which is further secured using an asynchronous pair of public and private user keys. \nThis dual-layer encryption ensures that the system remains both safe and efficient.\n\n## Encryption Scenario\n\nOnly an end user can create a Thread, by providing a set of public keys for the users who should have access to the Thread.\n\nA symmetric key for the Thread (Thread Encryption Key) is then **generated by the Thread author** and securely stored on the server, encrypted using public keys of **users assigned to the Thread**. \nThis ensures that only the authorized users have access to the Thread's Encryption Key. **Unencrypted keys never leave User Endpoints.**\n\nWhen accessing a Thread, the encrypted Thread Encryption Key is sent to each user based on their assignment to the Thread. Only the users with proper Private Keys can decrypt Thread Encryption Key. \nUsing the decrypted key, messages are encrypted and signed with the users’ Private Keys before being sent to the Bridge.  \n\nThis process is handled by the PrivMX Endpoint and is completely seamless for the users.",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/threads/encryption.mdx",
        "type": "mdx",
        "chunkIndex": 0,
        "headers": [
          "Encryption in Threads",
          "Encryption Scenario"
        ],
        "title": "Encryption in Threads",
        "lastModified": "2025-06-05T19:33:57.864Z",
        "size": 1168
      }
    },
    {
      "pageContent": "---\ntitle: Listening for Changes\n---\n\n\nListening for events related new messages and updating your app's state accordingly will allow you to build e.g., instant messaging features.\n\n## Types of Events\nThe lists below outline all the event types available in Threads and messages in PrivMX.\n\nThread events: \n- `threadCreated` - triggers when a new Thread is created in your Context\n- `threadDeleted` - triggers when a Thread is deleted from your Context\n- `threadUpdated` - triggers when a Thread is updated\n- `threadStatsChanged` - triggers when a message is sent to a thread or a message has been deleted\n\nMessage events: \n- `threadNewMessage` - triggers a message was sent to a Thread\n- `threadDeletedMessage`  triggers when a message was deleted from a Thread\n- `threadMessageUpdated` - triggers when a message was updated",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/threads/listening-for-changes.mdx",
        "type": "mdx",
        "chunkIndex": 0,
        "headers": [
          "Types of Events"
        ],
        "title": "Types of Events",
        "lastModified": "2025-06-05T19:33:57.865Z",
        "size": 825
      }
    },
    {
      "pageContent": "## Handling Thread and Message Events\n\n:::info\n\nThe sample code on this page is based on the same **[assumptions](./managing#initial-assumptions)**.\n\n:::\n\nBefore receiving Events, your application has to start an event loop and subscribe to a specific channel.\nAfterwards you can setup a listener.\n\nHere is an example how to do it in your own project:\n\n<Tabs groupId=\"lang\" items={['cpp','js','java','kotlin','swift']}>\n\n<Tab value=\"cpp\" label=\"C++\">\n\n```cpp\n// handle events\ncore::EventQueue eventQueue {core::EventQueue::getInstance()};\nstd::thread t([&](){\n    while(true) {\n        core::EventHolder event = eventQueue.waitEvent();\n        std::cout << \"onEvent: \" << event.type() << std::endl;\n        std::cout << event.toJSON() << std::endl;\n    }\n});\nt.detach();\n\n// subscribe for threads general events\nthreadsApi.subscribeForThreadEvents();\n\n// subscribe for particular thread events\nthreadsApi.subscribeForMessageEvents(threadId);\n```\n</Tab>\n\n<Tab value=\"js\" label=\"JavaScript\">\n\n```js\n// Getting the Event Queue\nconst eventQueue = await EndpointFactory.getEventQueue();",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/threads/listening-for-changes.mdx",
        "type": "mdx",
        "chunkIndex": 1,
        "headers": [
          "Handling Thread and Message Events"
        ],
        "title": "Handling Thread and Message Events",
        "codeBlocks": [
          "```cpp\n// handle events\ncore::EventQueue eventQueue {core::EventQueue::getInstance()};\nstd::thread t([&](){\n    while(true) {\n        core::EventHolder event = eventQueue.waitEvent();\n        std::cout << \"onEvent: \" << event.type() << std::endl;\n        std::cout << event.toJSON() << std::endl;\n    }\n});\nt.detach();\n\n// subscribe for threads general events\nthreadsApi.subscribeForThreadEvents();\n\n// subscribe for particular thread events\nthreadsApi.subscribeForMessageEvents(threadId);\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.865Z",
        "size": 1081
      }
    },
    {
      "pageContent": "<Tab value=\"js\" label=\"JavaScript\">\n\n```js\n// Getting the Event Queue\nconst eventQueue = await EndpointFactory.getEventQueue();\n\n// Simple function to listen for events in a loop\nfunction listenForEvents(eventsQueue) {\n    eventsQueue.waitEvent().then(event => {\n        console.log(\"onEvent\", event);\n        listenForEvents(eventsQueue);\n    });\n}\n// Start listening to events\nlistenForEvents(eventQueue);",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/threads/listening-for-changes.mdx",
        "type": "mdx",
        "chunkIndex": 2,
        "lastModified": "2025-06-05T19:33:57.865Z",
        "size": 407
      }
    },
    {
      "pageContent": "```\n\n</Tab>\n<Tab value=\"java\" label=\"Java\">\n\n```java\nString callbacksID = \"CALLBACK_ID\";\nString threadID = \"THREAD_ID\";\n// Starting the Event Loop\nendpointContainer.startListening();\n\n// Handling Thread events\nendpointSession.registerCallback(\n    callbacksID,\n    EventType.ThreadCreatedEvent,\n    newThread -> {\n        System.out.println(newThread.threadId);\n    }\n);\n\n//Handling message Events\nendpointSession.registerCallback(\n    callbacksID,\n    EventType.ThreadNewMessageEvent(threadID),\n    newMessage -> {\n        System.out.println(newMessage.info.messageId);\n    }\n);\n```\n</Tab>\n<Tab value=\"kotlin\" label=\"Kotlin\">\n\n```kotlin\nval callbacksID = \"CALLBACK_ID\"\nval threadID = \"THREAD_ID\"\n// Starting the Event Loop\nendpointContainer.startListening()\n\n// Handling Thread events\nendpointSession.registerCallback(\n    callbacksID,\n    EventType.ThreadCreatedEvent\n){ newThread ->\n    println(newThread.threadId)\n}\n\n//Handling message Events\nendpointSession.registerCallback(\n    callbacksID,\n    EventType.ThreadNewMessageEvent(threadID)\n){ newMessage ->\n    println(newMessage.info?.messageId)\n}\n```\n</Tab>\n<Tab value=\"swift\" label=\"Swift\">",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/threads/listening-for-changes.mdx",
        "type": "mdx",
        "chunkIndex": 3,
        "codeBlocks": [
          "```\n\n</Tab>\n<Tab value=\"java\" label=\"Java\">\n\n```",
          "```\n</Tab>\n<Tab value=\"kotlin\" label=\"Kotlin\">\n\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.865Z",
        "size": 1147
      }
    },
    {
      "pageContent": "```swift\n _ = try? endpointSession?.registerCallback(\n    for: privmx.endpoint.thread.ThreadCreatedEvent.self,\n    from: .thread, identified: \"SOME_UNIQUE_IDENTIFIER\",\n    { eventData in\n        // some actions when new thread created\n    })\n```\n</Tab>\n</Tabs>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/threads/listening-for-changes.mdx",
        "type": "mdx",
        "chunkIndex": 4,
        "codeBlocks": [
          "```swift\n _ = try? endpointSession?.registerCallback(\n    for: privmx.endpoint.thread.ThreadCreatedEvent.self,\n    from: .thread, identified: \"SOME_UNIQUE_IDENTIFIER\",\n    { eventData in\n        // some actions when new thread created\n    })\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.865Z",
        "size": 260
      }
    },
    {
      "pageContent": "---\ntitle: Managing Threads\n---\n\nAt their core, Threads provide a secure way for assigned members to exchange encrypted messages.\n\n- Threads allow users to communicate using topic-specific communication channels.\n- Each Context can contain any number of Threads with a unique identifier (`threadId`) used to distinguish them.\n- Threads do not need to have unique names or assigned public keys.\n\n## Permissions\nThreads differentiate two types of users - Managers and Regular Users. The table below shows the differences in their permissions:\n\n| **Activity**      | **User**       | **Manager**  |\n|-------------------|----------------|--------------|\n| Sending messages  | yes            | yes          |\n| Editing Thread    | no             | yes          |\n| Deleting messages | only their own | all messages |\n\nThe values above are the default policy values defined by PrivMX. To read more about Policies and learn how to modify them, go to [Policies](../concepts/policies).",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/threads/managing.mdx",
        "type": "mdx",
        "chunkIndex": 0,
        "headers": [
          "Permissions"
        ],
        "title": "Permissions",
        "lastModified": "2025-06-05T19:33:57.865Z",
        "size": 976
      }
    },
    {
      "pageContent": "## Initial Assumptions\nThe initial assumptions for all the code examples below are as follows:\n<Tabs items={[\"cpp\",\"js\",\"java\",\"swift\"]} defaultIndex={1} groupId={\"lang\"}>\n\n<Tab value=\"cpp\" label=\"C++\">\n```cpp\n    #include <privmx/endpoint/core/Connection.hpp>\n    #include <privmx/endpoint/thread/ThreadApi.hpp>\n    #include <privmx/endpoint/core/Buffer.hpp>\n    // ...\n\n\t/* \n\tAll the values below like BRIDGE_URL, SOLUTION_ID, CONTEXT_ID \n\tshould be replaced by the ones corresponding to your Bridge Server instance.\n\t\n\tThe private keys here are for demonstration purposes only. \n\tNormally, they should be kept separately by each user and stored in a safe place,\n\tor generated from a password (see the derivePrivateKey() method in the Crypto API)\n\t*/\n\n\tstd::string BRIDGE_URL {\"http://localhost:9111\"};\n\tstd::string SOLUTION_ID {\"YOUR_SOLUTION_ID\"};\n\tstd::string CONTEXT_ID {\"YOUR_CONTEXT_ID\"};\n\n\tstd::string USER1_ID {\"user_1\"};\n\tstd::string USER1_PUBLIC_KEY {\"PUBLIC_KEY_1\"};\n\tstd::string USER1_PRIV {\"PRIVATE_KEY_1\"};\n\n\tstd::string USER2_ID {\"user_2\"};\n\tstd::string USER2_PUBLIC_KEY {\"PUBLIC_KEY_2\"};\n\n\tstd::string USER3_ID {\"user_3\"};\n\tstd::string USER3_PUBLIC_KEY {\"PUBLIC_KEY_3\"};",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/threads/managing.mdx",
        "type": "mdx",
        "chunkIndex": 1,
        "headers": [
          "Initial Assumptions"
        ],
        "title": "Initial Assumptions",
        "lastModified": "2025-06-05T19:33:57.865Z",
        "size": 1188
      }
    },
    {
      "pageContent": "std::string USER2_ID {\"user_2\"};\n\tstd::string USER2_PUBLIC_KEY {\"PUBLIC_KEY_2\"};\n\n\tstd::string USER3_ID {\"user_3\"};\n\tstd::string USER3_PUBLIC_KEY {\"PUBLIC_KEY_3\"};\n\n    // initialize Endpoint connection and Threads API\n\tauto connection {core::Connection::connect(USER1_PRIV, SOLUTION_ID, BRIDGE_URL)};\n\tauto threadsApi {thread::ThreadApi::create(connection)};\n```\n</Tab>\n\n<Tab value=\"js\" label=\"JavaScript\">\n```js\n    /* \n    All the values below like BRIDGE_URL, SOLUTION_ID, CONTEXT_ID \n    should be replaced by the ones corresponding to your Bridge Server instance.\n    \n    The private keys here are for demonstration purposes only. \n    Normally, they should be kept separately by each user and stored in a safe place,\n    or generated from a password (see the derivePrivateKey() method in the Crypto API)\n    */\n\n    const BRIDGE_URL = \"http://localhost:9111\";\n    const SOLUTION_ID = \"YOUR_SOLUTION_ID\";\n    const CONTEXT_ID = \"YOUR_CONTEXT_ID\";\n\n    const USER1_ID = \"user_1\";\n    const USER1_PUBLIC_KEY = \"PUBLIC_KEY_1\";\n    const USER1_PRIV = \"PRIVATE_KEY_1\";\n\n    const USER2_ID = \"user_2\";\n    const USER2_PUBLIC_KEY = \"PUBLIC_KEY_2\";",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/threads/managing.mdx",
        "type": "mdx",
        "chunkIndex": 2,
        "codeBlocks": [
          "```\n</Tab>\n\n<Tab value=\"js\" label=\"JavaScript\">\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.865Z",
        "size": 1147
      }
    },
    {
      "pageContent": "const USER1_ID = \"user_1\";\n    const USER1_PUBLIC_KEY = \"PUBLIC_KEY_1\";\n    const USER1_PRIV = \"PRIVATE_KEY_1\";\n\n    const USER2_ID = \"user_2\";\n    const USER2_PUBLIC_KEY = \"PUBLIC_KEY_2\";\n\n    const USER3_ID = \"user_3\";\n    const USER3_PUBLIC_KEY = \"PUBLIC_KEY_3\";\n\n\n    class App {\n        uint8ToStr(arr) {\n            return (new TextDecoder()).decode(arr);\n        }\n\n        strToUint8(text) {\n            return (new TextEncoder()).encode(text);\n        }\n\n        // ...\n\n        run() {\n            // Initialize Endpoint and its Wasm assets\n            await Endpoint.setup(\"/public\");\n\n            // initialize Endpoint connection and Threads API\n            const connection = await Endpoint.connect(USER1_PRIV, SOLUTION_ID, BRIDGE_URL);\n            const threadsApi = await Endpoint.createThreadApi(connection);\n\n            // ...\n        }\n    }\n    new App().run();\n\n```\n</Tab>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/threads/managing.mdx",
        "type": "mdx",
        "chunkIndex": 3,
        "lastModified": "2025-06-05T19:33:57.865Z",
        "size": 894
      }
    },
    {
      "pageContent": "// ...\n        }\n    }\n    new App().run();\n\n```\n</Tab>\n\n<Tab value=\"java\" label=\"Java\">\n```java\n    /* \n    All the values below like BRIDGE_URL, SOLUTION_ID, CONTEXT_ID \n    should be replaced by the ones corresponding to your Bridge Server instance.\n    \n    The private keys here are for demonstration purposes only. \n    Normally, they should be kept separately by each user and stored in a safe place,\n    or generated from a password (see the derivePrivateKey() method in the Crypto API)\n    */ \n\n    String bridgeUrl = \"http://localhost:9111\";\n    String solutionId = \"YOUR_SOLUTION_ID\";\n    String contextId = \"YOUR_CONTEXT_ID\";\n\n    String user1Id = \"user_1\";\n    String user1publicKey = \"PUBLIC_KEY_1\";\n    String user1Priv = \"PRIVATE_KEY_1\";\n\n    String user2Id = \"user_2\";\n    String user2PublicKey = \"PUBLIC_KEY_2\";\n\n    String user3Id = \"user_3\";\n    String user3PublicKey = \"PUBLIC_KEY_3\";\n\n    Long limit = 30L;\n    Long skip = 0L;\n```\n</Tab>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/threads/managing.mdx",
        "type": "mdx",
        "chunkIndex": 4,
        "codeBlocks": [
          "```\n</Tab>\n\n<Tab value=\"java\" label=\"Java\">\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.865Z",
        "size": 959
      }
    },
    {
      "pageContent": "String user3Id = \"user_3\";\n    String user3PublicKey = \"PUBLIC_KEY_3\";\n\n    Long limit = 30L;\n    Long skip = 0L;\n```\n</Tab>\n\n<Tab value=\"kotlin\" label=\"Kotlin\">\n```kotlin\n    /* \n    All the values below like BRIDGE_URL, SOLUTION_ID, CONTEXT_ID \n    should be replaced by the ones corresponding to your Bridge Server instance.\n    \n    The private keys here are for demonstration purposes only. \n    Normally, they should be kept separately by each user and stored in a safe place,\n    or generated from a password (see the derivePrivateKey() method in the Crypto API)\n    */ \n\n    val bridgeUrl = \"http://localhost:9111\"\n    val solutionId = \"YOUR_SOLUTION_ID\"\n    val contextId = \"YOUR_CONTEXT_ID\"\n\n    val user1Id = \"user_1\"\n    val user1publicKey = \"PUBLIC_KEY_1\"\n    val user1Priv = \"PRIVATE_KEY_1\"\n\n    val user2Id = \"user_2\"\n    val user2PublicKey = \"PUBLIC_KEY_2\"\n\n    val user3Id = \"user_3\"\n    val user3PublicKey = \"PUBLIC_KEY_3\"\n\n    val limit = 30L\n    val skip = 0L\n```\n</Tab>\n\n<Tab value=\"swift\" label=\"Swift\">\n\n```swift\n    let PAGE_SIZE :Int64 = 30\n    let pageIndex :Int64 = 2\n```\n</Tab>\n</Tabs>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/threads/managing.mdx",
        "type": "mdx",
        "chunkIndex": 5,
        "codeBlocks": [
          "```\n</Tab>\n\n<Tab value=\"kotlin\" label=\"Kotlin\">\n```",
          "```\n</Tab>\n\n<Tab value=\"swift\" label=\"Swift\">\n\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.865Z",
        "size": 1113
      }
    },
    {
      "pageContent": "## Creating Threads\n\nTo create a Thread, you need a name and a list of **public key - userID** pairs.\nDue to the fact that each Thread is inside a Context, all the public keys have to be registered inside the given Context. \nYou can do it using [PrivMX Bridge API](https://bridge.privmx.dev/).\n\nAfter creating a Thread, all the users with management rights will be able to edit the Thread.\n\nBelow you can see some examples of creating Threads that function as a chat feature in your application, with access management capabilities similar to those found in other popular collaboration tools.\n\n<Tabs groupId=\"lang\" items={[\"JavaScript\",\"Java\",\"Kotlin\",\"Swift\"]}>\n    <Tab>\n        ```js\n        const thread = Endpoint.connection().thread('THREAD_ID');\n        const threadInfo = await thread.info();\n\n        const newUsers = threadInfo.users.map(user => ({\n        //Your application must provide a way,\n        //to get user's public key from their userId.\n        userId: user,\n        pubKey: 'USER_PUBLIC_KEY'\n    })\n        );\n\n        const newManagers = newUsers.filter(user =>\n        threadInfo.managers.find(manager => manager == user.userId));",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/threads/managing.mdx",
        "type": "mdx",
        "chunkIndex": 6,
        "headers": [
          "Creating Threads"
        ],
        "title": "Creating Threads",
        "lastModified": "2025-06-05T19:33:57.865Z",
        "size": 1156
      }
    },
    {
      "pageContent": "const newManagers = newUsers.filter(user =>\n        threadInfo.managers.find(manager => manager == user.userId));\n\n        const newPrivateMeta = {\n        title: 'New thread name'\n    };\n\n        await thread.update({\n        users: newUsers,\n        managers: newManagers,\n        privateMeta: serializeObject(newPrivateMeta),\n        version: threadInfo.version\n    });\n        ```\n    </Tab>\n    <Tab value='java' label=\"Java\">\n        ```java\n        PrivmxEndpointContainer container = new PrivmxEndpointContainer();\n        Long connectionID = 0L; // your connection ID\n        String threadID = \"YOUR_THREAD_ID\";\n\n        ThreadApi threadApi = container.getEndpoint(connectionID).threadApi;\n        com.simplito.java.privmx_endpoint.model.Thread thread = threadApi.getThread(threadID);\n\n        List<UserWithPubKey> newUsers = thread.users.stream().map(userID -> {\n        //Your application must provide a way,\n        //to get user's public key from their userId.\n\n        return new UserWithPubKey(\n        userID,\n        \"USER_PUBLIC_KEY\"\n        );",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/threads/managing.mdx",
        "type": "mdx",
        "chunkIndex": 7,
        "codeBlocks": [
          "```\n    </Tab>\n    <Tab value='java' label=\"Java\">\n        ```"
        ],
        "lastModified": "2025-06-05T19:33:57.865Z",
        "size": 1062
      }
    },
    {
      "pageContent": "return new UserWithPubKey(\n        userID,\n        \"USER_PUBLIC_KEY\"\n        );\n\n    }).toList();\n        List<UserWithPubKey> newManagers = thread.managers.stream().map(userID -> {\n            //Your application must provide a way,\n            //to get user's public key from their userId.\n            return new UserWithPubKey(\n            userID,\n            \"USER_PUBLIC_KEY\"\n            );\n\n        }).toList();\n            byte[] newPrivateMeta = \"New thread name\".getBytes(StandardCharsets.UTF_8);\n\n            container.getEndpoint(connectionID).threadApi.updateThread(\n            threadID,\n            newUsers,\n            newManagers,\n            thread.publicMeta,\n            newPrivateMeta,\n            thread.version,\n            false\n            );\n            ```\n    </Tab>\n    <Tab value=\"kotlin\" label=\"Kotlin\">\n        ```kotlin\n        val container = PrivmxEndpointContainer()\n        val connectionID = 0L // your connection ID\n        val threadID = \"YOUR_THREAD_ID\"\n\n        val threadApi = container.getEndpoint(connectionID).threadApi\n        val thread = threadApi.getThread(threadID)",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/threads/managing.mdx",
        "type": "mdx",
        "chunkIndex": 8,
        "codeBlocks": [
          "```\n    </Tab>\n    <Tab value=\"kotlin\" label=\"Kotlin\">\n        ```"
        ],
        "lastModified": "2025-06-05T19:33:57.865Z",
        "size": 1115
      }
    },
    {
      "pageContent": "val threadApi = container.getEndpoint(connectionID).threadApi\n        val thread = threadApi.getThread(threadID)\n\n        val newUsers = thread.users.map { userID ->\n        UserWithPubKey(\n            userID,\n            \"USER_PUBLIC_KEY\"\n        )\n    }.toList()\n        val newManagers = thread.managers.map { userID ->\n        UserWithPubKey(\n            userID,\n            \"USER_PUBLIC_KEY\"\n        )\n    }.toList()\n        val newPrivateMeta = \"New thread name\".toByteArray(StandardCharsets.UTF_8)\n\n        container.getEndpoint(connectionID).threadApi.updateThread(\n        threadID,\n        newUsers,\n        newManagers,\n        thread.publicMeta,\n        newPrivateMeta,\n        thread.version,\n        false\n        )\n        ```\n    </Tab>\n    <Tab value='swift' label=\"Swift\">\n        ```swift\n        let threadId :String= // id of thread to update\n        let threadInfo = threadApi.getThread(threadId);\n\n        var users :[UserWithPubKey] //new list of users\n        var managers :[UserWithPubKey]  //new list of managers",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/threads/managing.mdx",
        "type": "mdx",
        "chunkIndex": 9,
        "codeBlocks": [
          "```\n    </Tab>\n    <Tab value='swift' label=\"Swift\">\n        ```"
        ],
        "lastModified": "2025-06-05T19:33:57.865Z",
        "size": 1039
      }
    },
    {
      "pageContent": "var users :[UserWithPubKey] //new list of users\n        var managers :[UserWithPubKey]  //new list of managers\n\n        threadApi.updateThread(\n        threadInfo.threadId,\n        users:users,\n        managers:managers,\n        title:threadInfo.data.title,\n        version:threadInfo.version,\n        force:false,\n        generateNewKeyId:false,\n        accessToOldDataForNewUsers:false\n        )\n        ```\n    </Tab>\n</Tabs>\n\nThree additional options are available when changing the list of users inside a Thread:\n- `accessToOldDataForNewUsers` - if marked `true`, the newly added users will be able to access messages sent before they joined the Thread;\n- `force` - applies an update, without checking the current version;\n- `generateNewKey` - re-encrypts messages in the Thread. It's useful when a user is removed and we want to prevent them from accessing the Thread.",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/threads/managing.mdx",
        "type": "mdx",
        "chunkIndex": 10,
        "lastModified": "2025-06-05T19:33:57.865Z",
        "size": 874
      }
    },
    {
      "pageContent": "---\ntitle: Messages\n---\n\nThreads allow the exchange of messages.\nIn this section, let's take a closer look at the structure of messages and how to send them. We will also discuss some good practice when working with Threads.\n\n## About Messages\n\nThe structure of a message and a brief description of its elements is outlined in the following table:\n|**field**|**type**|**encrypted**|**description**|\n|---|---|---|---|\n|`data`|binary|yes|content of the message\n|`info`|ServerInfo|no|additional information assigned by the server e.g. author, `creationDate`, `messageID` and `threadID`\n|`privateMeta`|binary|yes|additional information about the message\n|`publicMeta`|binary|no|additional public information about the message, also accessible through Platform REST API",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/threads/messages.mdx",
        "type": "mdx",
        "chunkIndex": 0,
        "headers": [
          "About Messages"
        ],
        "title": "About Messages",
        "lastModified": "2025-06-05T19:33:57.865Z",
        "size": 764
      }
    },
    {
      "pageContent": "## Define structure\n\nThread's architecture does not require you to use a specific data structure inside the messages.\nSo before working with Threads, define what what kind of messages you want to send.\n\nWe recommend future-proofing your messages right from the start, i.e. choosing an easily modifiable format.\n\nIt is also a good idea to include its type and version in the structure of the message.\n\nHere is an example message structure that you can use in your project.\n\n``` json title=\"JSON\"\n{\n   “data”:{\n     “content”: \"string\", // string / binary data containing for example: markdown, html or json\n   },\n   “info”: \"ServerInfo\", // assigned by server,\n   “publicMeta”:{\n     “version”:number,\n     “type”: “text”, // some kind of enum describing type of message like “event”, “html”,“markdown” etc.\n   },\n   “privateMeta”:{\n     // meta fields\n   }\n}\n```\nRemember that it is only an example and you should consider your app's requirements and limitations.",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/threads/messages.mdx",
        "type": "mdx",
        "chunkIndex": 1,
        "headers": [
          "Define structure"
        ],
        "title": "Define structure",
        "codeBlocks": [
          "``` json title=\"JSON\"\n{\n   “data”:{\n     “content”: \"string\", // string / binary data containing for example: markdown, html or json\n   },\n   “info”: \"ServerInfo\", // assigned by server,\n   “publicMeta”:{\n     “version”:number,\n     “type”: “text”, // some kind of enum describing type of message like “event”, “html”,“markdown” etc.\n   },\n   “privateMeta”:{\n     // meta fields\n   }\n}\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.865Z",
        "size": 963
      }
    },
    {
      "pageContent": "## Sending\n\nWith the structure ready, its time to start sending messages.\n\n:::info\n\nRemember that before sending anything, you have to be connected to the Bridge - using `connect`.\n\n:::\n\n<Tabs groupId=\"lang\" items={[\"JavaScript\",\"Java\",\"Kotlin\",\"Swift\"]}>\n\n    <Tab >\n        ```js\n        const msgId = await Endpoint.connection().thread('THREAD_ID').sendMessage({\n        data: new TextEncoder().encode('My message'),\n        privateMeta: new TextEncoder().encode('My private data'),\n        publicMeta: serializeObject({\n        type: 'type_of_message'\n    })\n    });",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/threads/messages.mdx",
        "type": "mdx",
        "chunkIndex": 2,
        "headers": [
          "Sending"
        ],
        "title": "Sending",
        "lastModified": "2025-06-05T19:33:57.865Z",
        "size": 570
      }
    },
    {
      "pageContent": "```\n\n    </Tab>\n    <Tab >\n        ```java\n        PrivmxEndpointContainer container = new PrivmxEndpointContainer();\n        Long connectionID = 0L; // your connection ID\n        String threadId = \"<THREAD_ID>\";\n\n        byte[] privateMeta = \"My private meta\".getBytes(StandardCharsets.UTF_8);\n        byte[] publicMeta = \"My public meta\".getBytes(StandardCharsets.UTF_8);\n        byte[] message = \"My message\".getBytes(StandardCharsets.UTF_8);\n\n        String msgId = container.getEndpoint(connectionID).threadApi.sendMessage(\n        threadId,\n        publicMeta,\n        privateMeta,\n        message\n        );\n        ```\n    </Tab>\n    <Tab >\n        ```kotlin\n        val container = PrivmxEndpointContainer()\n        val connectionID = 0L // your connection ID\n        val threadId = \"<THREAD_ID>\"\n\n        val privateMeta = \"My private data\".encodeToByteArray()\n        val publicMeta = \"My public data\".encodeToByteArray()\n        val message = \"This is my message\".encodeToByteArray()\n\n        val msgId = container.getEndpoint(connectionID).threadApi.sendMessage(\n        threadId,\n        publicMeta,\n        privateMeta,\n        message\n        )\n        ```\n    </Tab>\n    <Tab >",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/threads/messages.mdx",
        "type": "mdx",
        "chunkIndex": 3,
        "codeBlocks": [
          "```\n\n    </Tab>\n    <Tab >\n        ```",
          "```\n    </Tab>\n    <Tab >\n        ```"
        ],
        "lastModified": "2025-06-05T19:33:57.865Z",
        "size": 1194
      }
    },
    {
      "pageContent": "val msgId = container.getEndpoint(connectionID).threadApi.sendMessage(\n        threadId,\n        publicMeta,\n        privateMeta,\n        message\n        )\n        ```\n    </Tab>\n    <Tab >\n\n        ```swift\n        let threadId: String; // ID of thread taken from threadApi.threadList\n\n        //for now we can leave them empty\n        let privateMeta = Data(\"My private data\".utf8)\n        let publicMeta = Data(\"My public data\".utf8)\n\n        let message = Data(\"This is my message\".utf8)\n\n        let msgId: String = threadApi.sendMessage(\n        in: threadId,\n        publicMeta: publicMeta,\n        privateMeta: privateMeta,\n        data: message)\n        ```\n    </Tab>\n</Tabs>\n\n\nAfter sending the message, you will get its ID returned.\n\nMessage IDs are unique within a Context, allowing you to locate a message solely by its ID, without the need to know the associated Thread ID.",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/threads/messages.mdx",
        "type": "mdx",
        "chunkIndex": 4,
        "codeBlocks": [
          "```\n    </Tab>\n    <Tab >\n\n        ```"
        ],
        "lastModified": "2025-06-05T19:33:57.865Z",
        "size": 888
      }
    },
    {
      "pageContent": "## Using Message Metadata\n\nMetadata fields inside messages make it easier to integrate Threads into new and existing projects.\nThreads are scheme agnostic by design, which makes them easy to integrate into any application.\nMetadata also allows developers to add any functionalities required by their app.\n\n### PrivateMeta\n\n`privateMeta` includes additional sensitive information about the message.\nIt's useful when we need to include the user's private data (personal information, activity details) in the message.\n\nLike the content of the message itself, `privateMeta` is **encrypted** before sending. Since it is saved as binary data, you are free to choose any format.\nIt can be a JSON parsed to a binary array or a more efficient binary format such as Protocol Buffers.\n\n### PublicMeta\n\nUnlike `privateMeta`, `publicMeta` is **not encrypted**.\nIt's useful when you want to include some additional info that does not require encryption.\n\n`publicMeta` also does not have a specified structure and supports any binary format.",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/threads/messages.mdx",
        "type": "mdx",
        "chunkIndex": 5,
        "headers": [
          "Using Message Metadata",
          "PrivateMeta",
          "PublicMeta"
        ],
        "title": "Using Message Metadata",
        "lastModified": "2025-06-05T19:33:57.865Z",
        "size": 1026
      }
    },
    {
      "pageContent": "### Example: Response To Another Message\n\nLet's say that you need to implement replies to other messages inside a Thread using `publicMeta`.\n\nWhen sending a message, include the ID of the message you want to reply to.\nExpanding on the example from the section on sending, it would look like that:\n\n``` json title=\"JSON\"\n{\n   \"data\":{\n     \"content\": \"string\" // string / binary data containing for example: markdown, html or json\n   },\n   \"info\": \"ServerInfo\", // assigned by server,\n   \"publicMeta\":{\n     \"version\":\"number\",\n     \"type\": “text”, // some kind of enum describing type of message like “event”, “html”,“markdown” etc.\n     \"responseTo\":”{messageID}”\n   },\n}\n```\n\nWhen displaying the message in a chat, you will be able to find the message that was mentioned and display it according to the application's requirements.",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/threads/messages.mdx",
        "type": "mdx",
        "chunkIndex": 6,
        "headers": [
          "Example: Response To Another Message"
        ],
        "title": "Example: Response To Another Message",
        "codeBlocks": [
          "``` json title=\"JSON\"\n{\n   \"data\":{\n     \"content\": \"string\" // string / binary data containing for example: markdown, html or json\n   },\n   \"info\": \"ServerInfo\", // assigned by server,\n   \"publicMeta\":{\n     \"version\":\"number\",\n     \"type\": “text”, // some kind of enum describing type of message like “event”, “html”,“markdown” etc.\n     \"responseTo\":”{messageID}”\n   },\n}\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.865Z",
        "size": 832
      }
    },
    {
      "pageContent": "---\ntitle: Overview\n---\n\nThread container is a structured communication tool used for **message based communication**. \n\nUsers create Threads to organize topic-specific conversations where they can securely **exchange encrypted messages** with designated participants.\nAll the active users are **notified** right away when a new message arrives or anything within the Thread changes. \n\nAll the data is stored in [PrivMX Bridge](../privmx-bridge) and can be freely shared between its users.\n\n## Prerequisites\n\nBefore working with Threads, you need to have a PrivMX Bridge instance.\n\nTo install it, [follow our PrivMX quick start guide](../quick-start).",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/threads/overview.mdx",
        "type": "mdx",
        "chunkIndex": 0,
        "headers": [
          "Prerequisites"
        ],
        "title": "Prerequisites",
        "lastModified": "2025-06-05T19:33:57.866Z",
        "size": 651
      }
    },
    {
      "pageContent": "## Prerequisites\n\nBefore working with Threads, you need to have a PrivMX Bridge instance.\n\nTo install it, [follow our PrivMX quick start guide](../quick-start).\n\n## Architecture\n\nThreads are time-sorted containers for messages. Think of a Thread as a container that allows you to **post messages, which can include any binary or text data as well as metadata.**\nEach Thread has its own set of permissions, managed by assigning the users’ public keys to the Thread. **Only the users with assigned public keys can read the messages posted in that Thread.**\nDecryption of these messages is possible only with the corresponding private keys. \n\n**Each message is protected by a synchronous key, which is further secured using an asynchronous pair of public and private user keys.**\nThis dual-layer encryption ensures that the system remains both safe and efficient.\n\n[Learn more](./encryption) about our advanced encryption methods and how they safeguard your messages.\n\nThe following diagram is a visual reference for the architecture of Threads:\n!![threads architecture](/img/privmx-threads.svg)",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/threads/overview.mdx",
        "type": "mdx",
        "chunkIndex": 1,
        "headers": [
          "Prerequisites",
          "Architecture"
        ],
        "title": "Prerequisites",
        "lastModified": "2025-06-05T19:33:57.866Z",
        "size": 1092
      }
    },
    {
      "pageContent": "## Messages in Threads\n\nThe main data units in Threads are messages, which contain binary `data`, as well as metadata\n\n- `privateMeta` - encrypted data about the message\n- `publicMeta` - **decrypted** additional data about the message\n\nEach message also has information assigned by the Bridge.\n\nTo learn more about messages, go to [Sending Messages](./messages).\n\n### Examples\n- Chatee\n  A demo project of Chat Application, containing server-side logic and web client. Created with Next.js.\n\n  [Github](https://github.com/simplito/privmx-chatee)\n\n- Simple, minimal examples\n  A set of short code snippets showing you how to start interacting with PrivMX Endpoint Library.\n\n  [Github](https://github.com/simplito/privmx-webendpoint/tree/main/examples)",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/threads/overview.mdx",
        "type": "mdx",
        "chunkIndex": 2,
        "headers": [
          "Messages in Threads",
          "Examples"
        ],
        "title": "Messages in Threads",
        "lastModified": "2025-06-05T19:33:57.866Z",
        "size": 750
      }
    },
    {
      "pageContent": "---\ntitle: Downloading Files\n---\n\n      Tabs, Tab} from \"fumadocs-ui/components/tabs\"\n\n:::info\n\nThe sample code on this page is based on the same **[assumptions](./managing#initial-assumptions)** mentioned in [Managing Stores](./managing).\n\n:::\n\nThe code example below shows how to download a file from a Store in PrivMX:\n<Tabs groupId=\"lang\" items={[\"cpp\",\"js\",\"java\",\"kotlin\",\"swift\"]}>\n<Tab value=\"cpp\" label=\"C++\">\n```cpp\n\t// read large file chunk-by-chunk\n\tauto bFileInfo {storesApi.getFile(binaryFileId)};\n\tauto bHandle {storesApi.openFile(binaryFileId)};\n\tsize_t read = 0;\n\twhile (read < bFileInfo.size) {\n\t\tauto data {storesApi.readFromFile(bHandle, 1024)};\n\t\tread += data.size();\n\t\tstd::cout << \"Read (from store) \" << read << \" out of: \" << bFileInfo.size << std::endl;\n\t}\n\tstoresApi.closeFile(bHandle);\n```\n</Tab>\n\n<Tab label=\"JavaScript\" value=\"js\">\n```js\n    // read file contents of the file added to the Store\n    const fileInfo = await storesApi.getFile(fileId);\n\n    const fileHandle = await storesApi.openFile(fileId);\n    const data = await storesApi.readFromFile(fileHandle, fileInfo.size);\n    await storesApi.closeFile(fileHandle);",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/stores/downloading-files.mdx",
        "type": "mdx",
        "chunkIndex": 0,
        "codeBlocks": [
          "```cpp\n\t// read large file chunk-by-chunk\n\tauto bFileInfo {storesApi.getFile(binaryFileId)};\n\tauto bHandle {storesApi.openFile(binaryFileId)};\n\tsize_t read = 0;\n\twhile (read < bFileInfo.size) {\n\t\tauto data {storesApi.readFromFile(bHandle, 1024)};\n\t\tread += data.size();\n\t\tstd::cout << \"Read (from store) \" << read << \" out of: \" << bFileInfo.size << std::endl;\n\t}\n\tstoresApi.closeFile(bHandle);\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.866Z",
        "size": 1153
      }
    },
    {
      "pageContent": "const fileHandle = await storesApi.openFile(fileId);\n    const data = await storesApi.readFromFile(fileHandle, fileInfo.size);\n    await storesApi.closeFile(fileHandle);\n\n    console.log(\"File meta\\n public: \", this.uint8ToStr(fileInfo.publicMeta));\n    console.log(\"private: \", this.uint8ToStr(fileInfo.privateMeta));\n    console.log(\"data: \", this.uint8ToStr(data));\n\n```\n</Tab>\n\n<Tab label=\"Java\" value=\"java\">\n```java\nPrivmxEndpointContainer container = new PrivmxEndpointContainer();\nLong connectionID = 0L; // your connection ID\nStoreApi storeApi = container.getEndpoint(connectionID).storeApi;\nString fileId = \"<YOUR_FILE_ID>\";\n\nStoreFileStream.Controller controller = new StoreFileStream.Controller(){\n    @Override\n    public void onChunkProcessed(Long processedBytes) {\n        System.out.println(\"Downloaded bytes: \" + processedBytes);\n    }\n};\n\ntry(OutputStream oS = new FileOutputStream(\"<PATH_TO_FILE>\")) {\n    StoreFileStreamReader.openFile(\n            storeApi,\n            fileId,\n            oS,\n            controller\n    );\n}catch (Exception e){\n    System.out.println(\"Cannot download file: \" + e.getMessage());\n}\n```\n</Tab>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/stores/downloading-files.mdx",
        "type": "mdx",
        "chunkIndex": 1,
        "codeBlocks": [
          "```\n</Tab>\n\n<Tab label=\"Java\" value=\"java\">\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.866Z",
        "size": 1146
      }
    },
    {
      "pageContent": "<Tab label=\"Kotlin\" value=\"Kotlin\">\n```kotlin\nval container = PrivmxEndpointContainer()\nval connectionID = 0L // your connection ID\nval storeApi = container.getEndpoint(connectionID).storeApi\nval fileId = \"<YOUR_FILE_ID>\"\n\nval controller: StoreFileStream.Controller = object : StoreFileStream.Controller() {\n    override fun onChunkProcessed(processedBytes: Long) {\n        println(\"Downloaded bytes: $processedBytes\")\n    }\n}\n\nFileOutputStream(\"<PATH_TO_FILE>\").use { oS ->\n    StoreFileStreamReader.openFile(\n        storeApi,\n        fileId,\n        oS,\n        controller\n    )\n}\n```\n</Tab>\n\n\n<Tab label=\"Swift\" value=\"swift\">\n```swift\nvar fileId = \"FILE_ID\"\nguard let privMXEndpoint =  endpointContainer.getEndpoint(connectionId) else {return}\nif let api = privMXEndpoint.storeApi{\n    guard let size = try? api.getFile(fileId).size else {return}\n    guard let handle = try? api.openFile(fileId) else {return}\n    guard let data = try? api.readFromFile(withHandle: handle,\n                                    length: size) else {return}\n    _ = try? api.closeFile(withHandle: handle)\n}\n```\n</Tab>\n</Tabs>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/stores/downloading-files.mdx",
        "type": "mdx",
        "chunkIndex": 2,
        "codeBlocks": [
          "```kotlin\nval container = PrivmxEndpointContainer()\nval connectionID = 0L // your connection ID\nval storeApi = container.getEndpoint(connectionID).storeApi\nval fileId = \"<YOUR_FILE_ID>\"\n\nval controller: StoreFileStream.Controller = object : StoreFileStream.Controller() {\n    override fun onChunkProcessed(processedBytes: Long) {\n        println(\"Downloaded bytes: $processedBytes\")\n    }\n}\n\nFileOutputStream(\"<PATH_TO_FILE>\").use { oS ->\n    StoreFileStreamReader.openFile(\n        storeApi,\n        fileId,\n        oS,\n        controller\n    )\n}\n```",
          "```swift\nvar fileId = \"FILE_ID\"\nguard let privMXEndpoint =  endpointContainer.getEndpoint(connectionId) else {return}\nif let api = privMXEndpoint.storeApi{\n    guard let size = try? api.getFile(fileId).size else {return}\n    guard let handle = try? api.openFile(fileId) else {return}\n    guard let data = try? api.readFromFile(withHandle: handle,\n                                    length: size) else {return}\n    _ = try? api.closeFile(withHandle: handle)\n}\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.866Z",
        "size": 1109
      }
    },
    {
      "pageContent": "---\ntitle: Encryption\n---\n\n\n## Encryption in Stores\n\nEach file is protected by a synchronous key, which is further secured using an asynchronous pair of public and private user keys. \nThis dual-layer encryption ensures that the system remains both safe and efficient.\n\n## Encryption Scenario\n\nOnly an end user can create a Store, by providing a set of public keys for the users who should have access to the Store.\n\nA symmetric key for the Store (Store Encryption Key) is then **generated by the Store author/owner** and securely stored on the server, encrypted using public keys of **users assigned to the Store**. \nThis ensures that only the authorized users have access to the Store's Encryption Key. **Unencrypted keys never leave user Endpoints.**\n\nWhen accessing a Store, the encrypted Store Encryption Key is sent to each user based on their assignment to the Store. Only the users with proper Private Keys can decrypt Store Encryption Key. \nUsing the decrypted key, messages are encrypted and signed with the users’ Private Keys before being sent to the Bridge.  \n\nThis process is handled by PrivMX Endpoint and is completely seamless for the users.",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/stores/encryption.mdx",
        "type": "mdx",
        "chunkIndex": 0,
        "headers": [
          "Encryption in Stores",
          "Encryption Scenario"
        ],
        "title": "Encryption in Stores",
        "lastModified": "2025-06-05T19:33:57.867Z",
        "size": 1157
      }
    },
    {
      "pageContent": "---\ntitle: Managing Files\n---\n\n\n\n\nStores allow you to exchange and save files. In this section, we'll take a closer look at file structures and how to manage them effectively. We'll also cover some best practices when working with Stores.\n\n## About Files\n\nAlong with a file's main content, additional **metadata** is stored to allow easy file management. Below is the structure of the metadata associated with each file:\n\n|**field**|**type**|**encrypted**|**description**|\n|---|---|---|---|\n|`info`|ServerFileInfo|yes|additional information assigned by the server e.g. author, `creationDate`, `storeID` and `fileID`\n|`publicMeta`|binary|no|additional public information about the message, also accessible through Bridge API\n|`privateMeta`|binary|yes|additional information about the message\n|`size`|number|yes|The size of file in getBytes\n|`authorPubKey`|string|yes|The public key of the author of the file\n|`statusCode`|number|no|0 if the file was decrypted successfully",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/stores/handling-files.mdx",
        "type": "mdx",
        "chunkIndex": 0,
        "headers": [
          "About Files"
        ],
        "title": "About Files",
        "lastModified": "2025-06-05T19:33:57.867Z",
        "size": 971
      }
    },
    {
      "pageContent": "## Listing Files\n\n:::info\n\nThe sample code on this page is based on the same **[assumptions](./managing#initial-assumptions)** mentioned in [Managing Stores](./managing).\n\n:::\n\nHere's how you can retrieve and list files from a Store:\n\n<Tabs groupId=\"lang\" items={[\"cpp\",\"js\",\"java\",\"kotlin\",\"swift\"]}>\n<Tab value=\"cpp\" label=\"C++\">\n```cpp\n    core::PagingQuery query = {.skip = 0, .limit = 30, .sortOrder = \"desc\"};\n\n\t// list files of the Store specified by storeId\n\tauto filesResult {storesApi.listFiles(storeId, query)};\n\tfor (auto file: filesResult.readItems) {\n        std::cout << \"File ID: \" << file.info.fileId << std::endl;\n        std::cout << \"File size: \" << file.size << std::endl;\n    }\n```\n</Tab>\n\n<Tab label=\"JavaScript\" value=\"js\">\n\n```js\n    const filesResult = await storesApi.listFiles(storeId, query);\n    for (const f of filesResult.readItems) {\n        console.log(\"File ID: \", f.info.fileId);\n        console.log(\"File public meta: \", this.uint8ToStr(f.publicMeta));\n        console.log(\"File private meta: \", this.uint8ToStr(f.privateMeta));\n    }\n```\n</Tab>\n\n<Tab label=\"Java\" value=\"java\">",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/stores/handling-files.mdx",
        "type": "mdx",
        "chunkIndex": 1,
        "headers": [
          "Listing Files"
        ],
        "title": "Listing Files",
        "codeBlocks": [
          "```cpp\n    core::PagingQuery query = {.skip = 0, .limit = 30, .sortOrder = \"desc\"};\n\n\t// list files of the Store specified by storeId\n\tauto filesResult {storesApi.listFiles(storeId, query)};\n\tfor (auto file: filesResult.readItems) {\n        std::cout << \"File ID: \" << file.info.fileId << std::endl;\n        std::cout << \"File size: \" << file.size << std::endl;\n    }\n```",
          "```js\n    const filesResult = await storesApi.listFiles(storeId, query);\n    for (const f of filesResult.readItems) {\n        console.log(\"File ID: \", f.info.fileId);\n        console.log(\"File public meta: \", this.uint8ToStr(f.publicMeta));\n        console.log(\"File private meta: \", this.uint8ToStr(f.privateMeta));\n    }\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.867Z",
        "size": 1115
      }
    },
    {
      "pageContent": "<Tab label=\"Java\" value=\"java\">\n\n```java\nPrivmxEndpointContainer container = new PrivmxEndpointContainer();\nLong connectionID = 0L; // your connection ID\nString storeID = \"<STORE_ID>\";\n\nlong limit = 30L;\nlong skip = 0L;\n\nPagingList<File> files = container.getEndpoint(connectionID).storeApi.listFiles(\n        storeID,\n        skip,\n        limit,\n        SortOrder.DESC\n);\n```\n</Tab>\n\n\n<Tab label=\"Kotlin\" value=\"kotlin\">\n\n```kotlin\nval container = PrivmxEndpointContainer()\nval connectionID = 0L // your connection ID\nval storeID = \"<STORE_ID>\"\n\nval limit = 30L\nval skip = 0L\n\nval files = container.getEndpoint(connectionID).storeApi.listFiles(\n    storeID,\n    skip,\n    limit,\n    SortOrder.DESC\n)\n```\n</Tab>\n\n<Tab label=\"Swift\" value=\"swift\">\n\n```ts\nconst files = await Endpoint.connection().store(STORE_ID).getFiles(0, {\n  pageSize: 100,\n  sort: 'desc',\n})\n\n```\n</Tab>\n</Tabs>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/stores/handling-files.mdx",
        "type": "mdx",
        "chunkIndex": 2,
        "codeBlocks": [
          "```java\nPrivmxEndpointContainer container = new PrivmxEndpointContainer();\nLong connectionID = 0L; // your connection ID\nString storeID = \"<STORE_ID>\";\n\nlong limit = 30L;\nlong skip = 0L;\n\nPagingList<File> files = container.getEndpoint(connectionID).storeApi.listFiles(\n        storeID,\n        skip,\n        limit,\n        SortOrder.DESC\n);\n```",
          "```kotlin\nval container = PrivmxEndpointContainer()\nval connectionID = 0L // your connection ID\nval storeID = \"<STORE_ID>\"\n\nval limit = 30L\nval skip = 0L\n\nval files = container.getEndpoint(connectionID).storeApi.listFiles(\n    storeID,\n    skip,\n    limit,\n    SortOrder.DESC\n)\n```",
          "```ts\nconst files = await Endpoint.connection().store(STORE_ID).getFiles(0, {\n  pageSize: 100,\n  sort: 'desc',\n})\n\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.867Z",
        "size": 882
      }
    },
    {
      "pageContent": "## Deleting Files\n\nDeleting a file is straightforward, but be aware that this action is irreversible:\n\n\n<Tabs groupId=\"lang\"  items={[\"cpp\",\"js\",\"java\",\"kotlin\",\"swift\"]}>\n<Tab value=\"cpp\" label=\"C++\">\n```cpp\n\t// deleting file specified by fileId\n\tstoresApi.deleteFile(fileId);\n```\n</Tab>\n<Tab label=\"JavaScript\" value=\"js\">\n\n```js\n    // delete the file\n    await storesApi.deleteFile(fileId);\n```\n</Tab>\n\n<Tab label=\"Java\" value=\"java\">\n\n```java\nPrivmxEndpointContainer container = new PrivmxEndpointContainer();\nLong connectionID = 0L; // your connection ID\nString fileID = \"<YOUR_FILE_ID>\";\ncontainer.getEndpoint(connectionID).storeApi.deleteFile(fileID);\n```\n</Tab>\n\n\n<Tab label=\"Kotlin\" value=\"kotlin\">\n\n```kotlin\nval container = PrivmxEndpointContainer()\nval connectionID = 0L // your connection ID\nval fileID = \"<YOUR_FILE_ID>\"\ncontainer.getEndpoint(connectionID).storeApi.deleteFile(fileID)\n```\n</Tab>\n\n<Tab label=\"Swift\" value=\"swift\">\n\n```ts\nawait Endpoint.connection().stores.deleteFile(FILE_ID);\n\n```\n</Tab>\n</Tabs>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/stores/handling-files.mdx",
        "type": "mdx",
        "chunkIndex": 3,
        "headers": [
          "Deleting Files"
        ],
        "title": "Deleting Files",
        "codeBlocks": [
          "```cpp\n\t// deleting file specified by fileId\n\tstoresApi.deleteFile(fileId);\n```",
          "```js\n    // delete the file\n    await storesApi.deleteFile(fileId);\n```",
          "```java\nPrivmxEndpointContainer container = new PrivmxEndpointContainer();\nLong connectionID = 0L; // your connection ID\nString fileID = \"<YOUR_FILE_ID>\";\ncontainer.getEndpoint(connectionID).storeApi.deleteFile(fileID);\n```",
          "```kotlin\nval container = PrivmxEndpointContainer()\nval connectionID = 0L // your connection ID\nval fileID = \"<YOUR_FILE_ID>\"\ncontainer.getEndpoint(connectionID).storeApi.deleteFile(fileID)\n```",
          "```ts\nawait Endpoint.connection().stores.deleteFile(FILE_ID);\n\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.867Z",
        "size": 1028
      }
    },
    {
      "pageContent": "---\ntitle: Instant Store Events\n---\n\n      Tabs, Tab} from \"fumadocs-ui/components/tabs\"\n\nEvents play a crucial role in modern applications, allowing them to instantly respond to changes in stored data. Monitoring and reacting to file and store-related events, such as the creation, modification, or deletion of files, is essential for maintaining up-to-date records, triggering workflows, and ensuring synchronization across various parts of the system.\n\n## Types of Events\n\nStore events:\n\n- `storeCreated` - triggers when a new Store is created in your Context\n- `storeDeleted` - triggers when a Store is deleted from your Context\n- `storeUpdated` - triggers when a Store is updated in your Context\n- `storeStatsChanged` - triggers when a file is created or deleted from a Store\n\nFile events: \n- `storeFileCreated` - triggers when a file is uploaded to a Store\n- `storeFileDeleted` - triggers when a file is deleted from a Store\n- `storeFileUpdated` - triggers when a file is updated in a Store",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/stores/instant-updating.mdx",
        "type": "mdx",
        "chunkIndex": 0,
        "headers": [
          "Types of Events"
        ],
        "title": "Types of Events",
        "lastModified": "2025-06-05T19:33:57.867Z",
        "size": 996
      }
    },
    {
      "pageContent": "## Handling Store Events\n\n:::info\n\nThe sample code on this page is based on the same **[assumptions](./managing#initial-assumptions)** mentioned in [Managing Stores](./managing).\n\n:::\n\nBefore receiving Events, your application must first start an event loop and subscribe to a specific channel.\nAfterwards you can setup a listener.\n\nHere is an example of how to do it in your own project:\n\n<Tabs groupId=\"lang\" items={[\"cpp\",\"js\",\"java\",\"kotlin\",\"swift\"]}>\n<Tab value=\"cpp\" label=\"C++\">\n```cpp\n\t// handle events\n\tcore::EventQueue eventQueue {core::EventQueue::getInstance()};\n\tstd::thread t([&](){\n\t\twhile(true) {\n\t\t\tcore::EventHolder event = eventQueue.waitEvent();\n\t\t\tstd::cout << \"onEvent: \" << event.type() << std::endl;\n\t\t\tstd::cout << event.toJSON() << std::endl;\n\t\t}\n    });\n\tt.detach();\n\n\t// subscribe for Stores general events\n\tstoresApi.subscribeForStoreEvents();",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/stores/instant-updating.mdx",
        "type": "mdx",
        "chunkIndex": 1,
        "headers": [
          "Handling Store Events"
        ],
        "title": "Handling Store Events",
        "lastModified": "2025-06-05T19:33:57.867Z",
        "size": 873
      }
    },
    {
      "pageContent": "// subscribe for Stores general events\n\tstoresApi.subscribeForStoreEvents();\n\n\t// subscribe for particular Store events\n\tstoresApi.subscribeForFileEvents(storeId);\n```\n</Tab>\n<Tab value=\"js\" label=\"JavaScript\">\nStarting the Event Loop\n```js\n    listenForEvents(eventsQueue) {\n        eventsQueue.waitEvent().then(event => {\n            console.log(\"onEvent\", event);\n            this.listenForEvents(eventsQueue);\n        });\n    }\n    // ...\n    run() {\n        // ...\n        \n        // handle events\n        const eventQueue = await Endpoint.getEventQueue();\n        this.listenForEvents(eventQueue);\n        // ...\n\n        // subscribe for Stores general events\n        await threadsApi.subscribeForStoreEvents();\n        // ...\n\n        // subscribe for particular Store events\n        await threadsApi.subscribeForFileEvents(storeId);\n    }",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/stores/instant-updating.mdx",
        "type": "mdx",
        "chunkIndex": 2,
        "codeBlocks": [
          "```\n</Tab>\n<Tab value=\"js\" label=\"JavaScript\">\nStarting the Event Loop\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.867Z",
        "size": 848
      }
    },
    {
      "pageContent": "```\n\n</Tab>\n<Tab value=\"java\" label=\"Java\">\n```java\nPrivmxEndpointContainer container = new PrivmxEndpointContainer();\nLong connectionID = 0L; // your connection ID\nString callbacksID = \"<YOUR_CALLBACK_ID>\";\nString storeID = \"<YOUR_STORE_ID\";\n// Starting the Event Loop\ncontainer.startListening();\n\n// Handling Store Events\ncontainer.getEndpoint(connectionID).registerCallback(\n        callbacksID,\n        EventType.StoreCreatedEvent,\n        newStore -> {\n            System.out.println(newStore.storeId);\n        }\n);\n\n// Handling File Events\ncontainer.getEndpoint(connectionID).registerCallback(\n        callbacksID,\n        EventType.StoreFileCreatedEvent(storeID),\n        newFile -> {\n            System.out.println(newFile.info.fileId);\n        }\n);\n```\n</Tab>\n\n<Tab value=\"kotlin\" label=\"Kotlin\">\n```kotlin\nval container = PrivmxEndpointContainer()\nval connectionID = 0L // your connection ID\nval callbacksID = \"<YOUR_CALLBACK_ID>\"\nval storeID = \"<YOUR_STORE_ID\"\n// Starting the Event Loop\ncontainer.startListening()",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/stores/instant-updating.mdx",
        "type": "mdx",
        "chunkIndex": 3,
        "codeBlocks": [
          "```\n\n</Tab>\n<Tab value=\"java\" label=\"Java\">\n```",
          "```\n</Tab>\n\n<Tab value=\"kotlin\" label=\"Kotlin\">\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.867Z",
        "size": 1025
      }
    },
    {
      "pageContent": "// Handling Store Events\ncontainer.getEndpoint(connectionID).registerCallback(\n    callbacksID,\n    EventType.StoreCreatedEvent\n) { newStore ->\n    println(newStore.storeId)\n}\n\n// Handling File Events\ncontainer.getEndpoint(connectionID).registerCallback(\n    callbacksID,\n    EventType.StoreFileCreatedEvent(storeID)\n) { newFile ->\n    println(newFile.info.fileId)\n}\n```\n</Tab>\n<Tab value=\"swift\" label=\"Swift\">\n\n```swift\nguard let privMXEndpoint =  endpointContainer.getEndpoint(connectionId) else {return}\nlet connectionId = \"CONNECTION_ID\"\nlet storeId = \"STORE_ID\"\n\n_ = try privMXEndpoint.registerCallback(\n    for: privmx.endpoint.store.StoreFileUpdatedEvent.self,\n    from: .storeFiles(storeID: storeId), identified: \"\",\n    { eventData in\n        // some actions when file updated\n    })\n_ = try privMXEndpoint.registerCallback(\n    for: privmx.endpoint.store.StoreCreatedEvent.self,\n    from: .store, identified: \"\",\n    { eventData in\n        // some actions when new store created\n    })\n    \n```\n</Tab>\n</Tabs>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/stores/instant-updating.mdx",
        "type": "mdx",
        "chunkIndex": 4,
        "codeBlocks": [
          "```\n</Tab>\n<Tab value=\"swift\" label=\"Swift\">\n\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.867Z",
        "size": 1020
      }
    },
    {
      "pageContent": "---\ntitle: Managing Stores\n---\n      Tabs, Tab} from \"fumadocs-ui/components/tabs\"\n\nAt the core, Stores provide a secure way for assigned members to upload encrypted files.\n\n- Stores allow users to upload files to separate file containers.\n- Each [Context](../architecture#contexts) can contain any number of Stores with a unique identifier (`storeId`) used to distinguish them.\n- Stores do not need to have unique names or assigned public keys.\n\n## Permissions\n\nStores differentiate two types of users: Managers and Regular Users. The table below shows the differences in their permissions:\n\n|**Activity**|**User**|**Manager**|\n|---|---|---|\n|Uploading files|yes|yes|\n|Editing files|yes|yes|\n|Editing Store|no|yes|\n|Deleting files|only their own|all files|\n\nThe values above are the default policy values defined by PrivMX. To read more about Policies and learn how to modify them, go to [Policies](../concepts/policies).",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/stores/managing.mdx",
        "type": "mdx",
        "chunkIndex": 0,
        "headers": [
          "Permissions"
        ],
        "title": "Permissions",
        "lastModified": "2025-06-05T19:33:57.868Z",
        "size": 922
      }
    },
    {
      "pageContent": "## Initial Assumptions\nThe initial assumptions for all the code examples below are as follows:\n<Tabs groupId=\"lang\" items={[\"cpp\",\"js\",\"java\",\"kotlin\",\"swift\"]}>\n\n<Tab value=\"cpp\" label=\"C++\">\n```cpp\n    #include <privmx/endpoint/core/Connection.hpp>\n    #include <privmx/endpoint/store/StoreApi.hpp>\n    #include <privmx/endpoint/core/Buffer.hpp>\n    // ...\n\n\t/* \n\tAll the values below like BRIDGE_URL, SOLUTION_ID, CONTEXT_ID \n\tshould be replaced by the ones corresponding to your Bridge Server instance.\n\t\n\tThe private keys here are for demonstration purposes only. \n\tNormally, they should be kept separately by each user and stored in a safe place,\n\tor generated from a password (see the derivePrivateKey() method in the Crypto API)\n\t*/\n\n\tstd::string BRIDGE_URL {\"http://localhost:9111\"};\n\tstd::string SOLUTION_ID {\"YOUR_SOLUTION_ID\"};\n\tstd::string CONTEXT_ID {\"YOUR_CONTEXT_ID\"};\n\n\tstd::string USER1_ID {\"user_1\"};\n\tstd::string USER1_PUBLIC_KEY {\"PUBLIC_KEY_1\"};\n\tstd::string USER1_PRIV {\"PRIVATE_KEY_1\"};\n\n\tstd::string USER2_ID {\"user_2\"};\n\tstd::string USER2_PUBLIC_KEY {\"PUBLIC_KEY_2\"};\n\n\tstd::string USER3_ID {\"user_3\"};\n\tstd::string USER3_PUBLIC_KEY {\"PUBLIC_KEY_3\"};",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/stores/managing.mdx",
        "type": "mdx",
        "chunkIndex": 1,
        "headers": [
          "Initial Assumptions"
        ],
        "title": "Initial Assumptions",
        "lastModified": "2025-06-05T19:33:57.868Z",
        "size": 1176
      }
    },
    {
      "pageContent": "std::string USER2_ID {\"user_2\"};\n\tstd::string USER2_PUBLIC_KEY {\"PUBLIC_KEY_2\"};\n\n\tstd::string USER3_ID {\"user_3\"};\n\tstd::string USER3_PUBLIC_KEY {\"PUBLIC_KEY_3\"};\n\n    // initialize Endpoint connection and Threads API\n\tauto connection {core::Connection::connect(USER1_PRIV, SOLUTION_ID, BRIDGE_URL)};\n\tauto storesApi {store::StoreApi::create(connection)};\n```\n</Tab>\n\n<Tab value=\"js\" label=\"JavaScript\">\n```js\n    /* \n    All the values below like BRIDGE_URL, SOLUTION_ID, CONTEXT_ID \n    should be replaced by the ones corresponding to your Bridge Server instance.\n    \n    The private keys here are for demonstration purposes only. \n    Normally, they should be kept separately by each user and stored in a safe place,\n    or generated from a password (see the derivePrivateKey() method in the Crypto API)\n    */\n\n    const BRIDGE_URL = \"http://localhost:9111\";\n    const SOLUTION_ID = \"YOUR_SOLUTION_ID\";\n    const CONTEXT_ID = \"YOUR_CONTEXT_ID\";\n\n    const USER1_ID = \"user_1\";\n    const USER1_PUBLIC_KEY = \"PUBLIC_KEY_1\";\n    const USER1_PRIV = \"PRIVATE_KEY_1\";\n\n    const USER2_ID = \"user_2\";\n    const USER2_PUBLIC_KEY = \"PUBLIC_KEY_2\";",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/stores/managing.mdx",
        "type": "mdx",
        "chunkIndex": 2,
        "codeBlocks": [
          "```\n</Tab>\n\n<Tab value=\"js\" label=\"JavaScript\">\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.868Z",
        "size": 1144
      }
    },
    {
      "pageContent": "const USER1_ID = \"user_1\";\n    const USER1_PUBLIC_KEY = \"PUBLIC_KEY_1\";\n    const USER1_PRIV = \"PRIVATE_KEY_1\";\n\n    const USER2_ID = \"user_2\";\n    const USER2_PUBLIC_KEY = \"PUBLIC_KEY_2\";\n\n    const USER3_ID = \"user_3\";\n    const USER3_PUBLIC_KEY = \"PUBLIC_KEY_3\";\n\n\n    class App {\n        uint8ToStr(arr) {\n            return (new TextDecoder()).decode(arr);\n        }\n\n        strToUint8(text) {\n            return (new TextEncoder()).encode(text);\n        }\n\n        // ...\n\n        run() {\n            // Initialize Endpoint and its Wasm assets\n            await Endpoint.setup(\"/public\");\n\n            // initialize Endpoint connection and Threads API\n            const connection = await Endpoint.connect(USER1_PRIV, SOLUTION_ID, BRIDGE_URL);\n            const storesApi = await Endpoint.createStoreApi(connection);\n\n            // ...\n        }\n    }\n    new App().run();\n\n```\n</Tab>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/stores/managing.mdx",
        "type": "mdx",
        "chunkIndex": 3,
        "lastModified": "2025-06-05T19:33:57.868Z",
        "size": 892
      }
    },
    {
      "pageContent": "// ...\n        }\n    }\n    new App().run();\n\n```\n</Tab>\n\n<Tab value=\"java\" label=\"Java\">\n```java\n    /* \n    All the values below like BRIDGE_URL, SOLUTION_ID, CONTEXT_ID \n    should be replaced by the ones corresponding to your Bridge Server instance.\n    \n    The private keys here are for demonstration purposes only. \n    Normally, they should be kept separately by each user and stored in a safe place,\n    or generated from a password (see the derivePrivateKey() method in the Crypto API)\n    */ \n\n    String bridgeUrl = \"http://localhost:9111\";\n    String solutionId = \"YOUR_SOLUTION_ID\";\n    String contextId = \"YOUR_CONTEXT_ID\";\n\n    String user1Id = \"user_1\";\n    String user1publicKey = \"PUBLIC_KEY_1\";\n    String user1Priv = \"PRIVATE_KEY_1\";\n\n    String user2Id = \"user_2\";\n    String user2PublicKey = \"PUBLIC_KEY_2\";\n\n    String user3Id = \"user_3\";\n    String user3PublicKey = \"PUBLIC_KEY_3\";\n\n    Long limit = 30L;\n    Long skip = 0L;\n```\n</Tab>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/stores/managing.mdx",
        "type": "mdx",
        "chunkIndex": 4,
        "codeBlocks": [
          "```\n</Tab>\n\n<Tab value=\"java\" label=\"Java\">\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.868Z",
        "size": 959
      }
    },
    {
      "pageContent": "String user3Id = \"user_3\";\n    String user3PublicKey = \"PUBLIC_KEY_3\";\n\n    Long limit = 30L;\n    Long skip = 0L;\n```\n</Tab>\n\n<Tab value=\"kotlin\" label=\"Kotlin\">\n```kotlin\n    /* \n    All the values below like BRIDGE_URL, SOLUTION_ID, CONTEXT_ID \n    should be replaced by the ones corresponding to your Bridge Server instance.\n    \n    The private keys here are for demonstration purposes only. \n    Normally, they should be kept separately by each user and stored in a safe place,\n    or generated from a password (see the derivePrivateKey() method in the Crypto API)\n    */ \n\n    val bridgeUrl = \"http://localhost:9111\"\n    val solutionId = \"YOUR_SOLUTION_ID\"\n    val contextId = \"YOUR_CONTEXT_ID\"\n\n    val user1Id = \"user_1\"\n    val user1publicKey = \"PUBLIC_KEY_1\"\n    val user1Priv = \"PRIVATE_KEY_1\"\n\n    val user2Id = \"user_2\"\n    val user2PublicKey = \"PUBLIC_KEY_2\"\n\n    val user3Id = \"user_3\"\n    val user3PublicKey = \"PUBLIC_KEY_3\"\n\n    val limit = 30L\n    val skip = 0L\n```\n</Tab>\n\n<Tab value=\"swift\" label=\"Swift\">\n\n```swift\n    let PAGE_SIZE :Int64 = 30\n    let pageIndex :Int64 = 2\n```\n</Tab>\n</Tabs>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/stores/managing.mdx",
        "type": "mdx",
        "chunkIndex": 5,
        "codeBlocks": [
          "```\n</Tab>\n\n<Tab value=\"kotlin\" label=\"Kotlin\">\n```",
          "```\n</Tab>\n\n<Tab value=\"swift\" label=\"Swift\">\n\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.868Z",
        "size": 1113
      }
    },
    {
      "pageContent": "## Creating Stores\n\nTo create a Store, you need a name and a list of **public key - userID** pairs. See how to get them [here](../installation).\nDue to the fact that each Store is inside a Context, all the public keys have to be registered inside the given Context. \nYou can do it using Bridge API.\n\nAfter creating a Store, all the users with management rights will be able to edit the Store. Skip to [Modifying Stores](#modifying-stores) for more info.\n\nBelow you can see some examples of creating Stores:\n\n<Tabs groupId=\"lang\" items={[\"cpp\",\"js\",\"java\",\"kotlin\",\"swift\"]}>\n\n<Tab value=\"cpp\" label=\"C++\">\n```cpp\n\t// create a new Store with access for user_1 as manager and user_2 as regular user\n\tauto storeId {storesApi.createStore(CONTEXT_ID, users, managers, \n        core::Buffer::from(\"some store's public meta-data\"), \n        core::Buffer::from(\"some store's private meta-data\")\n    )};\n```\n</Tab>\n\n<Tab value=\"js\" label=\"JavaScript\">\n```js\n    const managers = [\n        {userId: USER1_ID, pubKey: USER1_PUBLIC_KEY}\n    ];\n\n    const users = [\n        {userId: USER1_ID, pubKey: USER1_PUBLIC_KEY},\n        {userId: USER2_ID, pubKey: USER2_PUBLIC_KEY}\n    ];",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/stores/managing.mdx",
        "type": "mdx",
        "chunkIndex": 6,
        "headers": [
          "Creating Stores"
        ],
        "title": "Creating Stores",
        "codeBlocks": [
          "```cpp\n\t// create a new Store with access for user_1 as manager and user_2 as regular user\n\tauto storeId {storesApi.createStore(CONTEXT_ID, users, managers, \n        core::Buffer::from(\"some store's public meta-data\"), \n        core::Buffer::from(\"some store's private meta-data\")\n    )};\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.868Z",
        "size": 1166
      }
    },
    {
      "pageContent": "const users = [\n        {userId: USER1_ID, pubKey: USER1_PUBLIC_KEY},\n        {userId: USER2_ID, pubKey: USER2_PUBLIC_KEY}\n    ];\n\n    // create a new Store with access for user_1 as manager and user_2 as regular user\n    // for example, let's put the name of the store as an object in the store's private meta\n    const storeId = await storesApi.createStore(CONTEXT_ID, users, managers, \n        this.strToUint8(\"some store's public meta-data\"), \n        this.strToUint8(JSON.stringify({name: \"some_store\"}))\n    );",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/stores/managing.mdx",
        "type": "mdx",
        "chunkIndex": 7,
        "lastModified": "2025-06-05T19:33:57.868Z",
        "size": 516
      }
    },
    {
      "pageContent": "```\n\n</Tab>\n<Tab value=\"java\" label=\"Java\">\n```java\nPrivmxEndpointContainer container = new PrivmxEndpointContainer();\nLong connectionID = 0L; // your connection ID\nString contextID = \"<CONTEXT_ID>\";\n\nbyte[] privateMeta = \"My private data\".getBytes(StandardCharsets.UTF_8);\nbyte[] publicMeta = \"My public data\".getBytes(StandardCharsets.UTF_8);\nList<UserWithPubKey> users = List.of(\n        new UserWithPubKey(\"MY_USER\", \"PUB_KEY\"),\n        new UserWithPubKey(\"MY_USER2\", \"PUB_KEY2\")\n);\nList<UserWithPubKey> managers = List.of(\n        new UserWithPubKey(\"MY_USER\", \"PUB_KEY\")\n);\n\nString storeID = container.getEndpoint(connectionID).storeApi.createStore(\n        contextID,\n        users,\n        managers,\n        publicMeta,\n        privateMeta\n);\n```\n</Tab>\n\n<Tab value=\"kotlin\" label=\"Kotlin\">\n```kotlin\nval container = PrivmxEndpointContainer()\nval connectionID = 0L // your connection ID\nval contextID = \"<CONTEXT_ID>\"",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/stores/managing.mdx",
        "type": "mdx",
        "chunkIndex": 8,
        "codeBlocks": [
          "```\n\n</Tab>\n<Tab value=\"java\" label=\"Java\">\n```",
          "```\n</Tab>\n\n<Tab value=\"kotlin\" label=\"Kotlin\">\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.868Z",
        "size": 925
      }
    },
    {
      "pageContent": "<Tab value=\"kotlin\" label=\"Kotlin\">\n```kotlin\nval container = PrivmxEndpointContainer()\nval connectionID = 0L // your connection ID\nval contextID = \"<CONTEXT_ID>\"\n\nval privateMeta = \"My private data\".encodeToByteArray()\nval publicMeta = \"My public data\".encodeToByteArray()\nval users = listOf(\n    UserWithPubKey(\"MY_USER\", \"PUB_KEY\"),\n    UserWithPubKey(\"MY_USER2\", \"PUB_KEY2\")\n)\nval managers = listOf(\n    UserWithPubKey(\"MY_USER\", \"PUB_KEY\")\n)\n\nval storeID = container.getEndpoint(connectionID).storeApi.createStore(\n    contextID,\n    users,\n    managers,\n    publicMeta,\n    privateMeta\n)\n```\n</Tab>\n\n<Tab value=\"swift\" label=\"Swift\">\n\n```swift\nvar coreApi: CoreApi; \nvar threadApi = ThreadApi(coreApi);\n\nlet contextId= // your context Id\nlet users= // returns users from your server\nlet managers= // selected users with thread editing permissions\n\nlet newThreadID = try threadApi.createThread( \n    \"New Thread\",\n    with: users, \n    managedBy: \n    managers, \n    in: contextId\n)\n```\n</Tab>\n</Tabs>\n\n**Important note:** Managers declared while creating the Store, also have to be included in the regular user list.",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/stores/managing.mdx",
        "type": "mdx",
        "chunkIndex": 9,
        "codeBlocks": [
          "```kotlin\nval container = PrivmxEndpointContainer()\nval connectionID = 0L // your connection ID\nval contextID = \"<CONTEXT_ID>\"\n\nval privateMeta = \"My private data\".encodeToByteArray()\nval publicMeta = \"My public data\".encodeToByteArray()\nval users = listOf(\n    UserWithPubKey(\"MY_USER\", \"PUB_KEY\"),\n    UserWithPubKey(\"MY_USER2\", \"PUB_KEY2\")\n)\nval managers = listOf(\n    UserWithPubKey(\"MY_USER\", \"PUB_KEY\")\n)\n\nval storeID = container.getEndpoint(connectionID).storeApi.createStore(\n    contextID,\n    users,\n    managers,\n    publicMeta,\n    privateMeta\n)\n```",
          "```swift\nvar coreApi: CoreApi; \nvar threadApi = ThreadApi(coreApi);\n\nlet contextId= // your context Id\nlet users= // returns users from your server\nlet managers= // selected users with thread editing permissions\n\nlet newThreadID = try threadApi.createThread( \n    \"New Thread\",\n    with: users, \n    managedBy: \n    managers, \n    in: contextId\n)\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.868Z",
        "size": 1122
      }
    },
    {
      "pageContent": "**Important note:** Managers declared while creating the Store, also have to be included in the regular user list.\n\nThe user list in Stores is designed to be flexible, accommodating a wide range of use cases.",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/stores/managing.mdx",
        "type": "mdx",
        "chunkIndex": 10,
        "lastModified": "2025-06-05T19:33:57.868Z",
        "size": 208
      }
    },
    {
      "pageContent": "## Listing Stores\n\nYour application may include multiple Stores, each associated with different Contexts. \nYou can retrieve a **list of all Stores within a given Context.** \nThis list will include useful metadata about the Stores, such as the creation date, last file upload date, user list, and information about the last modification. \nHowever, to optimize performance, the list will only include the total number of files in each Store, not the full file content.\n\nHere's an example of how to download the last 30 Stores created within a Context:\n\n<Tabs groupId=\"lang\" items={[\"cpp\",\"js\",\"java\",\"kotlin\",\"swift\"]}>\n\n<Tab value=\"cpp\" label=\"C++\">\n```cpp\n\t// list stores\n\tcore::PagingQuery query = {.skip = 0, .limit = 30, .sortOrder = \"desc\"};\n    \n    auto result {storesApi.listStores(CONTEXT_ID, query)};\n    for (auto store: result.readItems) {\n        std::cout << \"Store ID: \" << store.storeId << std::endl;\n    }\n```\n</Tab>\n\n<Tab value='js' label=\"JavaScript\">\n```js\n    const query: Types.PagingQuery = {skip: 0, limit: 30, sortOrder: \"desc\"};",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/stores/managing.mdx",
        "type": "mdx",
        "chunkIndex": 11,
        "headers": [
          "Listing Stores"
        ],
        "title": "Listing Stores",
        "codeBlocks": [
          "```cpp\n\t// list stores\n\tcore::PagingQuery query = {.skip = 0, .limit = 30, .sortOrder = \"desc\"};\n    \n    auto result {storesApi.listStores(CONTEXT_ID, query)};\n    for (auto store: result.readItems) {\n        std::cout << \"Store ID: \" << store.storeId << std::endl;\n    }\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.868Z",
        "size": 1053
      }
    },
    {
      "pageContent": "<Tab value='js' label=\"JavaScript\">\n```js\n    const query: Types.PagingQuery = {skip: 0, limit: 30, sortOrder: \"desc\"};\n\n    const result = await storesApi.listStores(CONTEXT_ID, query);\n    for (const store of result.readItems) {\n        console.log(\"Store ID: \", store.storeId);\n    }",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/stores/managing.mdx",
        "type": "mdx",
        "chunkIndex": 12,
        "lastModified": "2025-06-05T19:33:57.868Z",
        "size": 286
      }
    },
    {
      "pageContent": "```\n\n</Tab>\n\n<Tab value='java' label=\"Java\">\n```java\nPrivmxEndpointContainer container = new PrivmxEndpointContainer();\nLong connectionID = 0L; // your connection ID\nString contextID = \"<CONTEXT_ID>\";\n\nLong limit = 30L;\nLong skip = 0L;\n\nPagingList<Store> stores = container.getEndpoint(connectionID).storeApi.listStores(\n        contextID,\n        skip,\n        limit,\n        SortOrder.DESC\n);\n```\n</Tab>\n\n<Tab value='kotlin' label=\"Kotlin\">\n```kotlin\nval container = PrivmxEndpointContainer()\nval connectionID = 0L // your connection ID\nval contextID = \"<CONTEXT_ID>\"\n\nval limit = 30L\nval skip = 0L\n\nval stores = container.getEndpoint(connectionID).storeApi.listStores(\n    contextID,\n    skip,\n    limit,\n    SortOrder.DESC\n)\n```\n</Tab>\n\n<Tab value='swift' label=\"Swift\">\n```swift\nlet PAGE_SIZE :Int64 = 30\nlet pageIndex :Int64 = 2\n\nlet threadList = try listThreads(\n    from: contextId,\n    query: privmx.endpoint.core.ListQuery(\n        skip: pageIndex,\n        limit: PAGE_SIZE,\n        sortOrder: .desc)\n)\n```\n</Tab>\n</Tabs>\n\nTo limit collecting too much data when downloading Stores, specify the page index (starting from 0) and the number of items to be included on each page.",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/stores/managing.mdx",
        "type": "mdx",
        "chunkIndex": 13,
        "codeBlocks": [
          "```\n\n</Tab>\n\n<Tab value='java' label=\"Java\">\n```",
          "```\n</Tab>\n\n<Tab value='kotlin' label=\"Kotlin\">\n```",
          "```\n</Tab>\n\n<Tab value='swift' label=\"Swift\">\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.868Z",
        "size": 1185
      }
    },
    {
      "pageContent": "## Modifying Stores\n\nDepending on your project's specification, it may be necessary to modify a Store.\nIt could be e.g. changing the name or adding/removing users.\nEach user with management rights is able to modify Stores, delete them as a whole or only particular files.\n\nUpdating a Store means overwriting it with the provided data. \nTo successfully update a Store, you must specify its current `version`. \nThe `version` field is mandatory to handle multiple updates on the server and it is incremented by 1 with each update.\n\nBelow there is an example of modifying a Store:\n\n<Tabs groupId=\"lang\" items={[\"cpp\",\"js\",\"java\",\"kotlin\",\"swift\"]}>\n\n<Tab value=\"cpp\" label=\"C++\">\n```cpp\n\tstd::vector<core::UserWithPubKey> managers {};\n\tmanagers.push_back({.userId = USER1_ID, .pubKey = USER1_PUBLIC_KEY});\n\n    // Let's add a new user to the existing ones in the Store\n\tstd::vector<core::UserWithPubKey> newUsersList {};\n    newUsersList.push_back({.userId = USER1_ID, .pubKey = USER1_PUBLIC_KEY});\n\tnewUsersList.push_back({.userId = USER2_ID, .pubKey = USER2_PUBLIC_KEY});\n\tnewUsersList.push_back({.userId = USER3_ID, .pubKey = USER3_PUBLIC_KEY});\n\n    auto storeInfo {storesApi.getStore(storeId)};",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/stores/managing.mdx",
        "type": "mdx",
        "chunkIndex": 14,
        "headers": [
          "Modifying Stores"
        ],
        "title": "Modifying Stores",
        "lastModified": "2025-06-05T19:33:57.868Z",
        "size": 1195
      }
    },
    {
      "pageContent": "auto storeInfo {storesApi.getStore(storeId)};\n\n    storesApi.updateStore(storeId, newUsersList, managers, \n        core::Buffer::from(\"some new store's public meta-data\"), \n        core::Buffer::from(\"some new store's private meta-data\"), storeInfo.version, false, false\n    );\n```\n</Tab>\n\n<Tab value='js' label=\"JavaScript\">\n```js\n    // Let's add a new user to the existing ones in the Store\n    const newUsersList = [\n        {userId: USER1_ID, pubKey: USER1_PUBLIC_KEY},\n        {userId: USER2_ID, pubKey: USER2_PUBLIC_KEY},\n        {userId: USER3_ID, pubKey: USER3_PUBLIC_KEY}\n    ]; \n\n    const storeInfo = await storesApi.getStore(storeId);\n\n    await storesApi.updateStore(storeId, newUsersList, managers, \n        this.strToUint8(\"some new store's public meta-data\"), \n        this.strToUint8(\"some new store's private meta-data\"), storeInfo.version, false, false\n    );\n```\n</Tab>\n<Tab value='java' label=\"Java\">\n```java\nPrivmxEndpointContainer container = new PrivmxEndpointContainer();\nLong connectionID = 0L; // your connection ID\nString storeID = \"YOUR_STORE_ID\";\n\nStoreApi storeApi = container.getEndpoint(connectionID).storeApi;\nStore store = storeApi.getStore(storeID);",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/stores/managing.mdx",
        "type": "mdx",
        "chunkIndex": 15,
        "codeBlocks": [
          "```\n</Tab>\n\n<Tab value='js' label=\"JavaScript\">\n```",
          "```\n</Tab>\n<Tab value='java' label=\"Java\">\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.868Z",
        "size": 1186
      }
    },
    {
      "pageContent": "StoreApi storeApi = container.getEndpoint(connectionID).storeApi;\nStore store = storeApi.getStore(storeID);\n\nList<UserWithPubKey> newUsers = store.users.stream().map(userID -> {\n    //Your application must provide a way,\n    //to get user's public key from their userId.\n\n    return new UserWithPubKey(\n            userID,\n            \"USER_PUBLIC_KEY\"\n    );\n\n}).toList();\nList<UserWithPubKey> newManagers = store.managers.stream().map(userID -> {\n    //Your application must provide a way,\n    //to get user's public key from their userId.\n    return new UserWithPubKey(\n            userID,\n            \"USER_PUBLIC_KEY\"\n    );\n\n}).toList();\nbyte[] newPrivateMeta = \"New store name\".getBytes(StandardCharsets.UTF_8);\n\ncontainer.getEndpoint(connectionID).storeApi.updateStore(\n        storeID,\n        newUsers,\n        newManagers,\n        store.publicMeta,\n        newPrivateMeta,\n        store.version,\n        false\n);\n```\n</Tab>\n\n<Tab value='kotlin' label=\"Kotlin\">\n```kotlin\nval container = PrivmxEndpointContainer()\nval connectionID = 0L // your connection ID\nval storeID = \"YOUR_STORE_ID\"\n\nval storeApi = container.getEndpoint(connectionID).storeApi\nval store = storeApi.getStore(storeID)",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/stores/managing.mdx",
        "type": "mdx",
        "chunkIndex": 16,
        "codeBlocks": [
          "```\n</Tab>\n\n<Tab value='kotlin' label=\"Kotlin\">\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.868Z",
        "size": 1197
      }
    },
    {
      "pageContent": "val storeApi = container.getEndpoint(connectionID).storeApi\nval store = storeApi.getStore(storeID)\n\nval newUsers = store.users.map { userID ->\n    UserWithPubKey(\n        userID,\n        \"USER_PUBLIC_KEY\"\n    )\n}.toList()\nval newManagers = store.managers.map { userID ->\n    UserWithPubKey(\n        userID,\n        \"USER_PUBLIC_KEY\"\n    )\n}.toList()\nval newPrivateMeta = \"New store name\".encodeToByteArray()\n\ncontainer.getEndpoint(connectionID).storeApi.updateStore(\n    storeID,\n    newUsers,\n    newManagers,\n    store.publicMeta,\n    newPrivateMeta,\n    store.version,\n    false\n)\n```\n</Tab>\n\n<Tab value='swift' label=\"Swift\">\n```swift\nlet threadId :String= // id of thread to update\nlet threadInfo = threadApi.getThread(threadId);\n\nvar users :[UserWithPubKey] //new list of users\nvar managers :[UserWithPubKey]  //new list of managers\n\nthreadApi.updateThread(\n    threadInfo.threadId,\n    users:users,\n    managers:managers,\n    title:threadInfo.data.title,\n    version:threadInfo.version,\n    force:false,\n    generateNewKeyId:false,\n    accessToOldDataForNewUsers:false\n)\n```\n</Tab>\n</Tabs>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/stores/managing.mdx",
        "type": "mdx",
        "chunkIndex": 17,
        "codeBlocks": [
          "```\n</Tab>\n\n<Tab value='swift' label=\"Swift\">\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.868Z",
        "size": 1096
      }
    },
    {
      "pageContent": "Three additional options are available when changing the list of users inside a Store:\n- `force` - applies an update, without checking the current version;\n- `forceGenerateNewKey` - re-encrypts messages in the Thread. It's useful when a user is removed and we want to prevent them from accessing the Thread.\n- `policies` - allow you to manage access to Stores and files. [Read more about Policies](../concepts/policies).",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/stores/managing.mdx",
        "type": "mdx",
        "chunkIndex": 18,
        "lastModified": "2025-06-05T19:33:57.868Z",
        "size": 420
      }
    },
    {
      "pageContent": "---\ntitle: Overview\n---\n\nStore container is a structured data storage and communication tool used for **file exchange and management**.\n\nUsers create Stores to organize topic-specific spaces where they can securely **upload encrypted files** and share them with designated participants.\nAll the active users are **notified** right away when a file is uploaded or modified. \nStores can be integrated with Threads.\n\n## Prerequisites\n\nBefore working with Stores, you need to have a PrivMX Bridge instance.\n\nTo install it, [follow our PrivMX quick start guide](../quick-start).",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/stores/overview.mdx",
        "type": "mdx",
        "chunkIndex": 0,
        "headers": [
          "Prerequisites"
        ],
        "title": "Prerequisites",
        "lastModified": "2025-06-05T19:33:57.868Z",
        "size": 573
      }
    },
    {
      "pageContent": "## Architecture\n\nThink of a Store like a folder that allows you to store files, which **can include any binary or text data as well as metadata**. \nEach Store has its own set of permissions, managed by assigning the users’ public keys to the Store.\n**Only the users with assigned public keys can read or write files from that Store**. \nDecryption of these files is possible only with the corresponding private keys.\n\n**Each file is protected by a synchronous key, which is further secured using an asynchronous pair of public and private user keys**. \nThis dual-layer encryption ensures that the system remains both safe and efficient. \nLearn more about our advanced [encryption methods and how they safeguard your files](./encryption).\n\nA distinguishing feature of Stores is that the files are stored using segmentation, and access to them is via streaming. \nThis allows for asynchronous reading and writing to these files without the need to download the entire file to memory or the local machine’s storage. \nThere is also no upper limit on the size of these files. All of this remains perfectly secure using dual-layer encryption.",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/stores/overview.mdx",
        "type": "mdx",
        "chunkIndex": 1,
        "headers": [
          "Architecture"
        ],
        "title": "Architecture",
        "lastModified": "2025-06-05T19:33:57.868Z",
        "size": 1134
      }
    },
    {
      "pageContent": "The following diagram is a visual reference for the architecture of Stores:\n![privmx stores encryption](/img/privmx-stores.svg)",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/stores/overview.mdx",
        "type": "mdx",
        "chunkIndex": 2,
        "lastModified": "2025-06-05T19:33:57.868Z",
        "size": 127
      }
    },
    {
      "pageContent": "## Files\n\nThe main data units in Stores are files, which contain binary `data`, as well as [metadata](./handling-files#about-files):\n\n- `privateMeta` - encrypted data about the file\n- `publicMeta` - **decrypted** additional data about the file\n\nEach file also has information assigned by the Bridge, which is impossible to modify.\n\nTo learn more about files, go to [Uploading Files](./uploading-files).",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/stores/overview.mdx",
        "type": "mdx",
        "chunkIndex": 3,
        "headers": [
          "Files"
        ],
        "title": "Files",
        "lastModified": "2025-06-05T19:33:57.868Z",
        "size": 402
      }
    },
    {
      "pageContent": "---\ntitle: Uploading Files\n---\n      Tabs, Tab} from \"fumadocs-ui/components/tabs\"\n\n\n:::info\n\nThe sample code on this page is based on the same **[assumptions](./managing#initial-assumptions)** mentioned in [Managing Stores](./managing).\n\n:::\n\nIn this section, we will guide you through the process of uploading a file to a Store. This process involves both uploading the file content and managing its associated metadata. Storing metadata, such as the file's name, and type, allows for easier identification and retrieval of files when needed.\n\nWe highly recommend storing the file's metadata along with the file content to make it easier to manage and interact with the uploaded file in the future.",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/stores/uploading-files.mdx",
        "type": "mdx",
        "chunkIndex": 0,
        "lastModified": "2025-06-05T19:33:57.869Z",
        "size": 700
      }
    },
    {
      "pageContent": "## Small Files\nWriting whole file at once:\n<Tabs groupId=\"lang\" items={[\"cpp\",\"js\",\"java\",\"kotlin\",\"swift\"]}>\n<Tab value=\"cpp\" label=\"C++\">\n\n```cpp\n\t// add file to the specified Store\n\tauto sampleFileMeta {core::Buffer::from(\"sample file data\")};\n\n    std::string exampleFileMeta = \"{\\\"name\\\":\\\"some_file_name\\\"}\";\n\n\tauto fileHandle {storesApi.createFile(storeId, \n\t        core::Buffer::from(\"file's public meta-data\"), \n        \tcore::Buffer::from(exampleFileMeta),\n\t\t\tsampleFileData.size()\n\t)};\n\n\tstoresApi.writeToFile(fileHandle, sampleFileData);\n\tauto fileId {storesApi.closeFile(fileHandle)};\n```\n</Tab>\n<Tab label=\"JavaScript\" value=\"js\">\n\n```js\n    // for example, let's put some extra file info in the file's private meta\n    const privateMeta = this.strToUint8(JSON.stringify({\n        name: file.name,\n        mimetype: file.type\n    });\n    const sampleFileData = this.strToUint8(\"sample file data\");\n\n    const fileHandle = await storesApi.createFile(storeId, \n        this.strToUint8(\"file's public meta-data\"), \n        privateMeta,\n        sampleFileData.length\n    );",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/stores/uploading-files.mdx",
        "type": "mdx",
        "chunkIndex": 1,
        "headers": [
          "Small Files"
        ],
        "title": "Small Files",
        "codeBlocks": [
          "```cpp\n\t// add file to the specified Store\n\tauto sampleFileMeta {core::Buffer::from(\"sample file data\")};\n\n    std::string exampleFileMeta = \"{\\\"name\\\":\\\"some_file_name\\\"}\";\n\n\tauto fileHandle {storesApi.createFile(storeId, \n\t        core::Buffer::from(\"file's public meta-data\"), \n        \tcore::Buffer::from(exampleFileMeta),\n\t\t\tsampleFileData.size()\n\t)};\n\n\tstoresApi.writeToFile(fileHandle, sampleFileData);\n\tauto fileId {storesApi.closeFile(fileHandle)};\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.869Z",
        "size": 1084
      }
    },
    {
      "pageContent": "const fileHandle = await storesApi.createFile(storeId, \n        this.strToUint8(\"file's public meta-data\"), \n        privateMeta,\n        sampleFileData.length\n    );\n\n    await storesApi.writeToFile(fileHandle, sampleFileData);\n    const fileId = await storesApi.closeFile(fileHandle);\n\n```\n</Tab>\n\n<Tab label=\"Java\" value=\"java\">\n```java\nPrivmxEndpointContainer container = new PrivmxEndpointContainer();\nLong connectionID = 0L; // your connection ID\nStoreApi storeApi = container.getEndpoint(connectionID).storeApi;\nString storeID = \"<YOUR_STORE_ID>\";\n\nbyte[] publicMeta = \"File public meta\".getBytes(StandardCharsets.UTF_8);\nbyte[] privateMeta = \"File private meta\".getBytes(StandardCharsets.UTF_8);\nbyte[] fileContent = \"Text file content\".getBytes(StandardCharsets.UTF_8);\ntry {\n    StoreFileStreamWriter writer = StoreFileStreamWriter.createFile(\n            storeApi,\n            storeID,\n            publicMeta,\n            privateMeta,\n            fileContent.length\n    );\n    writer.write(fileContent);\n    String fileId = writer.close();\n}catch (Exception e){\n    System.out.println(\"Cannot upload file: \" + e.getMessage());\n}\n```\n</Tab>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/stores/uploading-files.mdx",
        "type": "mdx",
        "chunkIndex": 2,
        "codeBlocks": [
          "```\n</Tab>\n\n<Tab label=\"Java\" value=\"java\">\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.869Z",
        "size": 1150
      }
    },
    {
      "pageContent": "<Tab label=\"Kotlin\" value=\"Kotlin\">\n```kotlin\nval container = PrivmxEndpointContainer()\nval connectionID = 0L // your connection ID\nval storeApi = container.getEndpoint(connectionID).storeApi\nval storeID = \"<YOUR_STORE_ID>\"\n\nval publicMeta = \"File public meta\".encodeToByteArray()\nval privateMeta = \"File private meta\".encodeToByteArray()\nval fileContent = \"Text file content\".encodeToByteArray()\n\nval fileId = StoreFileStreamWriter.createFile(\n    storeApi,\n    storeID,\n    publicMeta,\n    privateMeta,\n    fileContent.size.toLong()\n).run {\n    write(fileContent)\n    close()\n}\n```\n</Tab>\n\n\n<Tab label=\"Swift\" value=\"swift\">\n```swift\nstruct FilePrivateMeta:Codable{\n    let name: String\n    let mimetype: String\n}\n\nlet storeID = \"STORE_ID\"\nguard let fileContentData = \"Text file content\".data(using: .utf8 ) else {return}\n\nlet filePrivateMeta = FilePrivateMeta(name: \"Example text file\", mimetype: \"text/plain\")\nguard let filePrivateMetaData = try? JSONEncoder().encode(filePrivateMeta) else {return}\n\nguard let privMXEndpoint =  endpointContainer.getEndpoint(connectionId) else {return}",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/stores/uploading-files.mdx",
        "type": "mdx",
        "chunkIndex": 3,
        "codeBlocks": [
          "```kotlin\nval container = PrivmxEndpointContainer()\nval connectionID = 0L // your connection ID\nval storeApi = container.getEndpoint(connectionID).storeApi\nval storeID = \"<YOUR_STORE_ID>\"\n\nval publicMeta = \"File public meta\".encodeToByteArray()\nval privateMeta = \"File private meta\".encodeToByteArray()\nval fileContent = \"Text file content\".encodeToByteArray()\n\nval fileId = StoreFileStreamWriter.createFile(\n    storeApi,\n    storeID,\n    publicMeta,\n    privateMeta,\n    fileContent.size.toLong()\n).run {\n    write(fileContent)\n    close()\n}\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.869Z",
        "size": 1089
      }
    },
    {
      "pageContent": "guard let privMXEndpoint =  endpointContainer.getEndpoint(connectionId) else {return}\n\nguard let storeFileHandle = try? privMXEndpoint.storeApi?.createFile(\n    in: storeID,\n    withPublicMeta: Data(),\n    withPrivateMeta: filePrivateMetaData,\n    ofSize: Int64(fileContentData.count))\nelse {return}\n\ntry? privMXEndpoint.storeApi?.writeToFile(withHandle: storeFileHandle, uploading: fileContentData)\n\n```\n</Tab>\n</Tabs>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/stores/uploading-files.mdx",
        "type": "mdx",
        "chunkIndex": 4,
        "lastModified": "2025-06-05T19:33:57.869Z",
        "size": 419
      }
    },
    {
      "pageContent": "## Streaming\n\nFor larger files or scenarios where you need more control over the upload process (e.g. managing upload progress, pausing, or canceling uploads), we recommend using streaming. \nStreaming allows you to upload the file in chunks, enabling better interactivity, monitoring, and control.\n\nStreaming is especially useful when:\n- You need to upload large files and a single upload might take a long time;\n- You need the ability to cancel the upload in the middle of the process.\n\nUploading large file - writing to Store chunk by chunks:\n\n<Tabs groupId=\"lang\" items={[\"cpp\",\"js\",\"java\",\"kotlin\",\"swift\"]}>\n\n<Tab value=\"cpp\" label=\"C++\">\n```cpp\n\tstd::string filePath {\"file.zip\"};\n\tstd::string filePrivMeta = \"{\\\"name\\\":\\\"\" +filePath+ \"\\\"}\";\n\tauto sizeTotal = std::filesystem::file_size(filePath);\n\n\tauto binaryFileHandle {storesApi.createFile(storeId, core::Buffer::from(\"file's public meta-data\"), \n        core::Buffer::from(filePrivMeta), sizeTotal\n\t)};\n\t\n\t// read from disk and upload chunks to the Bridge\n\tstd::ifstream fin(filePath, std::ios::binary);\n    std::vector<char> buffer (1024,0);",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/stores/uploading-files.mdx",
        "type": "mdx",
        "chunkIndex": 5,
        "headers": [
          "Streaming"
        ],
        "title": "Streaming",
        "lastModified": "2025-06-05T19:33:57.869Z",
        "size": 1103
      }
    },
    {
      "pageContent": "while(!fin.eof()) {\n\t\tauto chunkSize {fin.read(buffer.data(), buffer.size()).gcount()};\n\t\tstoresApi.writeToFile(binaryFileHandle, core::Buffer::from(buffer.data(), chunkSize));\n\t\tif (!fin.good()) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tauto binaryFileId {storesApi.closeFile(binaryFileHandle)};\n\tfin.close();",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/stores/uploading-files.mdx",
        "type": "mdx",
        "chunkIndex": 6,
        "lastModified": "2025-06-05T19:33:57.869Z",
        "size": 288
      }
    },
    {
      "pageContent": "```\n\n</Tab>\n\n<Tab label=\"JavaScript\" value=\"js\">\nLet's say you have an Html input element in the page body:\n```html\n    <input type=\"file\" id=\"inp\"/>\n```\n    Now, access that above input element from the JS code and get a file from there:\n```js\n\n    const fileInput = document.getElementById('inp');\n    if (!fileInput.files || fileInput.files.length === 0) {\n        return;\n    }\n\n    // prepare a stream to read from the file\n    const stream = fileInput.files[0].stream();\n    const name = fileInput.files[0].name;\n\n    const fHandle = await storesApi.createFile(storeId, \n        this.strToUint8(\"file's public meta-data\"), \n        this.strToUint8(JSON.stringify({name})), \n        fileSize\n    );\n\n    const reader = stream.getReader();\n    while( true ) {\n        const result = await reader.read();\n        if( !result || result.done ) { \n            break; \n        }\n        console.log(\"Writing the file's chunk to the Store...\");\n        await storesApi.writeToFile(fHandle, result.value);\n    }\n    await storesApi.closeFile(fHandle);\n\n```\n</Tab>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/stores/uploading-files.mdx",
        "type": "mdx",
        "chunkIndex": 7,
        "codeBlocks": [
          "```\n\n</Tab>\n\n<Tab label=\"JavaScript\" value=\"js\">\nLet's say you have an Html input element in the page body:\n```",
          "```\n    Now, access that above input element from the JS code and get a file from there:\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.869Z",
        "size": 1060
      }
    },
    {
      "pageContent": "```\n</Tab>\n\n<Tab label=\"Java\" value=\"java\">\n```java\nPrivmxEndpointContainer container = new PrivmxEndpointContainer();\nLong connectionID = 0L; // your connection ID\nStoreApi storeApi = container.getEndpoint(connectionID).storeApi;\nString storeID = \"<YOUR_STORE_ID>\";\n\nbyte[] publicMeta = \"File public meta\".getBytes(StandardCharsets.UTF_8);\nbyte[] privateMeta = \"File private meta\".getBytes(StandardCharsets.UTF_8);\nStoreFileStream.Controller controller = new StoreFileStream.Controller(){\n    @Override\n    public void onChunkProcessed(Long processedBytes) {\n        System.out.println(\"Uploaded bytes: \" + processedBytes);\n    }\n};\n\ntry(InputStream iS = new FileInputStream(\"<PATH_TO_FILE>\")) {\n    String fileId = StoreFileStreamWriter.createFile(\n            storeApi,\n            storeID,\n            publicMeta,\n            privateMeta,\n            iS.available(),\n            iS,\n            controller\n    );\n}catch (Exception e){\n    System.out.println(\"Cannot download file: \" + e.getMessage());\n}\n```\n</Tab>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/stores/uploading-files.mdx",
        "type": "mdx",
        "chunkIndex": 8,
        "codeBlocks": [
          "```\n</Tab>\n\n<Tab label=\"Java\" value=\"java\">\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.869Z",
        "size": 1018
      }
    },
    {
      "pageContent": "<Tab label=\"Kotlin\" value=\"Kotlin\">\n```kotlin\nval container = PrivmxEndpointContainer()\nval connectionID = 0L // your connection ID\nval storeApi = container.getEndpoint(connectionID).storeApi\nval storeID = \"<YOUR_STORE_ID>\"\n\nval publicMeta = \"File public meta\".encodeToByteArray()\nval privateMeta = \"File private meta\".encodeToByteArray()\nval controller: StoreFileStream.Controller = object : StoreFileStream.Controller() {\n    override fun onChunkProcessed(processedBytes: Long) {\n        println(\"Downloaded bytes: $processedBytes\")\n    }\n}\n\nval fileId = FileInputStream(\"<PATH_TO_FILE>\").use { iS ->\n    StoreFileStreamWriter.createFile(\n        storeApi,\n        storeID,\n        publicMeta,\n        privateMeta,\n        iS.available().toLong(),\n        iS,\n        controller\n    )\n}\n```\n</Tab>\n\n\n<Tab label=\"Swift\" value=\"swift\">\n```swift\nstruct FilePrivateMeta:Codable{\n    let name: String\n    let mimetype: String\n}\nlet filePrivateMeta = FilePrivateMeta(name: \"Filename.txt\", mimetype: \"text/plain\")\n\nguard let filePrivateMetaData = try? JSONEncoder().encode(filePrivateMeta) else {return}\n\n    let storeID = \"STORE_ID\"\n    let URL = URL(fileURLWithPath: \"/path/to/file/Filename.txt\")",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/stores/uploading-files.mdx",
        "type": "mdx",
        "chunkIndex": 9,
        "codeBlocks": [
          "```kotlin\nval container = PrivmxEndpointContainer()\nval connectionID = 0L // your connection ID\nval storeApi = container.getEndpoint(connectionID).storeApi\nval storeID = \"<YOUR_STORE_ID>\"\n\nval publicMeta = \"File public meta\".encodeToByteArray()\nval privateMeta = \"File private meta\".encodeToByteArray()\nval controller: StoreFileStream.Controller = object : StoreFileStream.Controller() {\n    override fun onChunkProcessed(processedBytes: Long) {\n        println(\"Downloaded bytes: $processedBytes\")\n    }\n}\n\nval fileId = FileInputStream(\"<PATH_TO_FILE>\").use { iS ->\n    StoreFileStreamWriter.createFile(\n        storeApi,\n        storeID,\n        publicMeta,\n        privateMeta,\n        iS.available().toLong(),\n        iS,\n        controller\n    )\n}\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.869Z",
        "size": 1193
      }
    },
    {
      "pageContent": "guard let filePrivateMetaData = try? JSONEncoder().encode(filePrivateMeta) else {return}\n\n    let storeID = \"STORE_ID\"\n    let URL = URL(fileURLWithPath: \"/path/to/file/Filename.txt\")\n\n    guard let fileHandle =  try? FileHandle(forReadingFrom: URL) else { return }\n    let fileSize:Int64 = 0 //to be provided by app\n\n\n    guard let filePrivateMetaData = try? JSONEncoder().encode(filePrivateMeta) else {return}\n\n    guard let privMXEndpoint =  endpointContainer.getEndpoint(connectionId) else {return}\n\n\n    let newFileId = try? await privMXEndpoint\n        .startUploadingNewFile(fileHandle,\n                                to: storeID,\n                                withPublicMeta: Data(),\n                                withPrivateMeta: filePrivateMetaData,\n                                sized: fileSize)\n```\n</Tab>\n</Tabs>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/stores/uploading-files.mdx",
        "type": "mdx",
        "chunkIndex": 10,
        "lastModified": "2025-06-05T19:33:57.869Z",
        "size": 832
      }
    },
    {
      "pageContent": "## Notes\n\n- **Metadata**: helps you identify files later on by storing additional information about them. You can use both private metada (which might contain sensitive or internal data) and public metada (which can be shared publicly).\n- **Error Handling**: During the streaming process, it's important to handle potential errors, such as network interruptions, by using try-catch blocks and the ability to abort the upload.\n- **Progress Monitoring**: Streaming enables you to monitor the progress of the file upload, allowing you to display the current upload percentage to the user.",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/stores/uploading-files.mdx",
        "type": "mdx",
        "chunkIndex": 11,
        "headers": [
          "Notes"
        ],
        "title": "Notes",
        "lastModified": "2025-06-05T19:33:57.869Z",
        "size": 585
      }
    },
    {
      "pageContent": "---\ntitle: Deploy to VPS\ndescription: This guide will walk you through deploying PrivMX Bridge Instance.\n---\n      Tab,Tabs} from \"fumadocs-ui/components/tabs\"\n\n\n## Prerequisites\n\nThis guide requires access to VPS server.\nYou can choose any provider you prefer, e.g.:\n\n- AWS EC2\n- Google Cloud Compute Engine\n- Digital Ocean Droplets\n- Azure Virtual Machine\n\nWe recommend choosing an option with at least 1 CPU and 500MB of RAM for PrivMX Bridge itself,\nand if you decide to host your MongoDB instance on the same machine to increase RAM to 4GB.\n\nYou will need also a domain name for your server.\nThis tutorial will guide you through how to generate certificates for it for https connection.",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/production/deploy-to-vps.mdx",
        "type": "mdx",
        "chunkIndex": 0,
        "headers": [
          "Prerequisites"
        ],
        "title": "Prerequisites",
        "lastModified": "2025-06-05T19:33:57.869Z",
        "size": 691
      }
    },
    {
      "pageContent": "## Setup Environment\n\n:::warning\n\nThis guides requires access to your server with sudo privileges.\n\n:::\n\n### Installing Docker\n\n1. Add Docker's official GPG key.\n```shell\n sudo apt-get update\n sudo apt-get install ca-certificates curl\n sudo install -m 0755 -d /etc/apt/keyrings\n sudo curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.asc\n sudo chmod a+r /etc/apt/keyrings/docker.asc\n   ```\n2. Add the repository to Apt sources.\n```sh\n echo \\\n \"deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu \\\n $(. /etc/os-release && echo \"${UBUNTU_CODENAME:-$VERSION_CODENAME}\") stable\" | \\\n\n sudo tee /etc/apt/sources.list.d/docker.list > /dev/null\n sudo apt-get update\n    ```\n3. Install docker.\n ```shell\n sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin\n    ```",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/production/deploy-to-vps.mdx",
        "type": "mdx",
        "chunkIndex": 1,
        "headers": [
          "Setup Environment",
          "Installing Docker"
        ],
        "title": "Setup Environment",
        "codeBlocks": [
          "```shell\n sudo apt-get update\n sudo apt-get install ca-certificates curl\n sudo install -m 0755 -d /etc/apt/keyrings\n sudo curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.asc\n sudo chmod a+r /etc/apt/keyrings/docker.asc\n   ```",
          "```sh\n echo \\\n \"deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu \\\n $(. /etc/os-release && echo \"${UBUNTU_CODENAME:-$VERSION_CODENAME}\") stable\" | \\\n\n sudo tee /etc/apt/sources.list.d/docker.list > /dev/null\n sudo apt-get update\n    ```",
          "```shell\n sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin\n    ```"
        ],
        "lastModified": "2025-06-05T19:33:57.869Z",
        "size": 909
      }
    },
    {
      "pageContent": "### Setup nginx\n\n1. Install nginx and certbot.\n ```shell\n sudo apt-get update\n sudo apt install certbot python3-certbot-nginx nginx\n    ```\n2. Create site config.\n\nCreate files in `/etc/nginx/sites-available/YOUR_DOMAIN_NAME`\n ```shell\n touch /etc/nginx/sites-available/YOUR_DOMAIN_NAME\n    ```\nopen it in your favourite text editor and add the following configuration:\n ```\nserver {\nlisten 80;\nserver_name YOUR_DOMAIN_NAME;\n\n     location / {\n         proxy_pass http://localhost:9111;\n         proxy_set_header Host $host;\n         proxy_set_header X-Forwarded-For $remote_addr;\n         proxy_set_header Upgrade $http_upgrade;\n         proxy_set_header Connection \"Upgrade\";\n     }\n}\n```\n3. Create a link to sites-enabled.\n ```shell\nsudo ln -s /etc/nginx/sites-available/YOUR_DOMAIN_NAME /etc/nginx/sites-enabled/YOUR_DOMAIN_NAME\n    ```",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/production/deploy-to-vps.mdx",
        "type": "mdx",
        "chunkIndex": 2,
        "headers": [
          "Setup nginx"
        ],
        "title": "Setup nginx",
        "codeBlocks": [
          "```shell\n sudo apt-get update\n sudo apt install certbot python3-certbot-nginx nginx\n    ```",
          "```shell\n touch /etc/nginx/sites-available/YOUR_DOMAIN_NAME\n    ```",
          "```\nserver {\nlisten 80;\nserver_name YOUR_DOMAIN_NAME;\n\n     location / {\n         proxy_pass http://localhost:9111;\n         proxy_set_header Host $host;\n         proxy_set_header X-Forwarded-For $remote_addr;\n         proxy_set_header Upgrade $http_upgrade;\n         proxy_set_header Connection \"Upgrade\";\n     }\n}\n```",
          "```shell\nsudo ln -s /etc/nginx/sites-available/YOUR_DOMAIN_NAME /etc/nginx/sites-enabled/YOUR_DOMAIN_NAME\n    ```"
        ],
        "lastModified": "2025-06-05T19:33:57.869Z",
        "size": 840
      }
    },
    {
      "pageContent": "### PrivMX Bridge Setup\nPrivMX Bridge requires [MongoDB](https://www.mongodb.com/) instance.\nYou can host it alongside PrivMX Bridge using our docker compose file or provide connection string\nto external MongoDB instance, for example, from [MongoDB Atlas](https://www.mongodb.com/atlas).\n\n<Callout>\nPrivMX Bridge requires MongoDB instance with an initialized replica set.\n`./setup.sh` script takes care of initializing a replica set for local MongoDB instance in docker compose.\n</Callout>\n\n\n1. Start by cloning PrivMX Bridge docker repo containing setup scripts.\n ```shell\n git clone https://github.com/simplito/privmx-bridge-docker.git privmx-bridge\n cd privmx-bridge\n    ```\n2. Run setup script.\n<Tabs items={[\"contained\",\"external\"]}>\n    <Tab value={\"contained\"} label={\"Coupled ???\"}>\n        ```shell\n        sudo ./setup.sh\n        ```\n    </Tab>\n    <Tab value={\"external\"} label={\"External Database\"}>\n        ```shell\n        sudo ./setup.sh --db-uri=\"YOUR_MONGODB_CONNECTION_STRING\"\n        ```\n    </Tab>\n</Tabs>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/production/deploy-to-vps.mdx",
        "type": "mdx",
        "chunkIndex": 3,
        "headers": [
          "PrivMX Bridge Setup"
        ],
        "title": "PrivMX Bridge Setup",
        "codeBlocks": [
          "```shell\n git clone https://github.com/simplito/privmx-bridge-docker.git privmx-bridge\n cd privmx-bridge\n    ```",
          "```shell\n        sudo ./setup.sh\n        ```",
          "```shell\n        sudo ./setup.sh --db-uri=\"YOUR_MONGODB_CONNECTION_STRING\"\n        ```"
        ],
        "lastModified": "2025-06-05T19:33:57.869Z",
        "size": 1025
      }
    },
    {
      "pageContent": "This script will pull all necessary docker images, and setup your first Solution and Context.\nAfter setup PrivMX Bridge, you will be prompted with variables required for connection.\n\nBy default, new instance will be available on `http://localhost:9111`",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/production/deploy-to-vps.mdx",
        "type": "mdx",
        "chunkIndex": 4,
        "lastModified": "2025-06-05T19:33:57.869Z",
        "size": 252
      }
    },
    {
      "pageContent": "## Exposing Application\n1. Check Nginx config.\n ```shell\n sudo nginx -t\n    ```\n2. Restart nginx.\n ```shell\n sudo systemctl restart nginx\n    ```\n3. Generate certificates using certbot.\n ```shell\n sudo certbot --nginx -d YOUR_DOMAIN\n    ```\n4. In your firewall settings expose port `80` and `443`.\nDuring certificate generation, Certbot adds redirects from http connections to https.\n\nYou can now open domain URL in your browser. PrivMX Bridge instance should return starting page.\n\n## Next Steps\n\nCheckout Containers documentation for guides on how you can use your PrivMX Bridge for E2E encrypted communication.\n\nLearn how to use:\n\n-   [**Threads**](../threads/overview) - for exchanging encrypted messages;\n-   [**Stores**](../stores/overview) - for saving and sharing encrypted files;\n-   [**Inboxes**](../inboxes/overview) - for one way communication with external users.",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/production/deploy-to-vps.mdx",
        "type": "mdx",
        "chunkIndex": 5,
        "headers": [
          "Exposing Application",
          "Next Steps"
        ],
        "title": "Exposing Application",
        "codeBlocks": [
          "```shell\n sudo nginx -t\n    ```",
          "```shell\n sudo systemctl restart nginx\n    ```",
          "```shell\n sudo certbot --nginx -d YOUR_DOMAIN\n    ```"
        ],
        "lastModified": "2025-06-05T19:33:57.869Z",
        "size": 876
      }
    },
    {
      "pageContent": "---\ntitle: Inbox Entries\n---\n\n\n\nInboxes allow users to receive encrypted entries, either from external or internal sources.\n\n- Internal sources are people who have access to an Inbox, or are simply registered in a given Context.\nThose users are known to your application, and their entries can be linked to their accounts.\n\n- External sources are people from the outside; they do not have an account linked with your app. For example,\nsomeone who fills out an online contact form without the need to create an account.\n\nThe key difference between Inboxes and other PrivMX containers is that people don't need accounts in your app to be able to submit entries.\n\n## About Entries\n\nThe structure of an entry and a brief description of its elements is outlined in the following table:\n\n| **Field**      | **Type** |    **Encrypted**     | **Description**          |\n|----------------|----------|:--------------------:|--------------------------|\n| `data`         | binary   | <Icon icon=\"check\"/> | Content of the entry     |\n| `files`        | File[]   | <Icon icon=\"check\"/> | List of attached files   |\n| `authorPubKey` | string   |                      | Public key of the author |",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/inboxes/inbox-entries.mdx",
        "type": "mdx",
        "chunkIndex": 0,
        "headers": [
          "About Entries"
        ],
        "title": "About Entries",
        "lastModified": "2025-06-05T19:33:57.870Z",
        "size": 1181
      }
    },
    {
      "pageContent": "## Define Data Structure\n\nInbox's architecture does not require you to use a specific data structure inside the entries.\n**Before working with Inboxes, define the structure of your entries**.\n\n:::info\n\nWe recommend future-proofing your entries by choosing an easily modifiable format. It is a good idea to include both a `type` and a `version` field in the structure.\n\n:::\n\n### Example: Form with Text Answer\n\n``` json title=\"JSON\" \n{\n    “content”: {\n        \"answer\": USER_PROVIDED_TEXT\n    },\n    “version”:number,\n    “type”: \"text_answer\",\n}\n```\nThe `type` field allows future support for different types of entries like: `\"select_answer\"`, or `\"multi_select\"`.\nAnd in case of changing the schema, you can always distinguish between them using `\"version\"` field.\n\nRemember that this is only an example and you should consider your app's requirements and limitations.\n\n## Submitting Entries\n\nTo submit an entry, you need:\n\n- URL of your PrivMX Bridge Instance\n- Solution ID with at least one Inbox created\n- ID of the Inbox to submit the entry\n\nIf you need more information about how to create an Inbox, go to [Creating Inbox](./usage#creating-inbox).",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/inboxes/inbox-entries.mdx",
        "type": "mdx",
        "chunkIndex": 1,
        "headers": [
          "Define Data Structure",
          "Example: Form with Text Answer",
          "Submitting Entries"
        ],
        "title": "Define Data Structure",
        "codeBlocks": [
          "``` json title=\"JSON\" \n{\n    “content”: {\n        \"answer\": USER_PROVIDED_TEXT\n    },\n    “version”:number,\n    “type”: \"text_answer\",\n}\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.870Z",
        "size": 1155
      }
    },
    {
      "pageContent": "## Sending Process\n\nSending entries is carried out in two (or three if files are attached) steps.\n\n\n<div className=\"fd-steps\">\n<div className=\"fd-step\">\n\n     ### Preparing Entry\n\n    Use the `prepareEntry` method to provide the Inbox ID and the data you want to submit. Optionally, you can provide file handles and a private key.\n\n    If you don't want to send any files, pass an empty array for the file handles.\n\n    <Tabs groupId=\"lang\" items={[\"JavaScript\"]}>\n    <Tab >\n        ```js\n        const entryData = {\n        content: {\n        \"answer\": USER_PROVIDED_TEXT\n    },\n        version:number,\n        type: \"text_answer\",\n    }\n\n        const entryHandle = await inboxApi.prepareEntry(\n        inboxID,\n        this.strToUint8(JSON.stringify(entryData)),\n        []\n        );\n        ```\n    </Tab>\n</Tabs>\n</div>\n\n<div className=\"fd-step\">\n ### Sending Entry\n\nAfter preparing an entry you will receive an Inbox handle.\nIn this case, all you have to do is pass it to `sendEntry` method.\n\n<Tabs groupId=\"lang\" items={[\"JavaScript\"]}>\n    <Tab >\n        ```js\n        // previous code\n        await inboxApi.sendEntry(entryHandle)\n        ```\n\n    </Tab>\n</Tabs>\n</div>\n</div>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/inboxes/inbox-entries.mdx",
        "type": "mdx",
        "chunkIndex": 2,
        "headers": [
          "Sending Process"
        ],
        "title": "Sending Process",
        "codeBlocks": [
          "```js\n        const entryData = {\n        content: {\n        \"answer\": USER_PROVIDED_TEXT\n    },\n        version:number,\n        type: \"text_answer\",\n    }\n\n        const entryHandle = await inboxApi.prepareEntry(\n        inboxID,\n        this.strToUint8(JSON.stringify(entryData)),\n        []\n        );\n        ```",
          "```js\n        // previous code\n        await inboxApi.sendEntry(entryHandle)\n        ```"
        ],
        "lastModified": "2025-06-05T19:33:57.870Z",
        "size": 1187
      }
    },
    {
      "pageContent": "## Working With Files\n\nInbox entries can include any number of files (in accordance with the predefined Inbox file configuration).\n\nEach file may include its own public and private metadata to store additional information.\n\nFor example, to include file name and mimetype information, pass this data as JSON to the `publicMeta` (or `privateMeta`, if the file name contains sensitive information):\n\nFor example:\n\n``` json title=\"privateMeta\"\n{\n    \"name\":FILE_NAME,\n    \"mimetype\": FILE_MIMETYPE\n}\n```",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/inboxes/inbox-entries.mdx",
        "type": "mdx",
        "chunkIndex": 3,
        "headers": [
          "Working With Files"
        ],
        "title": "Working With Files",
        "codeBlocks": [
          "``` json title=\"privateMeta\"\n{\n    \"name\":FILE_NAME,\n    \"mimetype\": FILE_MIMETYPE\n}\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.870Z",
        "size": 499
      }
    },
    {
      "pageContent": "## Attaching Files\n\nSending entries with attached files follows a similar process to sending entries without files.\nThe main difference is that you must create file handles for each file and stream their content.\n\n<div className=\"fd-steps\">\n    <div className=\"fd-step\">\n        ### Preparing Entry\n        For each file you want to send, create a file handle.\n        You can provide additional data, e.g. file name or its metadata.\n\n        If you’re creating a questionnaire, you can relate files with questions\n        by putting question info in the file's metadata.\n\n        <Tabs groupId=\"lang\" items={[\"JavaScript\"]}>\n            <Tab>\n                ```js\n                const selectedFile = //File selected by user\n\n                const filePrivateMeta = {\n                name: selectedFile.name,\n                mimetype: selectedFile.type\n            }\n\n                const fileHandle = inboxApi.createFileHandle(\n                strToUin8(\"\"),\n                strToUin8(JSON.stringify(filePrivateMeta)),\n                selectedFile.size\n                )",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/inboxes/inbox-entries.mdx",
        "type": "mdx",
        "chunkIndex": 4,
        "headers": [
          "Attaching Files"
        ],
        "title": "Attaching Files",
        "lastModified": "2025-06-05T19:33:57.870Z",
        "size": 1074
      }
    },
    {
      "pageContent": "// preparing entry as shown before\n                const entryHandle = await inboxApi.prepareEntry(\n                inboxID,\n                this.strToUint8(JSON.stringify(entryData)),\n                [fileHandle]\n                );\n                ```\n            </Tab>\n        </Tabs>\n    </div>\n    <div className={'fd-step'}>\n        ### Sending File Contents\n        For large files, it is recommended to stream the file content in small buffers rather than loading the entire\n        file into memory.\n        PrivMX Endpoint divides those buffers if required, then streams\n        them to your PrivMX Bridge.\n\n        <Tabs groupId=\"lang\" items={[\"JavaScript\"]}>\n            <Tab>\n                ```js\n                //previous code\n                const reader = await selectedFile.stream().getReader()\n\n                while(true){\n                const {done, value} = await reader.read();\n\n                if(done){\n                break;\n            }",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/inboxes/inbox-entries.mdx",
        "type": "mdx",
        "chunkIndex": 5,
        "codeBlocks": [
          "```\n            </Tab>\n        </Tabs>\n    </div>\n    <div className={'fd-step'}>\n        ### Sending File Contents\n        For large files, it is recommended to stream the file content in small buffers rather than loading the entire\n        file into memory.\n        PrivMX Endpoint divides those buffers if required, then streams\n        them to your PrivMX Bridge.\n\n        <Tabs groupId=\"lang\" items={[\"JavaScript\"]}>\n            <Tab>\n                ```"
        ],
        "lastModified": "2025-06-05T19:33:57.870Z",
        "size": 966
      }
    },
    {
      "pageContent": "while(true){\n                const {done, value} = await reader.read();\n\n                if(done){\n                break;\n            }\n\n                await inboxApi.writeToFile(entryHandle, fileHandle, value)\n            }\n                ```\n            </Tab>\n        </Tabs>\n    </div>\n    <div className={\"fd-step\"}>\n        ### Sending Entry\n        Finally, send the entry in the same way as described before:\n\n        ```js\n        //previous code\n        await inboxApi.sendEntry(entryHandle)",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/inboxes/inbox-entries.mdx",
        "type": "mdx",
        "chunkIndex": 6,
        "codeBlocks": [
          "```\n            </Tab>\n        </Tabs>\n    </div>\n    <div className={\"fd-step\"}>\n        ### Sending Entry\n        Finally, send the entry in the same way as described before:\n\n        ```"
        ],
        "lastModified": "2025-06-05T19:33:57.870Z",
        "size": 503
      }
    },
    {
      "pageContent": "```\n\n    </div>\n</div>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/inboxes/inbox-entries.mdx",
        "type": "mdx",
        "chunkIndex": 7,
        "lastModified": "2025-06-05T19:33:57.870Z",
        "size": 22
      }
    },
    {
      "pageContent": "## Fetching Entries\n\n:::info\n\nFetching entries requires decoding them back into their original format. Depending on your data structure, you will need to parse and decode the fetched entries.\\\n\\\nThe process for fetching entries heavily depends on your entry format. Refer back to [Define Data Structure](#define-data-structure) if you need guidance on how to structure your entry.\n\n:::\n\n### Basic Entries\n\nAfter fetching entries, you must first decrypt them back to their original format.\nFor schema used [earlier](#example-form-with-text-answer), this process looks like this:\n<Tabs groupId=\"lang\" items={[\"JavaScript\"]}>\n    <Tab label=\"JavaScript\">\n        ```js\n        //define how much you want to fetch and skip\n        const defaultQuery = {skip:0, limit:100, sortOrder: \"asc\"}\n        const readList = inboxApi.listEntries(inboxId, defaultQuery)\n\n        const decodedEntries = readList.readItems(entry => {\n        return {\n        ...entry,\n        data: JSON.parse(uint8ToStr(entry.data))\n    }\n    })\n        ```\n    </Tab>\n</Tabs>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/inboxes/inbox-entries.mdx",
        "type": "mdx",
        "chunkIndex": 8,
        "headers": [
          "Fetching Entries",
          "Basic Entries"
        ],
        "title": "Fetching Entries",
        "codeBlocks": [
          "```js\n        //define how much you want to fetch and skip\n        const defaultQuery = {skip:0, limit:100, sortOrder: \"asc\"}\n        const readList = inboxApi.listEntries(inboxId, defaultQuery)\n\n        const decodedEntries = readList.readItems(entry => {\n        return {\n        ...entry,\n        data: JSON.parse(uint8ToStr(entry.data))\n    }\n    })\n        ```"
        ],
        "lastModified": "2025-06-05T19:33:57.870Z",
        "size": 1044
      }
    },
    {
      "pageContent": "### Entries with Files\n\nEntries include only file metadata, without their contents.\nSimilar to entries data, you have to decode them before using.\n\nFor example, if you saved name and metadata of a file in its `privateMeta`,\nyou can read them like this:\n<Tabs groupId=\"lang\" items={[\"JavaScript\"]}>\n    <Tab >\n        ```js\n        //define how much you want to fetch and skip\n        const defaultQuery = {skip:0, limit:100, sortOrder: \"asc\"}\n        const readList = inboxApi.listEntries(inboxId, defaultQuery)\n\n        const decodedEntries = readList.readItems(entry => {\n        //decoding file meta first\n        const decodedFiles = entry.files.map(file => {\n        return {\n        ...file,\n        privateMeta:JSON.parse(uint8ToStr(file.privateMeta)),\n    }\n    })\n        return {\n        ...entry,\n        data: JSON.parse(uint8ToStr(entry.data)),\n        files:decodedFiles\n    }\n    })\n        ```\n    </Tab>\n</Tabs>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/inboxes/inbox-entries.mdx",
        "type": "mdx",
        "chunkIndex": 9,
        "headers": [
          "Entries with Files"
        ],
        "title": "Entries with Files",
        "codeBlocks": [
          "```js\n        //define how much you want to fetch and skip\n        const defaultQuery = {skip:0, limit:100, sortOrder: \"asc\"}\n        const readList = inboxApi.listEntries(inboxId, defaultQuery)\n\n        const decodedEntries = readList.readItems(entry => {\n        //decoding file meta first\n        const decodedFiles = entry.files.map(file => {\n        return {\n        ...file,\n        privateMeta:JSON.parse(uint8ToStr(file.privateMeta)),\n    }\n    })\n        return {\n        ...entry,\n        data: JSON.parse(uint8ToStr(entry.data)),\n        files:decodedFiles\n    }\n    })\n        ```"
        ],
        "lastModified": "2025-06-05T19:33:57.870Z",
        "size": 928
      }
    },
    {
      "pageContent": "---\ntitle: Inbox Updates\n---\n\n      Tabs, Tab} from \"fumadocs-ui/components/tabs\"\n\n\nEvents play a crucial role in modern applications, allowing them to instantly respond to changes in stored data. Monitoring and reacting to entries and Inbox-related events, is essential for maintaining up-to-date records, triggering workflows, and ensuring synchronization across various parts of the system.\n\n## Types of Events\n\nBefore receiving Events, your application must first subscribe to a group of events.\nIn the case of Inbox, types of events are the following:\n\nInbox events:\n- `inboxCreated` - triggers when a new Inbox is created in your Context\n- `inboxDeleted` - triggers when an Inbox is deleted from your Context\n- `inboxUpdated` - triggers when an Inbox is updated in your Context\n\nEntry events:\n- `inboxEntryCreated` - triggers when an entry is sent to an Inbox\n- `inboxEntryDeleted` - triggers when an entry is deleted from an Inbox",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/inboxes/inbox-updates.mdx",
        "type": "mdx",
        "chunkIndex": 0,
        "headers": [
          "Types of Events"
        ],
        "title": "Types of Events",
        "lastModified": "2025-06-05T19:33:57.870Z",
        "size": 937
      }
    },
    {
      "pageContent": "## Handling Inbox Events\n\n:::info\n\nThe sample code on this page is based on the same **[assumptions](./usage#initial-assumptions)** mentioned in [Working with Inboxes](./usage).\n\n:::\n\nHere is an example of how to do it in your own project:\n<Tabs groupId=\"lang\" items={[\"JavaScript\"]}>\n\n<Tab >\nStart by getting `eventQueue` instance using Endpoint:\n\n```js\nconst eventQueue = await Endpoint.getEventQueue()",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/inboxes/inbox-updates.mdx",
        "type": "mdx",
        "chunkIndex": 1,
        "headers": [
          "Handling Inbox Events"
        ],
        "title": "Handling Inbox Events",
        "lastModified": "2025-06-05T19:33:57.870Z",
        "size": 404
      }
    },
    {
      "pageContent": "```\n\n`EventQueue` provides `waitEvent` method that blocks main browser's thread.\nTo avoid freezing the entire app:\n\n```js\n    const eventQueue = await EndpointFactory.getEventQueue();\n    let listenForEventsPromise = null;\n\n    function listenForEvents(queue) {\n        if (!listenForEventsPromise) {\n            listenForEventsPromise = queue.waitEvent();\n            listenForEventsPromise.then(result => {\n                console.log(\"Event Received:\", result);\n                listenForEventsPromise = null;\n                listenForEvents(queue);\n            })\n        }\n    }\n\n    listenForEvents(eventQueue);\n```\n</Tab>\n</Tabs>\n\nYou can now subscribe for events you need:\n<Tabs groupid=\"lang\" items={[\"JavaScript\"]}>\n    <Tab >\n        ```js\n        await inboxApi.subscribeForInboxEvents()\n        ```\n        or\n        ```js\n        await inboxApi.subscribeForEntryEvents(inboxID)\n        ```\n        When no longer needed, you can unsubscribe from events:\n\n        ```js\n        await inboxApi.unSubscribeForInboxEvents()\n        ```\n    </Tab>\n</Tabs>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/inboxes/inbox-updates.mdx",
        "type": "mdx",
        "chunkIndex": 2,
        "codeBlocks": [
          "```\n\n`EventQueue` provides `waitEvent` method that blocks main browser's thread.\nTo avoid freezing the entire app:\n\n```",
          "```\n</Tab>\n</Tabs>\n\nYou can now subscribe for events you need:\n<Tabs groupid=\"lang\" items={[\"JavaScript\"]}>\n    <Tab >\n        ```",
          "```\n        or\n        ```",
          "```\n        When no longer needed, you can unsubscribe from events:\n\n        ```"
        ],
        "lastModified": "2025-06-05T19:33:57.870Z",
        "size": 1064
      }
    },
    {
      "pageContent": "---\ntitle: Overview\n---\n\nInbox is a special kind of communication tool used for **one-way communication with external users**.\n\nAn authorized PrivMX user can create an Inbox, configure its snippet and place it in a desired place (like a webpage or an app). **Anonymous, unregistered users can send data to the Inbox**.\nThis procedure uses Inbox Public Key, which allows to write data to an Inbox. One time access assures that the writer has no possibility of reading the data once it's sent.\n \nInboxes can be organized as source-specific containers, where anonymous users from each source can **securely submit encrypted data** (messages/forms/files). \nAll the active users are notified right away when new data arrives. The data can be plain text or binary.\n\nAll the data is stored in the Bridge and can be freely accessed by authorized users.\n\n## Use Cases\n\nInboxes are ideal for creating public online forms that collect sensitive information.\nAll submitted data is encrypted before transmission, using a one-time private key generated on the user’s device.\nSubmitted entries are only available to users with access to the given Inbox.",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/inboxes/overview.mdx",
        "type": "mdx",
        "chunkIndex": 0,
        "headers": [
          "Use Cases"
        ],
        "title": "Use Cases",
        "lastModified": "2025-06-05T19:33:57.871Z",
        "size": 1138
      }
    },
    {
      "pageContent": "## Prerequisites\n\nBefore working with Inboxes, you need to have a PrivMX Bridge instance.\n\nTo install it, [follow our PrivMX quick start guide](../quick-start).\n\n## Architecture\n\nInboxes are containers for anonymous submissions. Think of an Inbox as a container that allows anonymous sources to send submissions with attachments (such as a form from your company's webpage). \nEach Inbox has its own set of permissions, managed by assigning the users’ public keys. **Only the users with assigned public keys can read data submitted to that Inbox**.\nDecryption of the data is possible only with the corresponding private keys.\n\nInboxes use public key access for submitting any data by anonymous users. Dual-layer encryption for accessing this data, ensures that the system remains both safe and efficient. \n\nThe following diagram is a visual reference for the architecture of Inboxes:\n![privmx inboxes encryption](/img/privmx-inboxes.svg)",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/inboxes/overview.mdx",
        "type": "mdx",
        "chunkIndex": 1,
        "headers": [
          "Prerequisites",
          "Architecture"
        ],
        "title": "Prerequisites",
        "lastModified": "2025-06-05T19:33:57.871Z",
        "size": 936
      }
    },
    {
      "pageContent": "## Encryption in Inboxes\n\nOnly an end user can create an Inbox, by providing a set of public keys for the users who should have access to the Inbox.\n\nAn asymmetric public key is used to write to the Inbox, which allows anonymous external users to submit Inbox entries.\n\nA key for reading the Inbox (Inbox Encryption Key) is generated always **by the Inbox author/owner** and securely stored on the server, encrypted using public keys of **users assigned to the Inbox and all its submissions**.\nThis ensures that only the authorized users can access the Inbox Encryption Key. **Unencrypted keys never leave user Endpoints.**\n\nWhen accessing an Inbox and its submissions, the encrypted Inbox Encryption Key is securely transmitted based on the users' permissions. Only the users with proper Private Keys can decrypt Inbox Encryption Key.\nUsing this key, submissions are decrypted in the Endpoint environment.\n\nThis process is handled by PrivMX Endpoint library and is completely seamless for Endpoint users.",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/inboxes/overview.mdx",
        "type": "mdx",
        "chunkIndex": 2,
        "headers": [
          "Encryption in Inboxes"
        ],
        "title": "Encryption in Inboxes",
        "lastModified": "2025-06-05T19:33:57.871Z",
        "size": 1005
      }
    },
    {
      "pageContent": "---\ntitle: Working with Inboxes\n---\n\n      Tabs, Tab} from \"fumadocs-ui/components/tabs\"\n\nInboxes provide a secure way to receive entries from both internal and external sources.\n\n- Entries can contain binary data and files.\n- Each [Context](../architecture#contexts) can contain any number of Inboxes with unique identifiers (`inboxId`) used to distinguish them.\n- Everyone with access to `inboxID`, `solutionID`, and Bridge URL can send an entry, but only the users who are added to given Inbox can read them.",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/inboxes/usage.mdx",
        "type": "mdx",
        "chunkIndex": 0,
        "lastModified": "2025-06-05T19:33:57.871Z",
        "size": 511
      }
    },
    {
      "pageContent": "## Permissions\n\nThe user list in Inbox is designed to be flexible, accommodating a wide range of use cases.\n\nInboxes differentiate three types of users: Regular Users, Managers, and External Users. The table below shows what actions can be performed by each type of users:\n\n| **Activity**       | **User** | **Manager** | **External** |\n|--------------------|----------|-------------|--------------|\n| Submitting entries | yes      | yes         | yes          |\n| Fetching entries   | yes      | yes         | no           |\n| Deleting entries   | no       | yes         | no           |\n| Editing Inbox      | no       | yes         | no           |\n\nThe values above are the default policy values defined by PrivMX. To read more about Policies and learn how to modify them, go to [Policies](../concepts/policies).",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/inboxes/usage.mdx",
        "type": "mdx",
        "chunkIndex": 1,
        "headers": [
          "Permissions"
        ],
        "title": "Permissions",
        "lastModified": "2025-06-05T19:33:57.871Z",
        "size": 816
      }
    },
    {
      "pageContent": "## Initial Assumptions\nThe initial assumptions for all the code examples below are as follows:\n\n:::info\n\nReplace placeholder values such as `BRIDGE_URL`, `SOLUTION_ID`, `CONTEXT_ID`\nwith those corresponding to your PrivMX Bridge instance.\\\n\\\nThe private keys here are for demonstration purposes only.\nNormally, they should be kept separately by each user and stored in a safe place,\nor generated from a password (see the [`derivePrivateKey()`](../../reference/endpoint/crypto/crypto-api#deriveprivatekey) method in Crypto API)\n\n:::\n\n<Tabs items={[\"JavaScript\"]}>\n<Tab>\n\n```js\nconst BRIDGE_URL = \"http://localhost:9111\";\nconst SOLUTION_ID = \"YOUR_SOLUTION_ID\";\nconst CONTEXT_ID = \"YOUR_CONTEXT_ID\";\n\nconst USER1_ID = \"user_1\";\nconst USER1_PUBLIC_KEY = \"PUBLIC_KEY_1\";\nconst USER1_PRIV = \"PRIVATE_KEY_1\";\n\nconst USER2_ID = \"user_2\";\nconst USER2_PUBLIC_KEY = \"PUBLIC_KEY_2\";\n\nconst USER3_ID = \"user_3\";\nconst USER3_PUBLIC_KEY = \"PUBLIC_KEY_3\";\n\n//helper functions for encoding and decoding strings\nfunction uint8ToStr(arr) {\n    return (new TextDecoder()).decode(arr);\n}\n\nfunction strToUint8(text) {\n    return (new TextEncoder()).encode(text);\n}",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/inboxes/usage.mdx",
        "type": "mdx",
        "chunkIndex": 2,
        "headers": [
          "Initial Assumptions"
        ],
        "title": "Initial Assumptions",
        "lastModified": "2025-06-05T19:33:57.871Z",
        "size": 1143
      }
    },
    {
      "pageContent": "function strToUint8(text) {\n    return (new TextEncoder()).encode(text);\n}\n\n// Initialize Endpoint and its Wasm assets\nawait Endpoint.setup(\"/public\");\n\n// initialize Endpoint connection, Threads API, Store API\nconst connection = await Endpoint.connect(USER1_PRIV, SOLUTION_ID, BRIDGE_URL);\nconst threadApi = await Endpoint.createThreadApi(connection);\nconst storeApi = await Endpoint.createStoreApi(connection);\n\n// Inbox API require Thread API and Store API instance\nconst inboxApi = await Endpoint.createInboxApi(connection,threadApi,storeApi);\n```\n</Tab>\n\n</Tabs>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/inboxes/usage.mdx",
        "type": "mdx",
        "chunkIndex": 3,
        "lastModified": "2025-06-05T19:33:57.871Z",
        "size": 567
      }
    },
    {
      "pageContent": "## Creating Inbox\n\nTo create an Inbox, you need to name it and provide a list of **public key - userID** pairs.\nDue to the fact that each Inbox is inside a Context, all the public keys have to be registered inside the given Context.\nYou can do it using Bridge API [`context/addUserToContext`](https://bridge.privmx.dev/#context-addusertocontext) method.\n\nWhile creating an Inbox, you can also provide additional information:\n\n- `publicMeta` contains additional info about the Inbox. It is not encrypted before sending to PrivMX Bridge.\n    Inbox API provides methods for accessing this field as `publicView`. For more information about Inbox `publicView` and\n    its common use cases go to [Using Public View](#using-public-view).\n\n- `privateMeta` this field will be encrypted by PrivMX Endpoint before sending to PrivMX Bridge.\n    It's meant to store additional sensitive information about the Inbox. `privateMeta` is accessible only for users registered to the given Inbox.\n\n- `filesConfig` you can specify up front file requirements for each entry submitted to the Inbox.\n    This config includes min and max count of files in an entry, their max size, but also max size of whole upload.",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/inboxes/usage.mdx",
        "type": "mdx",
        "chunkIndex": 4,
        "headers": [
          "Creating Inbox"
        ],
        "title": "Creating Inbox",
        "lastModified": "2025-06-05T19:33:57.871Z",
        "size": 1191
      }
    },
    {
      "pageContent": "- `policy` determines what actions will be available to specific users. For more information and use cases, go to [Policies](../concepts/policies).\n\nPublic and private metadata is sent in binary format.\n\nAfter creating an Inbox, all the users with management rights will be able to edit it. Skip to [Modifying Inboxes](#modifying-inboxes) for more info.\n\nThe examples below demonstrate how to create Inboxes:\n\n<Tabs   items={[\"JavaScript\"]}>\n<Tab>\nCreate a new Inbox with access for `user_1` as a manager and `user_2` as  a regular user.\nYou can include the name of the Inbox within the `privateMeta` object. This metadata is encrypted before being sent to PrivMX Bridge, ensuring its confidentiality.\n\n```js\nconst managers = [\n    {userId: USER1_ID, pubKey: USER1_PUBLIC_KEY}\n];\n\nconst users = [\n    {userId: USER1_ID, pubKey: USER1_PUBLIC_KEY},\n    {userId: USER2_ID, pubKey: USER2_PUBLIC_KEY}\n];\n\nconst storeId = await inboxApi.createInbox(\n    CONTEXT_ID,\n    users,\n    managers,\n    this.strToUint8(\"some store's public meta-data\"),\n    this.strToUint8(JSON.stringify({\n        name: \"some_store\"\n    }))\n);\n```\n</Tab>\n\n</Tabs>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/inboxes/usage.mdx",
        "type": "mdx",
        "chunkIndex": 5,
        "codeBlocks": [
          "```js\nconst managers = [\n    {userId: USER1_ID, pubKey: USER1_PUBLIC_KEY}\n];\n\nconst users = [\n    {userId: USER1_ID, pubKey: USER1_PUBLIC_KEY},\n    {userId: USER2_ID, pubKey: USER2_PUBLIC_KEY}\n];\n\nconst storeId = await inboxApi.createInbox(\n    CONTEXT_ID,\n    users,\n    managers,\n    this.strToUint8(\"some store's public meta-data\"),\n    this.strToUint8(JSON.stringify({\n        name: \"some_store\"\n    }))\n);\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.871Z",
        "size": 1133
      }
    },
    {
      "pageContent": "</Tabs>\n\n<Callout>\nManagers declared while creating the Inbox, also have to be included in the regular user list.\n</Callout>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/inboxes/usage.mdx",
        "type": "mdx",
        "chunkIndex": 6,
        "lastModified": "2025-06-05T19:33:57.871Z",
        "size": 124
      }
    },
    {
      "pageContent": "## Listing Inboxes\n\nYour application may include multiple Inboxes, each associated with different Contexts.\nYou can retrieve a **list of all Inboxes within a given Context.**\nThis list, alongside the metadata you sent while creating the Inbox, will include useful metadata about the Inbox, such as the creation date,\nlast file upload date, user list, and information about the last modification.\n\nPrivMX Endpoint **takes care of decrypting received data**, which means you only have to take care of decoding them from\nbinary format.\n\nHere's an example of how to download the last 30 Inboxes created within a Context:\n\n<Tabs   items={[\"JavaScript\"]}>\n\n<Tab >\n```js\nconst query: Types.PagingQuery = {skip: 0, limit: 30, sortOrder: \"desc\"};\n\nconst result = await inboxApi.listInboxes(CONTEXT_ID, query);\nfor (const inbox of result.readItems) {\n    console.log(\"Inbox ID: \", store.storeId);\n\n    // Decode the data back into a string and parse its content\n    const privateMeta = JSON.parse(uint8ToStr(inbox.privateMeta))\n    console.log(privateMeta)\n}",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/inboxes/usage.mdx",
        "type": "mdx",
        "chunkIndex": 7,
        "headers": [
          "Listing Inboxes"
        ],
        "title": "Listing Inboxes",
        "lastModified": "2025-06-05T19:33:57.871Z",
        "size": 1048
      }
    },
    {
      "pageContent": "```\n\n</Tab>\n</Tabs>\n\nTo limit collecting too much data when downloading Inboxes, specify the page index (starting from 0) and the number of items to be included on each page.",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/inboxes/usage.mdx",
        "type": "mdx",
        "chunkIndex": 8,
        "lastModified": "2025-06-05T19:33:57.871Z",
        "size": 174
      }
    },
    {
      "pageContent": "## Modifying Inboxes\n\nDepending on your project's specification, it may be necessary to modify an Inbox.\nIt could be, for example, changing the name or adding/removing users.\nEach user with management rights is able to modify Inboxes, delete them as a whole or only particular entries.\n\nUpdating an Inbox means overwriting it with the provided data.\nTo successfully update an Inbox, you must specify its current `version`.\nThe `version` field is mandatory to handle multiple updates on the server, and it is incremented by 1 with each update.\n\nBelow there is an example of modifying an Inbox:\n\n<Tabs groupId=\"lang\" items={[\"JavaScript\"]}>\n\n\n<Tab>\n```js\n// Add a new user to the existing ones in the Inbox\nconst newUsersList = [\n    {userId: USER1_ID, pubKey: USER1_PUBLIC_KEY},\n    {userId: USER2_ID, pubKey: USER2_PUBLIC_KEY},\n    {userId: USER3_ID, pubKey: USER3_PUBLIC_KEY}\n];\n\nconst inbox = await inboxApi.getInbox(inboxId);\n\n// Edit the Inbox name\nconst privateMeta = JSON.parse(uint8ToStr(inbox.privateMeta));\nprivateMeta.name = \"New Inbox Name\";",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/inboxes/usage.mdx",
        "type": "mdx",
        "chunkIndex": 9,
        "headers": [
          "Modifying Inboxes"
        ],
        "title": "Modifying Inboxes",
        "lastModified": "2025-06-05T19:33:57.871Z",
        "size": 1052
      }
    },
    {
      "pageContent": "const inbox = await inboxApi.getInbox(inboxId);\n\n// Edit the Inbox name\nconst privateMeta = JSON.parse(uint8ToStr(inbox.privateMeta));\nprivateMeta.name = \"New Inbox Name\";\n\nawait inboxApi.updateInbox(\n    inboxId,\n    newUsersList,\n    managers,\n    inbox.publicMeta,\n    strToUint8(JSON.stringify(privateMeta)),\n    inbox.version,\n    false,                                   // force\n    false                                    // forceGenerateNewKey\n);\n```\n</Tab>\n\n\n</Tabs>\n\nThree additional options are available when changing the list of users inside an Inbox:\n- `force` - applies an update, without checking the current version.\n- `forceGenerateNewKey` - re-encrypts entries in the Inbox. It's useful when a user is removed, and you want to prevent them from accessing the Inbox.\n- `policy` - you can also pass a new policy object as the last optional argument.",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/inboxes/usage.mdx",
        "type": "mdx",
        "chunkIndex": 10,
        "lastModified": "2025-06-05T19:33:57.871Z",
        "size": 868
      }
    },
    {
      "pageContent": "## Using Public View\n\nYou can fetch Inbox public view using `getInboxPublicView`.\nPublic view contains the [`publicMeta`](#creating-inbox) field from Inbox.\n\n:::info\n\nKeep in mind that every user with access to Inbox ID can get its public view.\n\n:::\n\nIn Inboxes, `publicMeta` can store information about the required structure of an entry.\n\nFor example, while creating an Inbox, you could save the required fields:\n\n```json publicMeta\n{\n    \"fields\": [\n      {\n        \"type\": \"text\",\n        \"question\": \"Your Name\"},\n      {\n        \"type\": \"select\",\n        \"question\": \"Favorite Language\",\n        \"options\": [\"JavaScript\",\"Java\",\"Swift\",\"C#\"]\n      }\n    ]\n}",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/inboxes/usage.mdx",
        "type": "mdx",
        "chunkIndex": 11,
        "headers": [
          "Using Public View"
        ],
        "title": "Using Public View",
        "lastModified": "2025-06-05T19:33:57.871Z",
        "size": 663
      }
    },
    {
      "pageContent": "```\n\nThen, you can dynamically create a form based on this schema:\n\n<Tabs groupId=\"lang\" items={[\"JavaScript\"]} >\n    <Tab>\n        ```js\n        const publicView = await inboxApi.getInboxPublicView(INBOX_ID)\n        const publicMeta = JSON.parse(uint8ToStr(publicView.publicMeta)\n        ```\n        In React, for example, you could map each of the fields to its input types:\n\n        ```jsx\n        //rest of your component",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/inboxes/usage.mdx",
        "type": "mdx",
        "chunkIndex": 12,
        "codeBlocks": [
          "```\n\nThen, you can dynamically create a form based on this schema:\n\n<Tabs groupId=\"lang\" items={[\"JavaScript\"]} >\n    <Tab>\n        ```",
          "```\n        In React, for example, you could map each of the fields to its input types:\n\n        ```"
        ],
        "lastModified": "2025-06-05T19:33:57.871Z",
        "size": 425
      }
    },
    {
      "pageContent": "```jsx\n        //rest of your component\n\n        <form>\n            {publicMeta.fields.map(field => {\n                switch (field.type) {\n                    case \"text\":\n                        return (\n                            <>\n                            <label>{field.question}</label>\n                            <input type={\"text\"} name={field.question} />\n                            </>\n                        )\n                    case \"select\":\n                        return (\n                            <>\n                            <label>{field.question}</label>\n                            <select name={field.question}>\n                                {field.options.map(option => (\n                                    <option value={option}>{option}</option>\n                                ))}\n                            </select>\n                            </>\n                        )\n                    default:\n                        return <></>\n                }\n            })}\n        </form>\n        ```\n    </Tab>\n</Tabs>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/inboxes/usage.mdx",
        "type": "mdx",
        "chunkIndex": 13,
        "codeBlocks": [
          "```jsx\n        //rest of your component\n\n        <form>\n            {publicMeta.fields.map(field => {\n                switch (field.type) {\n                    case \"text\":\n                        return (\n                            <>\n                            <label>{field.question}</label>\n                            <input type={\"text\"} name={field.question} />\n                            </>\n                        )\n                    case \"select\":\n                        return (\n                            <>\n                            <label>{field.question}</label>\n                            <select name={field.question}>\n                                {field.options.map(option => (\n                                    <option value={option}>{option}</option>\n                                ))}\n                            </select>\n                            </>\n                        )\n                    default:\n                        return <></>\n                }\n            })}\n        </form>\n        ```"
        ],
        "lastModified": "2025-06-05T19:33:57.871Z",
        "size": 1065
      }
    },
    {
      "pageContent": "---\ntitle: Managing Keys\n---\n\nThis page outlines a structured approach to managing private keys (in case of e.g. changing a password), ensuring secure authentication and data access integrity.",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/guides/managing-keys.mdx",
        "type": "mdx",
        "chunkIndex": 0,
        "lastModified": "2025-06-05T19:33:57.872Z",
        "size": 192
      }
    },
    {
      "pageContent": "## Step 1: Private Key Generation and Storage\n\n### Step 1A: Generating Private Key from Password and Username\n\n- Private key is generated automatically using password and username.\n- **Password Change Impact:** Changing the password automatically results in generating a new private key, as it is derived directly from the updated password and username.\n\n### Step 1B: Private Key Stored on Application Server\n\n- Password and username are used for authentication with the application server.\n- The private key is stored securely on the server, encrypted with either the user's password or a key derived from the password.\n\n#### Password Change Process\n\n1.  Password is updated on the server only.\n2.  The old private key is re-encrypted on the client side using the new password or a derived key, and then saved back on the server.\n3.  If the private key requires regeneration:\n    - The new private key is encrypted (with the new password or derived key) and replaces the private key stored on the server.\n4.  If regeneration is not required, the process ends.",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/guides/managing-keys.mdx",
        "type": "mdx",
        "chunkIndex": 1,
        "headers": [
          "Step 1: Private Key Generation and Storage",
          "Step 1A: Generating Private Key from Password and Username",
          "Step 1B: Private Key Stored on Application Server",
          "Password Change Process"
        ],
        "title": "Step 1: Private Key Generation and Storage",
        "lastModified": "2025-06-05T19:33:57.872Z",
        "size": 1060
      }
    },
    {
      "pageContent": "### Step 1C: Regenerating Private Key Without Changing Password\n\n- A new private key is generated.\n- The new key replaces the existing private key on the server, encrypted with the current password or a derived key.",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/guides/managing-keys.mdx",
        "type": "mdx",
        "chunkIndex": 2,
        "headers": [
          "Step 1C: Regenerating Private Key Without Changing Password"
        ],
        "title": "Step 1C: Regenerating Private Key Without Changing Password",
        "lastModified": "2025-06-05T19:33:57.872Z",
        "size": 215
      }
    },
    {
      "pageContent": "## Step 2: Updating Public Key\n\n- The new public key is sent to the application server.\n\n## Step 3: Registering Public Key in Bridge\n\n- The application server registers the new public key in PrivMX Bridge.\n\n**Data Access Impact:**\n\n- The user temporarily loses access to existing data (containers like Thread or Store) they previously had access to.\n- The application server has to notify the Container Manager that access to the data must be refreshed.\n- Only the users with management access to the specific container can restore access for the user.\n\n## Step 4: Restoring Data Access\n\n- The Container Manager in the Endpoint initiates a recovery procedure to refresh data access.\n\n#### Recovery Procedure\n\n1.  All containers are updated with functions such as `threadUpdate` or `storeUpdate` etc.\n2.  The old public key associated with the specific user is replaced with a new public key in the containers.\n3.  The option `force` while updating should be set to `True`.\n\nThis structured approach ensures secure management of private and public keys while maintaining data access integrity during key updates or password changes.",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/guides/managing-keys.mdx",
        "type": "mdx",
        "chunkIndex": 3,
        "headers": [
          "Step 2: Updating Public Key",
          "Step 3: Registering Public Key in Bridge",
          "Step 4: Restoring Data Access",
          "Recovery Procedure"
        ],
        "title": "Step 2: Updating Public Key",
        "lastModified": "2025-06-05T19:33:57.872Z",
        "size": 1131
      }
    },
    {
      "pageContent": "---\ntitle: SMS Notifications\n---\n\nPrivMX Bridge features WebSocket support.\nThis allows you to receive instant notifications about changes, for example:\n* new messages in Threads\n* new files in Stores\n* new items in Inboxes\n\nA common use case is to send SMS notifications when a specific event occurs.\nThe following example shows how to build an SMS notification system using [SMSAPI](https://www.smsapi.com/).\nHowever, you can use any other notification service provider – just remove all the references to SMSAPI and reimplement the `sendSms()` function.\n\n## Prerequisites\n\nTo send SMS notifications, you need to have an [SMSAPI](https://www.smsapi.com/) account.\nYou also need a running PrivMX Bridge instance. Follow the [getting started](../installation) guide to set it up.",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/guides/sms-notifications.mdx",
        "type": "mdx",
        "chunkIndex": 0,
        "headers": [
          "Prerequisites"
        ],
        "title": "Prerequisites",
        "lastModified": "2025-06-05T19:33:57.872Z",
        "size": 779
      }
    },
    {
      "pageContent": "## Subscribing to Notifications\n1. Connect to your PrivMX Bridge instance using WebSockets. See [PrivMX Bridge docs](https://bridge.privmx.dev/) for more information.\n2. Use the [manager/subscribeToChannel](https://bridge.privmx.dev/#manager-subscribetochannel) method to subscribe to notification channel(s).\n3. Handle the incoming notifications and send SMS messages when needed. See [SMSAPI docs](https://www.smsapi.com/docs/?shell#2-single-sms) for more information.\n\nJavaScript example:\n```javascript\nimport { SMSAPI } from \"smsapi\";\nimport WebSocket from \"ws\";\n\n// Config - replace with your data\nconst config = {\n    httpApiUrl: \"http://localhost:9111/api\",\n    wsApiUrl: \"ws://localhost:9111/api\",\n    apiKeyId: \"YOUR_API_KEY_ID\",\n    apiKeySecret: \"YOUR_API_KEY_SECRET\",\n    channels: [\"thread\", \"store\", \"stream\", \"inbox\"],\n    smsApi: {\n        url: \"https://api.smsapi.com/sms.do\",\n        oAuthToken: \"YOUR_SMSAPI_OAUTH_TOKEN\",\n        phoneNumber: \"YOUR_SMSAPI_PHONE_NUMBER\",\n        senderName: \"YOUR_SMSAPI_SENDER_NAME\",\n    },\n};",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/guides/sms-notifications.mdx",
        "type": "mdx",
        "chunkIndex": 1,
        "headers": [
          "Subscribing to Notifications"
        ],
        "title": "Subscribing to Notifications",
        "lastModified": "2025-06-05T19:33:57.872Z",
        "size": 1046
      }
    },
    {
      "pageContent": "// Auth\nconst accessToken = (\n    await (\n        await fetch(config.httpApiUrl, {\n            method: \"POST\",\n            headers: { \"Content-Type\": \"application/json\" },\n            body: JSON.stringify({\n                jsonrpc: \"2.0\",\n                id: 128,\n                method: \"manager/auth\",\n                params: {\n                    grantType: \"api_key_credentials\",\n                    apiKeyId: config.apiKeyId,\n                    apiKeySecret: config.apiKeySecret,\n                },\n            }),\n        })\n    ).json()\n).result.accessToken;\n\n// Create WebSocket\nconst ws = new WebSocket(config.wsApiUrl);\nlet reqId = 1;\nconst reqMap = new Map();\n\n// Bind access token and subscribe to channels when WebSocket opens\nws.onopen = async () => {\n    await request(\"manager/bindAccessToken\", {\n        accessToken: accessToken,\n    });\n    await request(\"manager/subscribeToChannel\", {\n        channels: config.channels,\n    });\n};",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/guides/sms-notifications.mdx",
        "type": "mdx",
        "chunkIndex": 2,
        "lastModified": "2025-06-05T19:33:57.872Z",
        "size": 951
      }
    },
    {
      "pageContent": "// Handle incoming messages\nws.onmessage = (e) => {\n    const data = JSON.parse(e.data);\n    const req = reqMap.get(data.id);\n    if (req) {\n        if (data.error) {\n            req.reject(data.error);\n        } else {\n            req.resolve(data.result);\n        }\n    } else {\n        // Act on selected messages - customize as needed\n        if (\n            data.channel === \"thread\" &&\n            data.type === \"threadNewMessage\" &&\n            data.data.contextId === \"66f76cdc06848d6a6494f783\" &&\n            data.data.threadId === \"6757b81daafe67cb6e19180e\"\n        ) {\n            sendSms(\"New message in thread LoremIpsum\");\n        }\n    }\n};\n\n// Log errors\nws.onerror = (e) => {\n    console.error(\"WebSocket error:\", e);\n};\n\n// WebSocket request helper\nfunction request(method, params) {\n    const id = reqId++;\n    ws.send(\n        JSON.stringify({\n            jsonrpc: \"2.0\",\n            id: id,\n            method: method,\n            params: params,\n        }),\n    );\n    return new Promise((resolve, reject) => {\n        reqMap.set(id, { resolve, reject });\n    });\n}",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/guides/sms-notifications.mdx",
        "type": "mdx",
        "chunkIndex": 3,
        "lastModified": "2025-06-05T19:33:57.872Z",
        "size": 1088
      }
    },
    {
      "pageContent": "// SMS sending function that uses SMSAPI\nconst smsapi = new SMSAPI(config.smsApi.oAuthToken);\nasync function sendSms(message) {\n    try {\n        const result = await smsapi.sms.sendSms(config.smsApi.phoneNumber, message);\n        console.log(\"sendSms result\", result);\n    } catch (err) {\n        console.error(\"sendSms error\", err);\n    }\n}\n```",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/guides/sms-notifications.mdx",
        "type": "mdx",
        "chunkIndex": 4,
        "lastModified": "2025-06-05T19:33:57.872Z",
        "size": 346
      }
    },
    {
      "pageContent": "## Unsubscribing from Notifications\nWhen you no longer want to receive notifications, use the [manager/unsubscribeFromChannel](https://bridge.privmx.dev/#manager-unsubscribefromchannel) method to unsubscribe from the channel(s).\n\nJavaScript example (uses `request()` and `config` from the previous example):\n```javascript\nawait request(\"manager/unsubscribeFromChannel\", {\n    channels: config.channels,\n});\n```",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/guides/sms-notifications.mdx",
        "type": "mdx",
        "chunkIndex": 5,
        "headers": [
          "Unsubscribing from Notifications"
        ],
        "title": "Unsubscribing from Notifications",
        "codeBlocks": [
          "```javascript\nawait request(\"manager/unsubscribeFromChannel\", {\n    channels: config.channels,\n});\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.872Z",
        "size": 410
      }
    },
    {
      "pageContent": "---\ntitle: Access Management\n---\n\nPrivMX platform offers versatile containers like Threads, Stores, and Inboxes to support secure collaboration and communication.\nAccess to these containers is managed based on different user roles and the type of container setup. This ensures that only authorized participants can view and modify the content.\nHere’s a breakdown of how these elements function:\n\n- **Private Users** - Private containers are created and managed by one of the participants (not the owner).\nIn this scenario, access to the container's content is controlled by the participants, not by the system owner.\nThe owner can view content they’ve been granted access to by participants, but cannot modify it. The keys remain entirely with the users, ensuring a high level of privacy.\n\n- **Managed Users** - Managed containers, on the other hand, are created and managed directly by the owner, who has access to all the content within the container.\nWhile this setup allows the owner to monitor and modify everything that flows through the container,\nit also provides a standardized access experience common in many communication systems.",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/guides/user-management.mdx",
        "type": "mdx",
        "chunkIndex": 0,
        "lastModified": "2025-06-05T19:33:57.872Z",
        "size": 1142
      }
    },
    {
      "pageContent": "In practice, these two modes allow PrivMX to balance privacy and control, enabling both highly secure user-controlled spaces and owner-managed containers suited to organizational needs.",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/guides/user-management.mdx",
        "type": "mdx",
        "chunkIndex": 1,
        "lastModified": "2025-06-05T19:33:57.872Z",
        "size": 185
      }
    },
    {
      "pageContent": "## Scenarios\n|                   | **Private Channel**                                                                                                                                                                                                                                           | **Managed Channel**                                                                                                                                                                                                                                        |\n|-------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/guides/user-management.mdx",
        "type": "mdx",
        "chunkIndex": 2,
        "headers": [
          "Scenarios"
        ],
        "title": "Scenarios",
        "lastModified": "2025-06-05T19:33:57.872Z",
        "size": 1074
      }
    },
    {
      "pageContent": "| **Private Users** | [Full User Privacy](#full-user-privacy.mdx) - The owner can only access the content they were granted permission to by the other participants of the container. Therefore, the owner should be directly added as a participant to gain the necessary access.  | [Partially Managed Accounts](#partially-managed-accounts-and-containers ) - The owner has access to the entire content of the container. However, without the necessary private keys, they cannot make any modifications to the content.                            |\n| **Managed Users** | [Managed Users with Impersonation](#managed-accounts-with-impersonation) - The owner can access the content by using the users' private keys. This is possible because the system owner has ownership of the keys, which are stored in the management system. | [Full Access Management](#fully-managed-accounts-and-containers-with-full-access) - The owner can view and modify everything that is transmitted through the container - it's a full access mode to the container's content (which is the standard in typical communication systems). |",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/guides/user-management.mdx",
        "type": "mdx",
        "chunkIndex": 3,
        "lastModified": "2025-06-05T19:33:57.872Z",
        "size": 1097
      }
    },
    {
      "pageContent": "### Potential Threats\nEach scenario introduces distinct security challenges and privacy implications:\n\n- **Full User Privacy** – ensures maximum privacy, but carries the risk of data loss if users lose access to their accounts. Additionally, there is a potential for undetected breaches if a user’s device is compromised (if the private key is stored locally). However, the keys can be deterministically generated from user-provided data as an alternative.\n- **Partially Managed Accounts** – faces risks related to insider threats and potential misuse of read-only access, as administrators may still view sensitive data under certain conditions.\n- **Managed Users with Impersonation** – introduces the risk of unauthorized access, if the owner's credentials or users' private keys are compromised. Since the users' private keys are stored by the system's owner, they could be vulnerable to breaches. It's up to the developer to secure them properly.\n- **Full Access Management** – presents a heightened risk of data manipulation, insider threats, and challenges in securely managing and storing private keys within the system.",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/guides/user-management.mdx",
        "type": "mdx",
        "chunkIndex": 4,
        "headers": [
          "Potential Threats"
        ],
        "title": "Potential Threats",
        "lastModified": "2025-06-05T19:33:57.872Z",
        "size": 1127
      }
    },
    {
      "pageContent": "PrivMX offers flexible configurations to address diverse privacy and management needs.\nThe selected scenario should align with the organization's specific security, compliance, and operational requirements.",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/guides/user-management.mdx",
        "type": "mdx",
        "chunkIndex": 5,
        "lastModified": "2025-06-05T19:33:57.872Z",
        "size": 206
      }
    },
    {
      "pageContent": "## Full User Privacy\n Private Users - Private Containers\n\nA Private Channel is set up by one of the participants, not the system owner, and managed by the users within the container.\nThe owner does not have access to the users' private keys and can only view the content if participants directly grant them access.\n\nThis setup is ideal when privacy is the priority, but some oversight may occasionally be necessary.\nAny external access can be granted only by the participants who set up the container.",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/guides/user-management.mdx",
        "type": "mdx",
        "chunkIndex": 6,
        "headers": [
          "Full User Privacy"
        ],
        "title": "Full User Privacy",
        "lastModified": "2025-06-05T19:33:57.872Z",
        "size": 501
      }
    },
    {
      "pageContent": "### System Roles\nThe table below outlines system roles in this scenario:\n\n| | **Application** | **Application Server** | **PrivMX Bridge**|\n| --- | :---: | :---: |:---: |\n| **Generating Users' Key Pair**               |<Icon icon=\"check\"/> |   |   |\n| **Storing Users' Private Keys**              |<Icon icon=\"check\"/> |   |   |\n| **Storing Users' Public Keys**               |   |<Icon icon=\"check\"/> |   |\n| **Registering Users' Public Keys in Bridge** |   |<Icon icon=\"check\"/> |   |\n| **Creating and managing containers**         |<Icon icon=\"check\"/> |   |   |\n| **Managing System Owner's Public Key**       |<Icon icon=\"check\"/>  |  |   |\n| **Storing always encrypted data**            |   |   |<Icon icon=\"check\"/> |\n\n### Example Applications\n\n- **Research Teams**: Researchers working on sensitive projects or developing new technologies may use this setup to restrict access only to authorized team members, thereby protecting their intellectual property.\n- **Investigative Journalism**: Journalists working on sensitive material can securely communicate and store information within a container inaccessible to platform administrators, safeguarding journalistic sources and data privacy.",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/guides/user-management.mdx",
        "type": "mdx",
        "chunkIndex": 7,
        "headers": [
          "System Roles",
          "Example Applications"
        ],
        "title": "System Roles",
        "lastModified": "2025-06-05T19:33:57.872Z",
        "size": 1197
      }
    },
    {
      "pageContent": "## Partially Managed Accounts and Containers\n### Private Users - Managed Containers\n\nIn this scenario, accounts and containers are managed in a limited way.\nManaged containers are established by the system owner, who has read-only access without the ability to modify any content, as private keys remain entirely with the users.\n\nThis model prioritizes privacy, as the owner cannot interfere or alter content within the container.\n\n### System Roles\nThe table below outlines system roles in this scenario:\n\n|        | **Application** | **Application Server** | **PrivMX Bridge**\n| --- | :---: | :---: | :---: |\n| **Generating Users' Key Pair**               |<Icon icon=\"check\"/> |   |   |\n| **Storing Users' Private Keys**              |<Icon icon=\"check\"/> |   |   |\n| **Storing Users' Public Keys**               |   |<Icon icon=\"check\"/> |   |\n| **Registering Users' Public Keys in Bridge** |   |<Icon icon=\"check\"/> |   |\n| **Creating and managing containers**         |   |<Icon icon=\"check\"/> |   |\n| **Managing System Owner's Public Key**       |   |<Icon icon=\"check\"/> |   |\n| **Storing always encrypted data**            |   |   |<Icon icon=\"check\"/> |",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/guides/user-management.mdx",
        "type": "mdx",
        "chunkIndex": 8,
        "headers": [
          "Partially Managed Accounts and Containers",
          "Private Users - Managed Containers",
          "System Roles"
        ],
        "title": "Partially Managed Accounts and Containers",
        "lastModified": "2025-06-05T19:33:57.872Z",
        "size": 1162
      }
    },
    {
      "pageContent": "### Example Applications\n\n- **Corporate Work Environment**: In workplaces with strict compliance requirements, administrators may have read-only access to certain documents in exceptional circumstances, such as when HR personnel need to resolve conflicts or retrieve lost data.\n- **Public Institutions**: In departments that manage sensitive documents, administrators can have restricted access, which preserves data integrity without allowing them to modify the content.",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/guides/user-management.mdx",
        "type": "mdx",
        "chunkIndex": 9,
        "headers": [
          "Example Applications"
        ],
        "title": "Example Applications",
        "lastModified": "2025-06-05T19:33:57.872Z",
        "size": 471
      }
    },
    {
      "pageContent": "## Managed Accounts with Impersonation\n### Managed Users - Private Containers\n\nIn this model, private containers are still set up by a participant, but the system owner has access to private keys and can utilize these to access content.\nThis access allows administrators to \"impersonate\" users when necessary, to access information stored in these containers.\nIt is suited to environments that require stricter oversight, but do not necessitate regular content modification.\n\nSuch a setup requires the system owner to generate and store all Private Keys in a safe place and use them only in extreme situations.\nSince the users still create their containers, only impersonation (using participant's Private Key) can grant full access to the container content.",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/guides/user-management.mdx",
        "type": "mdx",
        "chunkIndex": 10,
        "headers": [
          "Managed Accounts with Impersonation",
          "Managed Users - Private Containers"
        ],
        "title": "Managed Accounts with Impersonation",
        "lastModified": "2025-06-05T19:33:57.872Z",
        "size": 758
      }
    },
    {
      "pageContent": "### System Roles\nThe table below outlines system roles in this scenario:\n\n|        | **Application** | **Application Server** | **PrivMX Bridge**\n| --- | :---: | :---: | :---: |\n| **Generating Users' Key Pair**               |   |<Icon icon=\"check\"/> |   |\n| **Storing Users' Private Keys**              |   |<Icon icon=\"check\"/> |   |\n| **Storing Users' Public Keys**               |   |<Icon icon=\"check\"/> |   |\n| **Registering Users' Public Keys in Bridge** |   |<Icon icon=\"check\"/> |   |\n| **Creating and managing containers**         |   |<Icon icon=\"check\"/> |   |\n| **Managing System Owner's Public Key**       |<Icon icon=\"check\"/>  |  |   |\n| **Storing always encrypted data**            |   |   |<Icon icon=\"check\"/> |\n\n\n### Example Applications\n\n- **Data Management in Healthcare**: Hospitals may require administrators to access patient records or test results during emergencies, where key management enables rapid access without direct user involvement.\n- **Compliance in Financial Systems**: Financial institutions may need administrators to monitor client resources to comply with regulatory standards, ensuring the information remains auditable.",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/guides/user-management.mdx",
        "type": "mdx",
        "chunkIndex": 11,
        "headers": [
          "System Roles",
          "Example Applications"
        ],
        "title": "System Roles",
        "lastModified": "2025-06-05T19:33:57.872Z",
        "size": 1164
      }
    },
    {
      "pageContent": "## Fully Managed Accounts and Containers with Full Access\n### Managed Users - Managed Containers\n\nIn this scenario, both accounts and containers are fully managed by the system owner, granting them full access to all content.\nThey can view and modify any data within the container, as private keys are stored and controlled by the system owner.\nThis model is typically used in cases requiring comprehensive control over data for security, compliance, or operational efficiency.",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/guides/user-management.mdx",
        "type": "mdx",
        "chunkIndex": 12,
        "headers": [
          "Fully Managed Accounts and Containers with Full Access",
          "Managed Users - Managed Containers"
        ],
        "title": "Fully Managed Accounts and Containers with Full Access",
        "lastModified": "2025-06-05T19:33:57.872Z",
        "size": 477
      }
    },
    {
      "pageContent": "### System Roles\nThe table below outlines system roles in this scenario:\n\n|        | **Application** | **Application Server** | **PrivMX Bridge**\n| --- | :---: | :---: | :---: |\n| **Generating Users' Key Pair**               |   |<Icon icon=\"check\"/> |   |\n| **Storing Users' Key Pair**                  |   |<Icon icon=\"check\"/> |   |\n| **Storing Users' Public Keys**               |   |<Icon icon=\"check\"/> |   |\n| **Registering Users' Public Keys in Bridge** |   |<Icon icon=\"check\"/> |   |\n| **Creating and managing containers**         |   |<Icon icon=\"check\"/> |   |\n| **Managing System Owner's Public Key**       |   |<Icon icon=\"check\"/> |   |\n| **Storing always encrypted data**            |   |   |<Icon icon=\"check\"/> |",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/guides/user-management.mdx",
        "type": "mdx",
        "chunkIndex": 13,
        "headers": [
          "System Roles"
        ],
        "title": "System Roles",
        "lastModified": "2025-06-05T19:33:57.872Z",
        "size": 730
      }
    },
    {
      "pageContent": "### Example Applications\n\n- **Hospital Data Management**: Full access allows administrators and authorized staff to easily share and update patient records as needed. This facilitates prompt decision-making and coordination between specialists.\n- **Financial Regulatory Compliance**: Financial services often require extensive monitoring and control over sensitive documents, enabling administrators to oversee client interactions and document transactions to meet regulatory standards.",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/guides/user-management.mdx",
        "type": "mdx",
        "chunkIndex": 14,
        "headers": [
          "Example Applications"
        ],
        "title": "Example Applications",
        "lastModified": "2025-06-05T19:33:57.872Z",
        "size": 486
      }
    },
    {
      "pageContent": "---\ntitle: Access Control List\n---\nAccess Control List (**ACL**) is a set of **rules that determine which functions a user can access**.\nIt consists of simple instructions using the terms \"**ALLOW**\" or \"**DENY**\" followed by the name of a function or group.\nBy default, an ACL is set to \"**DENY ALL**\". Instructions are executed in the order they are listed.\nIf group scopes overlap, the second instruction will override the overlapping portion.\n\nThe example below allows the user to browse Stores, create files, and use Threads, but doesn't allow to delete Threads or messages:\n\n```\nALLOW store/READ\nALLOW store/storeFileCreate\nALLOW thread/ALL\nDENY thread/deleteThread\nDENY thread/deleteMessage\nDENY thread/deleteManyMessages\nDENY thread/deleteMessagesOlderThan",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/concepts/acl.mdx",
        "type": "mdx",
        "chunkIndex": 0,
        "lastModified": "2025-06-05T19:33:57.873Z",
        "size": 764
      }
    },
    {
      "pageContent": "```\n\nA more detailed explanation and breakdown of the example:\n```\nALLOW store/READ                     => Grants access to all methods in the store/READ group\nALLOW store/storeFileCreate          => Grants access to the storeFileCreate method\nALLOW thread/ALL                     => Grants access to all methods in the thread group\nDENY thread/deleteThread             => Revokes access to the thread/deleteThread method, other thread methods remain unchanged\nDENY thread/deleteMessage            => Revokes access to the thread/deleteMessage method, other thread methods remain unchanged\nDENY thread/deleteManyMessages       => Revokes access to the thread/deleteManyMessages method, other thread methods remain unchanged\nDENY thread/deleteMessagesOlderThan  => Revokes access to the thread/deleteMessagesOlderThan method, other thread methods remain unchanged\n```\n\nIt's also possible to bind an ACL rule to a specific object by using function arguments:\n\n```\n[DIRECTIVE] [scope/method] [parameter]=[argument]\n```\n\nFor example:\n```\nALLOW store/storeFileWrite storeId=65ad8f6c2e4f4f1adb40bf81",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/concepts/acl.mdx",
        "type": "mdx",
        "chunkIndex": 1,
        "codeBlocks": [
          "```\n\nA more detailed explanation and breakdown of the example:\n```",
          "```\n\nIt's also possible to bind an ACL rule to a specific object by using function arguments:\n\n```",
          "```\n\nFor example:\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.873Z",
        "size": 1093
      }
    },
    {
      "pageContent": "```\n\nFor example:\n```\nALLOW store/storeFileWrite storeId=65ad8f6c2e4f4f1adb40bf81\n```\n\nCheck all ACL groups in [PrivMX Bridge API Reference](https://bridge.privmx.dev/#acl-groups-and-functions).",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/concepts/acl.mdx",
        "type": "mdx",
        "chunkIndex": 2,
        "codeBlocks": [
          "```\n\nFor example:\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.873Z",
        "size": 194
      }
    },
    {
      "pageContent": "---\ntitle: Metrics\n---\n\nPrivMX Bridge provides a `/metrics` endpoint that returns various metrics in a format compatible with [Prometheus](https://prometheus.io/). The endpoint is protected by HTTP Basic Authorization for security.\n\n## Metrics Endpoint\n\n- **Endpoint**: `/metrics`\n- **Access Control**: Requires HTTP Basic Authorization\n- **Scrape Interval**: 1 minute (data older than 1 minute is discarded)\n- **Bucket Clearing**: After each metric collection via the `/metrics` endpoint, the internal metrics bucket is cleared. This enables the endpoint to support scrape intervals shorter than 1 minute, if desired.",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/concepts/metrics.mdx",
        "type": "mdx",
        "chunkIndex": 0,
        "headers": [
          "Metrics Endpoint"
        ],
        "title": "Metrics Endpoint",
        "lastModified": "2025-06-05T19:33:57.873Z",
        "size": 618
      }
    },
    {
      "pageContent": "## Metrics Collected\nThe following metrics are available from the `/metrics` endpoint:\n\n1. `privmx_bridge_error_gauge`\n - Type: Gauge\n - Description: Tracks the number of errors.\n2. `privmx_bridge_cpu_execution_time_gauge`\n - Type: Gauge\n - Description: Measures the CPU time taken for executions.\n3. `privmx_bridge_in_traffic_gauge`\n - Type: Gauge\n - Description: Records incoming traffic volume in bytes.\n4. `privmx_bridge_out_traffic_gauge`\n - Type: Gauge\n - Description: Records outgoing traffic volume in bytes.\n5. `privmx_bridge_request_gauge`\n - Type: Gauge\n - Description: Counts the number of requests.\n\nEach of these metrics is exposed with the `# TYPE <metric_name>` gauge format.",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/concepts/metrics.mdx",
        "type": "mdx",
        "chunkIndex": 1,
        "headers": [
          "Metrics Collected"
        ],
        "title": "Metrics Collected",
        "lastModified": "2025-06-05T19:33:57.873Z",
        "size": 691
      }
    },
    {
      "pageContent": "---\ntitle: Policies\n---\n\n       Accordion, Accordions } from 'fumadocs-ui/components/accordion';\n\n\nPolicies determine who is allowed to perform specific actions. You can define your policy on three levels: for a Context, for a Container (Thread, Store, etc), and for items such as messages or files, in case of Containers that include them.\n\nThis section covers policies in the Containers' scope.",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/concepts/policies.mdx",
        "type": "mdx",
        "chunkIndex": 0,
        "lastModified": "2025-06-05T19:33:57.874Z",
        "size": 396
      }
    },
    {
      "pageContent": "## Overview\nSetting a policy in the Container overwrites the policy from the Context.\nThe property of the policy can be set to one of the following values:\n\n- \"default\" - takes the default value, [listed below](#default-policy-values)\n- \"inherit\" - always takes value from the Context (can only be used in Container and item policies)\n- \"none\" - no one can perform this action\n- \"all\" - all Context users can perform this action\n- \"user\" - all Container users can perform this action\n- \"manager\" - all Container managers can perform this action\n- \"owner\" - only Container owner can perform this action\n- \"itemOwner\" - only item owner can perform this action (can only be used in the item policy)\n\nLeaving an empty policy in a Container or item policy results in `inherit`. In Context it results in `default`.",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/concepts/policies.mdx",
        "type": "mdx",
        "chunkIndex": 1,
        "headers": [
          "Overview"
        ],
        "title": "Overview",
        "lastModified": "2025-06-05T19:33:57.874Z",
        "size": 808
      }
    },
    {
      "pageContent": "Leaving an empty policy in a Container or item policy results in `inherit`. In Context it results in `default`.\n\nYou can also combine the values listed above. If you want to allow item updates to be executed only by the item owner, with the additional assumption that they must be an active user of the Container, you can write `itemOwner&user`. But if you want to allow the Container managers to also update the item, you can write `itemOwner&user,manager`. In the policy entry, the `&` character means 'and', and the coma `,` means `or`. Operations with `&` are always performed first.",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/concepts/policies.mdx",
        "type": "mdx",
        "chunkIndex": 2,
        "lastModified": "2025-06-05T19:33:57.874Z",
        "size": 587
      }
    },
    {
      "pageContent": "## Default Policy Values\nThe Endpoint can only define policies on the level of Containers and items.\nContext level policies include rules connected to, for example, creating Containers – so they have to be defined using Bridge API.\n\nThe following tables list the default policy values in PrivMX:",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/concepts/policies.mdx",
        "type": "mdx",
        "chunkIndex": 3,
        "headers": [
          "Default Policy Values"
        ],
        "title": "Default Policy Values",
        "lastModified": "2025-06-05T19:33:57.874Z",
        "size": 295
      }
    },
    {
      "pageContent": "### Context\n| **Policy**             | **Value** |\n|------------------------|-----------|\n| listUsers              | all       |\n| sendCustomNotification | all       |\n\n\n<Accordions>\n    <Accordion title=\"Threads\">\n        ### General\n        | **Policy**                      | **Value** |\n        |---------------------------------|-----------|\n        | get                             | user      |\n        | listMy                          | all       |\n        | listAll                         | none      |\n        | create                          | all       |\n        | update                          | manager   |\n        | delete                          | manager   |\n        | updatePolicy                    | manager   |\n        | creatorHasToBeManager           | yes       |\n        | updaterCanBeRemovedFromManagers | no        |\n        | ownerCanBeRemovedFromManagers   | yes       |\n        | canOverwriteContextPolicy       | yes       |\n        | sendCustomNotification          | all       |",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/concepts/policies.mdx",
        "type": "mdx",
        "chunkIndex": 4,
        "headers": [
          "Context"
        ],
        "title": "Context",
        "lastModified": "2025-06-05T19:33:57.874Z",
        "size": 1018
      }
    },
    {
      "pageContent": "#### Thread Items\n        | **Policy** | **Value**              |\n        |------------|------------------------|\n        | get        | user                   |\n        | listMy     | user                   |\n        | listAll    | user                   |\n        | create     | user                   |\n        | update     | itemOwner&user,manager |\n        | delete     | itemOwner&user,manager |\n    </Accordion>\n    <Accordion title=\"Stores\">\n        ### Store\n        | **Policy**                      | **Value** |\n        |---------------------------------|-----------|\n        | get                             | user      |\n        | listMy                          | all       |\n        | listAll                         | none      |\n        | create                          | all       |\n        | update                          | manager   |\n        | delete                          | manager   |\n        | updatePolicy                    | manager   |\n        | creatorHasToBeManager           | yes       |\n        | updaterCanBeRemovedFromManagers | no        |\n        | ownerCanBeRemovedFromManagers   | yes       |",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/concepts/policies.mdx",
        "type": "mdx",
        "chunkIndex": 5,
        "headers": [
          "Thread Items"
        ],
        "title": "Thread Items",
        "lastModified": "2025-06-05T19:33:57.874Z",
        "size": 1139
      }
    },
    {
      "pageContent": "| creatorHasToBeManager           | yes       |\n        | updaterCanBeRemovedFromManagers | no        |\n        | ownerCanBeRemovedFromManagers   | yes       |\n        | canOverwriteContextPolicy       | yes       |\n        | sendCustomNotification          | all       |",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/concepts/policies.mdx",
        "type": "mdx",
        "chunkIndex": 6,
        "lastModified": "2025-06-05T19:33:57.874Z",
        "size": 271
      }
    },
    {
      "pageContent": "#### Store Item\n        | **Policy** | **Value**              |\n        |------------|------------------------|\n        | get        | user                   |\n        | listMy     | user                   |\n        | listAll    | user                   |\n        | create     | user                   |\n        | update     | itemOwner&user,manager |\n        | delete     | itemOwner&user,manager |\n    </Accordion>\n    <Accordion title=\"Inboxes\">\n        ### Inbox\n        | **Policy**                      | **Value** |\n        |---------------------------------|-----------|\n        | get                             | user      |\n        | listMy                          | all       |\n        | listAll                         | none      |\n        | create                          | all       |\n        | update                          | manager   |\n        | delete                          | manager   |\n        | updatePolicy                    | manager   |\n        | creatorHasToBeManager           | yes       |\n        | updaterCanBeRemovedFromManagers | no        |\n        | ownerCanBeRemovedFromManagers   | yes       |",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/concepts/policies.mdx",
        "type": "mdx",
        "chunkIndex": 7,
        "headers": [
          "Store Item"
        ],
        "title": "Store Item",
        "lastModified": "2025-06-05T19:33:57.874Z",
        "size": 1138
      }
    },
    {
      "pageContent": "| creatorHasToBeManager           | yes       |\n        | updaterCanBeRemovedFromManagers | no        |\n        | ownerCanBeRemovedFromManagers   | yes       |\n        | canOverwriteContextPolicy       | yes       |\n        | sendCustomNotification          | all       |\n    </Accordion>\n</Accordions>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/start/concepts/policies.mdx",
        "type": "mdx",
        "chunkIndex": 8,
        "lastModified": "2025-06-05T19:33:57.874Z",
        "size": 302
      }
    },
    {
      "pageContent": "---\ntitle: Downloading Files\ndescription: Downloading file content and accessing files.\n---\n\n\n:::info\n\nThe sample code on this page is based on the **[initial assumptions](./introduction)**.\n\n:::\n\n<Tabs groupId=\"variant\" items={['Basic Download',\"Using Sink\"]}>\n<Tab value=\"Basic Download\">\nDownloading a file from the Store and saving it by chunk to ByteArray:\n```kotlin\nval fileID = \"FILE_ID\"\nvar data = ByteArray(0)\n\nval closedFileID = StoreFileStreamReader.openFile(\n    storeApi,\n    fileID,\n).also {\n    do {\n        val chunk = it.read(StoreFileStream.OPTIMAL_SEND_SIZE)\n        data += chunk\n    } while (chunk.size.toLong() == StoreFileStream.OPTIMAL_SEND_SIZE)\n}.close()\n```\n</Tab>\n\n<Tab value=\"Using Sink\">\nDownloading a file from the Store and writing by chunk to `OutputStream`:\n```kotlin\nval fileID = \"FILE_ID\"\nval sink: Sink = SystemFileSystem.sink(Path(\"PATH_TO_FILE\")).buffered()\nval streamController = object: StoreFileStream.Controller(){\n    override fun onChunkProcessed(processedBytes: Long) {\n        super.onChunkProcessed(processedBytes)\n        println(\"Full read size: $processedBytes\")\n    }\n}",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/kotlin/downloading-files.mdx",
        "type": "mdx",
        "chunkIndex": 0,
        "codeBlocks": [
          "```kotlin\nval fileID = \"FILE_ID\"\nvar data = ByteArray(0)\n\nval closedFileID = StoreFileStreamReader.openFile(\n    storeApi,\n    fileID,\n).also {\n    do {\n        val chunk = it.read(StoreFileStream.OPTIMAL_SEND_SIZE)\n        data += chunk\n    } while (chunk.size.toLong() == StoreFileStream.OPTIMAL_SEND_SIZE)\n}.close()\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.874Z",
        "size": 1121
      }
    },
    {
      "pageContent": "val closedFileID = StoreFileStreamReader.openFile(\n    storeApi,\n    fileID,\n    sink,\n    streamController\n)\n```\n</Tab>\n</Tabs>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/kotlin/downloading-files.mdx",
        "type": "mdx",
        "chunkIndex": 1,
        "lastModified": "2025-06-05T19:33:57.874Z",
        "size": 128
      }
    },
    {
      "pageContent": "---\ntitle: Entries\ndescription: Working with Inbox Entries.\n---\n\n\nAll the data sent by someone to an Inbox is called an Entry.\nIn Threads and Stores, a user must be assigned to the container to send data. In Inboxes, however, \nanyone who has Inbox ID can send a reply (assuming they have the Bridge URL and Solution ID).\n\n:::info\n\nThe sample code on this page is based on the **[initial assumptions](./introduction#initial-assumptions)**.\n\n:::\n\n:::info\n\nEntry's `publicMeta` and `privateMeta` fields support any kind of data formats encoded to byte arrays. Examples in this section use `kotlinx-serialization-json` dependency to serialize object to JSON format.\n\n:::",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/kotlin/entries.mdx",
        "type": "mdx",
        "chunkIndex": 0,
        "lastModified": "2025-06-05T19:33:57.874Z",
        "size": 666
      }
    },
    {
      "pageContent": "## Sending Entries using Public API\n\nPublic submissions require using `connectPublic` function, provided by the `Connection` class, to establish a public connection to the platform.\nAfter connecting, create an `InboxApi` instance, which allows to operate on Inboxes.\n\n```kotlin\nval connection = Connection.connectPublic(\n    solutionId,\n    bridgeUrl,\n)\nval publicInboxApi = InboxApi(connection)\n```\nAssuming you need some kind of structure in entries, define a data struct `InboxPublicEntryData`, and its instance:\nDefine structure of data sending to Inbox entry:\n```kotlin\n@Serializable\ndata class InboxPublicEntryData(\n    val name: String,\n    val surname: String,\n    val email: String,\n    val comment : String\n)\n```\nNow, having established public connection and `inboxApi`, you can send data to the Inbox:\n\n<Tabs groupId=\"variant\" items={[\"Basic\",\"With Files\"]}>\n<Tab value=\"basic\" label=\"Basic\">\n```kotlin\nval inboxID = \"INBOX_ID\"\nval inboxPublicEntryData = InboxPublicEntryData(\n    \"NAME\",\n    \"SURNAME\",\n    \"EMAIL\",\n    \"COMMENT\"\n)",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/kotlin/entries.mdx",
        "type": "mdx",
        "chunkIndex": 1,
        "headers": [
          "Sending Entries using Public API"
        ],
        "title": "Sending Entries using Public API",
        "codeBlocks": [
          "```kotlin\nval connection = Connection.connectPublic(\n    solutionId,\n    bridgeUrl,\n)\nval publicInboxApi = InboxApi(connection)\n```",
          "```kotlin\n@Serializable\ndata class InboxPublicEntryData(\n    val name: String,\n    val surname: String,\n    val email: String,\n    val comment : String\n)\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.874Z",
        "size": 1043
      }
    },
    {
      "pageContent": "publicInboxApi.prepareEntry(\n    inboxID,\n    Json.encodeToString(inboxPublicEntryData).encodeToByteArray(),\n)?.let {\n    publicInboxApi.sendEntry(it)\n}\n```\n</Tab>\n\n<Tab value=\"With Files\">\n    <div className={'fd-steps'}>\n       <div className={'fd-step'} >\n\n\nCreate `InboxFileHandle` for each file:\n```kotlin\nval fileContents: List<ByteArray> = (0..5).map {\n    \"File content $it\".encodeToByteArray()\n}\nval filePublicMeta = ByteArray(0)\nval filePrivateMeta = ByteArray(0)\nval fileHandles = fileContents.map {\n    publicInboxApi.createFileHandle(\n        filePublicMeta,\n        filePrivateMeta,\n        it.size.toLong()\n    )!!\n}",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/kotlin/entries.mdx",
        "type": "mdx",
        "chunkIndex": 2,
        "codeBlocks": [
          "```\n</Tab>\n\n<Tab value=\"With Files\">\n    <div className={'fd-steps'}>\n       <div className={'fd-step'} >\n\n\nCreate `InboxFileHandle` for each file:\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.874Z",
        "size": 631
      }
    },
    {
      "pageContent": "```\n\n</div>\n    <div className={'fd-step'} >\nCreate `InboxHandle` with `fileHandles` passed as a parameter:\n```kotlin\nval inboxID = \"INBOX_ID\"\nval inboxPublicEntryData = InboxPublicEntryData(\n    \"NAME\",\n    \"SURNAME\",\n    \"EMAIL\",\n    \"COMMENT\"\n)\n\nval inboxHandle = publicInboxApi.prepareEntry(\n    inboxID,\n    Json.encodeToString(inboxPublicEntryData).encodeToByteArray(),\n    fileHandles\n)!!\n```\n\n    </div>\n        <div className={'fd-step'} >\nUpload all files using `writeToFile` method from `InboxApi`:\n```kotlin\nfileContents.zip(fileHandles).forEach { (content, fileHandle) ->\n    publicInboxApi.writeToFile(inboxHandle, fileHandle, content)\n}\n```\n\n        </div>\n            <div className={'fd-step'} >\nCall `sendEntry` which sends `inboxPublicEntryData` data to Inbox and closes all file handles:\n```kotlin\npublicInboxApi.sendEntry(inboxHandle)\n```\n            </div>\n            </div>\n</Tab>\n</Tabs>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/kotlin/entries.mdx",
        "type": "mdx",
        "chunkIndex": 3,
        "codeBlocks": [
          "```\n\n</div>\n    <div className={'fd-step'} >\nCreate `InboxHandle` with `fileHandles` passed as a parameter:\n```",
          "```\n\n    </div>\n        <div className={'fd-step'} >\nUpload all files using `writeToFile` method from `InboxApi`:\n```",
          "```\n\n        </div>\n            <div className={'fd-step'} >\nCall `sendEntry` which sends `inboxPublicEntryData` data to Inbox and closes all file handles:\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.874Z",
        "size": 912
      }
    },
    {
      "pageContent": "## Getting Entries\n\nCreated entries can be listed by non-public connections created using [`PrivmxEndpoint`](/reference/kotlin/privmx-endpoint-extra/com.simplito.kotlin.privmx_endpoint_extra.lib/-privmx-endpoint/index.html) class.\n\nDefine Entry item class with decoded `data`:\n```kotlin\ndata class EntryItem(\n    val entry: InboxEntry,\n    val decodedData: InboxPublicEntryData\n)",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/kotlin/entries.mdx",
        "type": "mdx",
        "chunkIndex": 4,
        "headers": [
          "Getting Entries"
        ],
        "title": "Getting Entries",
        "lastModified": "2025-06-05T19:33:57.874Z",
        "size": 379
      }
    },
    {
      "pageContent": "```\n\n<Tabs groupId=\"variant\" items={[\"Most Recent\",\"Oldest\"]}>\n<Tab value=\"Most Recent\">\nFetching the most recent Entries in given Inbox:\n```kotlin\nval inboxID = \"INBOX_ID\"\nval startIndex = 0L\nval pageSize = 100L\n\nval entriesPagingList = inboxApi.listEntries(\n    inboxID,\n    startIndex,\n    pageSize,\n    SortOrder.DESC\n)\n\nval entries = entriesPagingList.readItems.map {\n    EntryItem(\n        it,\n        Json.decodeFromString(it.data.decodeToString())\n    )\n}\n```\n</Tab>\n\n<Tab value=\"Oldest\">\nFetching the oldest Entries (by creation date) in given Inbox:\n```kotlin\nval inboxID = \"INBOX_ID\"\nval startIndex = 0L\nval pageSize = 100L\n\nval entriesPagingList = inboxApi.listEntries(\n    inboxID,\n    startIndex,\n    pageSize,\n    SortOrder.ASC\n)\n\nval entries = entriesPagingList.readItems.map {\n    EntryItem(\n        it,\n        Json.decodeFromString(it.data.decodeToString())\n    )\n}\n```\n</Tab>\n</Tabs>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/kotlin/entries.mdx",
        "type": "mdx",
        "chunkIndex": 5,
        "codeBlocks": [
          "```\n\n<Tabs groupId=\"variant\" items={[\"Most Recent\",\"Oldest\"]}>\n<Tab value=\"Most Recent\">\nFetching the most recent Entries in given Inbox:\n```",
          "```\n</Tab>\n\n<Tab value=\"Oldest\">\nFetching the oldest Entries (by creation date) in given Inbox:\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.874Z",
        "size": 903
      }
    },
    {
      "pageContent": "## Reading Entries Files\n\nFiles from Entries can be read by non-public connections created using [`PrivmxEndpoint`](/reference/kotlin/privmx-endpoint-extra/com.simplito.kotlin.privmx_endpoint_extra.lib/-privmx-endpoint/index.html) class.\n\n```kotlin\nval entryID = \"ENTRY_ID\"\nval inboxEntry = inboxApi.readEntry(entryID)\n\nval files: List<File> = inboxEntry.files\nval filesContent: List<ByteArray> = files.map { file ->\n    inboxApi.openFile(file.info.fileId)!!\n        .let { fileHandle ->\n            var fileContent = ByteArray(0)\n            do {\n                val chunk = inboxApi.readFromFile(fileHandle, StoreFileStream.OPTIMAL_SEND_SIZE)\n                fileContent += chunk\n            } while (chunk.size.toLong() == StoreFileStream.OPTIMAL_SEND_SIZE)\n            inboxApi.closeFile(fileHandle)\n            fileContent\n        }\n}\n```",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/kotlin/entries.mdx",
        "type": "mdx",
        "chunkIndex": 6,
        "headers": [
          "Reading Entries Files"
        ],
        "title": "Reading Entries Files",
        "codeBlocks": [
          "```kotlin\nval entryID = \"ENTRY_ID\"\nval inboxEntry = inboxApi.readEntry(entryID)\n\nval files: List<File> = inboxEntry.files\nval filesContent: List<ByteArray> = files.map { file ->\n    inboxApi.openFile(file.info.fileId)!!\n        .let { fileHandle ->\n            var fileContent = ByteArray(0)\n            do {\n                val chunk = inboxApi.readFromFile(fileHandle, StoreFileStream.OPTIMAL_SEND_SIZE)\n                fileContent += chunk\n            } while (chunk.size.toLong() == StoreFileStream.OPTIMAL_SEND_SIZE)\n            inboxApi.closeFile(fileHandle)\n            fileContent\n        }\n}\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.874Z",
        "size": 843
      }
    },
    {
      "pageContent": "---\ntitle: Events\ndescription: Events enable your application to react dynamically to changes within user context.\n---\n\n\n\n:::info\n\nBefore working with Events, follow our [Getting Started Guide](./introduction). It will show you how to set up your project to work with PrivMX Bridge.\n\nThe sample code on this page is based on the **[initial assumptions](./introduction#initial-assumptions)**.\n\n:::\n\nThese events are triggered automatically when a relevant change occurs. You can subscribe to them by registering event listeners. This allows you to respond to changes as they happen in real-time.\n\n\n## Caveats\n\n- All callbacks are related to the connection on which they were registered.\n- Calling [`PrivmxEndpointContainer.stopListening()`](/reference/kotlin/privmx-endpoint-extra/com.simplito.kotlin.privmx_endpoint_extra.lib/-privmx-endpoint-container/stop-listening.html) does not delete event listeners.\n- Disconnecting deletes all event listeners related to the connection.",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/kotlin/events.mdx",
        "type": "mdx",
        "chunkIndex": 0,
        "headers": [
          "Caveats"
        ],
        "title": "Caveats",
        "lastModified": "2025-06-05T19:33:57.875Z",
        "size": 977
      }
    },
    {
      "pageContent": "## Quick Start\n\n<div className={'fd-steps'}>\n   <div className={'fd-step'}>\n\nStart the event loop:\n```kotlin\nendpointContainer.startListening()\n```\n   </div>\n       <div className={'fd-step'}>\nAdd event listener for 'ThreadCreatedEvent' related with `callbackID`\n```kotlin\nval callbackID = \"CALLBACK_ID\"\nendpointSession.registerCallback(\n    callbackID,\n    EventType.ThreadCreatedEvent\n){ newThreadData ->\n    // some actions with newThreadData\n}\n```\n       </div>\n           <div className={'fd-step'}>\nRemove the event listener when no longer needed:\n```kotlin\nendpointSession.unregisterCallbacks(callbackID)\n```\n   </div>\n</div>\n## Unregister Callbacks\n\n<Tabs groupId=\"variant\" items={[\"By Callback ID\", \"All Callbacks\"]}>\n<Tab value=\"By Callback ID\">\nUnregister all callbacks identified by `callbacksID`:\n```kotlin\nval callbacksID = \"CALLBACKS_ID\"\nendpointSession.unregisterCallbacks(callbacksID)\n```\n</Tab>\n\n<Tab value=\"All Callbacks\">\nUnregister all callbacks from the connection:\n```kotlin\nendpointSession.unregisterAll()\n```\n</Tab>\n\n</Tabs>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/kotlin/events.mdx",
        "type": "mdx",
        "chunkIndex": 1,
        "headers": [
          "Quick Start",
          "Unregister Callbacks"
        ],
        "title": "Quick Start",
        "codeBlocks": [
          "```kotlin\nendpointContainer.startListening()\n```",
          "```kotlin\nval callbackID = \"CALLBACK_ID\"\nendpointSession.registerCallback(\n    callbackID,\n    EventType.ThreadCreatedEvent\n){ newThreadData ->\n    // some actions with newThreadData\n}\n```",
          "```kotlin\nendpointSession.unregisterCallbacks(callbackID)\n```",
          "```kotlin\nval callbacksID = \"CALLBACKS_ID\"\nendpointSession.unregisterCallbacks(callbacksID)\n```",
          "```kotlin\nendpointSession.unregisterAll()\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.875Z",
        "size": 1049
      }
    },
    {
      "pageContent": "---\ntitle: Files\ndescription: Uploading and managing files.\n---\n\n\n\n:::info\n\nThe sample code on this page is based on the **[initial assumptions](./introduction#initial-assumptions)**.\n\n:::\n\n:::info\n\nFile `publicMeta` and `privateMeta` fields support any kind of data formats encoded to byte arrays. Examples in this section use `kotlinx-serialization-json` dependency to serialize object to JSON format.\n\n:::",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/kotlin/files.mdx",
        "type": "mdx",
        "chunkIndex": 0,
        "lastModified": "2025-06-05T19:33:57.875Z",
        "size": 408
      }
    },
    {
      "pageContent": "## Uploading Files\n\n<Tabs groupId=\"variant\" items={[\"Basic Upload\",\"With File Meta\",\"Using Source\"]}>\n<Tab >\nUploading file to a Store in the most basic way:\n```kotlin\nval storeID = \"STORE_ID\"\nval fileContent = \"Text file content\".encodeToByteArray()\nval publicMeta = ByteArray(0)\nval privateMeta = ByteArray(0)\n\nval fileId = StoreFileStreamWriter.createFile(\n    storeApi,\n    storeID,\n    publicMeta,\n    privateMeta,\n    fileContent.size.toLong(),\n).also {\n    it.write(fileContent)\n}.close()\n```\n</Tab>\n<Tab >\n\nUploading file to a Store with additional metadata.\n\nDefine file `privateMeta` structure:\n```kotlin\n@Serializable\ndata class FilePrivateMeta(\n    val name: String,\n    val mimetype: String\n)\n```\nPrepare and upload the file:\n```kotlin\nval storeID = \"STORE_ID\"\nval fileContent = \"Text file content\".encodeToByteArray()\nval publicMeta = ByteArray(0)\nval privateMeta = FilePrivateMeta(\n    name = \"Example text file\",\n    mimetype = \"text/plain\"\n)",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/kotlin/files.mdx",
        "type": "mdx",
        "chunkIndex": 1,
        "headers": [
          "Uploading Files"
        ],
        "title": "Uploading Files",
        "codeBlocks": [
          "```kotlin\nval storeID = \"STORE_ID\"\nval fileContent = \"Text file content\".encodeToByteArray()\nval publicMeta = ByteArray(0)\nval privateMeta = ByteArray(0)\n\nval fileId = StoreFileStreamWriter.createFile(\n    storeApi,\n    storeID,\n    publicMeta,\n    privateMeta,\n    fileContent.size.toLong(),\n).also {\n    it.write(fileContent)\n}.close()\n```",
          "```kotlin\n@Serializable\ndata class FilePrivateMeta(\n    val name: String,\n    val mimetype: String\n)\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.875Z",
        "size": 958
      }
    },
    {
      "pageContent": "val fileId = StoreFileStreamWriter.createFile(\n    storeApi,\n    storeID,\n    publicMeta,\n    Json.encodeToString(privateMeta).encodeToByteArray(),\n    fileContent.size.toLong(),\n).also {\n    it.write(fileContent)\n}.close()\n```\n</Tab>\n<Tab value='Using Source'>\nThe snippet below shows how to send `Source` directly to a file.\n\nDefine file `privateMeta` structure:\n```kotlin\n@Serializable\ndata class FilePrivateMeta(\n    val name: String,\n    val mimetype: String\n)\n```\nPrepare and upload the file:\n```kotlin\nval storeID = \"STORE_ID\"\nval filePath = Path(\"PATH_TO_FILE\")\nval fileMimetype = \"FILE_MIMETYPE\"\nval fileMetadata = SystemFileSystem.metadataOrNull(filePath)!!\nval source = SystemFileSystem.source(filePath).buffered()\nval publicMeta = ByteArray(0)\nval privateMeta = FilePrivateMeta(\n    name = filePath.name.substringBeforeLast(\".\"),\n    mimetype = fileMimetype\n)\nval streamController = object : StoreFileStream.Controller() {\n    override fun onChunkProcessed(processedBytes: Long) {\n        super.onChunkProcessed(processedBytes)\n        println(\"Processed size: $processedBytes\")\n    }\n}",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/kotlin/files.mdx",
        "type": "mdx",
        "chunkIndex": 2,
        "codeBlocks": [
          "```\n</Tab>\n<Tab value='Using Source'>\nThe snippet below shows how to send `Source` directly to a file.\n\nDefine file `privateMeta` structure:\n```",
          "```\nPrepare and upload the file:\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.875Z",
        "size": 1098
      }
    },
    {
      "pageContent": "val fileId = StoreFileStreamWriter.createFile(\n    storeApi,\n    storeID,\n    publicMeta,\n    Json.encodeToString(privateMeta).encodeToByteArray(),\n    fileMetadata.size,\n    source,\n    streamController\n)\n```\n</Tab>\n</Tabs>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/kotlin/files.mdx",
        "type": "mdx",
        "chunkIndex": 3,
        "lastModified": "2025-06-05T19:33:57.875Z",
        "size": 224
      }
    },
    {
      "pageContent": "## Getting Files\n\nDefine file item class with decoded `privateMeta`.\n```kotlin\ndata class FileItem(\n    val file: File,\n    val decodedPrivateMeta: FilePrivateMeta\n)",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/kotlin/files.mdx",
        "type": "mdx",
        "chunkIndex": 4,
        "headers": [
          "Getting Files"
        ],
        "title": "Getting Files",
        "lastModified": "2025-06-05T19:33:57.875Z",
        "size": 165
      }
    },
    {
      "pageContent": "```\n\n<Tabs groupId=\"variant\" items={[\"Most Recent\",\"Oldest\",\"By File ID\"]}>\n<Tab value=\"Most Recent\">\nFetching the most recent files in given Store:\n```kotlin\nval storeId = \"STORE_ID\"\nval startIndex = 0L\nval pageSize = 100L\n\nval filesPagingList = storeApi.listFiles(\n    storeId,\n    startIndex,\n    pageSize,\n    SortOrder.DESC\n)\n\nval files = filesPagingList.readItems.map {\n    FileItem(\n        it,\n        Json.decodeFromString(it.privateMeta.decodeToString())\n    )\n}\n```\n</Tab>\n\n<Tab value=\"Oldest\">\nFetching the oldest files (by creation date) in given Store:\n```kotlin\nval storeId = \"STORE_ID\"\nval startIndex = 0L\nval pageSize = 100L\n\nval filesPagingList = storeApi.listFiles(\n    storeId,\n    startIndex,\n    pageSize,\n    SortOrder.ASC\n)\n\nval files = filesPagingList.readItems.map {\n    FileItem(\n        it,\n        Json.decodeFromString(it.privateMeta.decodeToString())\n    )\n}\n```\n</Tab>\n<Tab value=\"By File ID\">\nYou can get info about a file using its `fileId`:\n```kotlin\nval fileID = \"FILE_ID\"\n\nval fileItem = storeApi.getFile(fileID).let {\n    FileItem(\n        it,\n        Json.decodeFromString(it.privateMeta.decodeToString())\n    )\n}\n```\n</Tab>\n</Tabs>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/kotlin/files.mdx",
        "type": "mdx",
        "chunkIndex": 5,
        "codeBlocks": [
          "```\n\n<Tabs groupId=\"variant\" items={[\"Most Recent\",\"Oldest\",\"By File ID\"]}>\n<Tab value=\"Most Recent\">\nFetching the most recent files in given Store:\n```",
          "```\n</Tab>\n\n<Tab value=\"Oldest\">\nFetching the oldest files (by creation date) in given Store:\n```",
          "```\n</Tab>\n<Tab value=\"By File ID\">\nYou can get info about a file using its `fileId`:\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.875Z",
        "size": 1171
      }
    },
    {
      "pageContent": "## Managing Files\n\n<Tabs groupId=\"variant\" items={[\"Changing File Name\",\"Overwriting File Content\",\"Deleting File\"]}>\n<Tab value=\"Changing File Name\">\n```kotlin\nval fileID = \"FILE_ID\"\nval file = storeApi.getFile(fileID)\nvar filePrivateMeta: FilePrivateMeta = Json.decodeFromString(file.privateMeta.decodeToString())\nfilePrivateMeta = filePrivateMeta.copy(\n    name = \"New file name\"\n)\n\nstoreApi.updateFileMeta(\n    fileID,\n    file.publicMeta,\n    Json.encodeToString(filePrivateMeta).encodeToByteArray(),\n)\n```\n</Tab>\n\n<Tab value=\"Overwriting File Content\">\n```kotlin\nval fileID = \"FILE_ID\"\nval newFilePath = Path(\"PATH_TO_FILE\")\nval fileMetadata = SystemFileSystem.metadataOrNull(newFilePath)!!\nval source = SystemFileSystem.source(newFilePath).buffered()\nval streamController = object : StoreFileStream.Controller() {\n    override fun onChunkProcessed(processedBytes: Long) {\n        super.onChunkProcessed(processedBytes)\n        println(\"Processed size: $processedBytes\")\n    }\n}\nval file = storeApi.getFile(fileID)\n\nStoreFileStreamWriter.updateFile(\n    storeApi,\n    fileID,\n    file.publicMeta,\n    file.privateMeta,\n    fileMetadata.size,\n    source,\n    streamController\n)\n```\n</Tab>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/kotlin/files.mdx",
        "type": "mdx",
        "chunkIndex": 6,
        "headers": [
          "Managing Files"
        ],
        "title": "Managing Files",
        "codeBlocks": [
          "```kotlin\nval fileID = \"FILE_ID\"\nval file = storeApi.getFile(fileID)\nvar filePrivateMeta: FilePrivateMeta = Json.decodeFromString(file.privateMeta.decodeToString())\nfilePrivateMeta = filePrivateMeta.copy(\n    name = \"New file name\"\n)\n\nstoreApi.updateFileMeta(\n    fileID,\n    file.publicMeta,\n    Json.encodeToString(filePrivateMeta).encodeToByteArray(),\n)\n```",
          "```kotlin\nval fileID = \"FILE_ID\"\nval newFilePath = Path(\"PATH_TO_FILE\")\nval fileMetadata = SystemFileSystem.metadataOrNull(newFilePath)!!\nval source = SystemFileSystem.source(newFilePath).buffered()\nval streamController = object : StoreFileStream.Controller() {\n    override fun onChunkProcessed(processedBytes: Long) {\n        super.onChunkProcessed(processedBytes)\n        println(\"Processed size: $processedBytes\")\n    }\n}\nval file = storeApi.getFile(fileID)\n\nStoreFileStreamWriter.updateFile(\n    storeApi,\n    fileID,\n    file.publicMeta,\n    file.privateMeta,\n    fileMetadata.size,\n    source,\n    streamController\n)\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.875Z",
        "size": 1193
      }
    },
    {
      "pageContent": "StoreFileStreamWriter.updateFile(\n    storeApi,\n    fileID,\n    file.publicMeta,\n    file.privateMeta,\n    fileMetadata.size,\n    source,\n    streamController\n)\n```\n</Tab>\n\n<Tab value=\"Deleting File\">\n```kotlin\nval fileID = \"FILE_ID\"\nstoreApi.deleteFile(fileID)\n```\n</Tab>\n</Tabs>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/kotlin/files.mdx",
        "type": "mdx",
        "chunkIndex": 7,
        "codeBlocks": [
          "```\n</Tab>\n\n<Tab value=\"Deleting File\">\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.875Z",
        "size": 280
      }
    },
    {
      "pageContent": "---\ntitle: Getting Started\n---\n\n\n## Initial Requirements\n\nBefore starting developing using PrivMX Endpoint Kotlin follow our [quick start guide](../start/quick-start)\n\nTo connect it to your environment, you need:\n  - `Bridge URL` - URL address of the instance of your PrivMX Bridge\n  - `Solution ID` - ID of the Solution provided by PrivMX Bridge during its initialization process\n  - `User Private Key` - the private key from the user's public-private key pair\n\nYou also need to use your own application server to manage users (and their keys) and Contexts.\n\n## Adding Dependencies\n\n1. Add `mavenCentral()` repository to your `settings.gradle.kts`:\n\n```groovy\ndependencyResolutionManagement {\n    repositories {\n        mavenCentral()\n    }\n}\n```\n\n2. Add dependency to `build.gradle.kts`:\n\n```groovy\nkotlin {\n  sourceSets {\n    val commonMain by getting {\n      dependencies {\n        implementation(\"com.simplito.kotlin:privmx-endpoint:$privmxLibVersion\")\n        // optionally you can add privmx-endpoint-extra dependency\n//        implementation(\"com.simplito.kotlin:privmx-endpoint-extra:$privmxLibVersion\")\n      }\n    }\n  }\n}\n```",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/kotlin/getting-started.mdx",
        "type": "mdx",
        "chunkIndex": 0,
        "headers": [
          "Initial Requirements",
          "Adding Dependencies"
        ],
        "title": "Initial Requirements",
        "codeBlocks": [
          "```groovy\ndependencyResolutionManagement {\n    repositories {\n        mavenCentral()\n    }\n}\n```",
          "```groovy\nkotlin {\n  sourceSets {\n    val commonMain by getting {\n      dependencies {\n        implementation(\"com.simplito.kotlin:privmx-endpoint:$privmxLibVersion\")\n        // optionally you can add privmx-endpoint-extra dependency\n//        implementation(\"com.simplito.kotlin:privmx-endpoint-extra:$privmxLibVersion\")\n      }\n    }\n  }\n}\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.876Z",
        "size": 1136
      }
    },
    {
      "pageContent": "## JVM\nYou have to pass path to PrivMX Endpoint native libraries directory by configuring\n`-Djava.library.path=<path-to-your-libraries-dir>` system property during run application.\n\n**You can download pre-compiled zipped native binaries for each supported JVM platform from [GitHub Releases](https://github.com/simplito/privmx-endpoint-kotlin/releases).**\n\n## Android\n### Native Libraries\nBefore build your project you have to attach PrivMX Endpoint native libraries to Android build process by adding them\nto jniLibs sourceSet directory (`src/main/jniLibs` by default) for each supported ABI.\n\n**You can download pre-compiled zipped native binaries for each supported Android ABI from [GitHub Releases](https://github.com/simplito/privmx-endpoint-kotlin/releases).**\n\n### Required Permissions\nPrivMX Endpoint requires to add the following permissions to your AndroidManifest.xml:\n* `<uses-permission android:name=\"android.permission.INTERNET\"/>`",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/kotlin/getting-started.mdx",
        "type": "mdx",
        "chunkIndex": 1,
        "headers": [
          "JVM",
          "Android",
          "Native Libraries",
          "Required Permissions"
        ],
        "title": "JVM",
        "lastModified": "2025-06-05T19:33:57.876Z",
        "size": 946
      }
    },
    {
      "pageContent": "## Initial Assumptions\nThe initial assumptions for all the code examples below are as follows:\n\n``` kotlin\n/*\n    All the values below like BRIDGE_URL, SOLUTION_ID, CONTEXT_ID\n    should be replaced by the ones corresponding to your Bridge Server instance.\n\n    The private keys here are for demonstration purposes only.\n    Normally, they should be kept separately by each user and stored in a safe place,\n    or generated from a password (see the derivePrivateKey2() method in the Crypto API)\n*/\n\nval bridgeUrl = \"YOUR_BRIDGE_URL\"\nval solutionId = \"YOUR_SOLUTION_ID\"\nval contextId = \"YOUR_CONTEXT_ID\"\n\nval user1Id = \"USER_ID_1\"\nval user1PublicKey = \"PUBLIC_KEY_1\"\nval user1PrivateKey = \"PRIVATE_KEY_1\"\n\nval user2Id = \"USER_ID_2\"\nval user2PublicKey = \"PUBLIC_KEY_2\"\n```",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/kotlin/getting-started.mdx",
        "type": "mdx",
        "chunkIndex": 2,
        "headers": [
          "Initial Assumptions"
        ],
        "title": "Initial Assumptions",
        "codeBlocks": [
          "``` kotlin\n/*\n    All the values below like BRIDGE_URL, SOLUTION_ID, CONTEXT_ID\n    should be replaced by the ones corresponding to your Bridge Server instance.\n\n    The private keys here are for demonstration purposes only.\n    Normally, they should be kept separately by each user and stored in a safe place,\n    or generated from a password (see the derivePrivateKey2() method in the Crypto API)\n*/\n\nval bridgeUrl = \"YOUR_BRIDGE_URL\"\nval solutionId = \"YOUR_SOLUTION_ID\"\nval contextId = \"YOUR_CONTEXT_ID\"\n\nval user1Id = \"USER_ID_1\"\nval user1PublicKey = \"PUBLIC_KEY_1\"\nval user1PrivateKey = \"PRIVATE_KEY_1\"\n\nval user2Id = \"USER_ID_2\"\nval user2PublicKey = \"PUBLIC_KEY_2\"\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.876Z",
        "size": 770
      }
    },
    {
      "pageContent": "## Connecting to PrivMX Bridge\n\nTo use any of the library's elements, you must first connect to PrivMX Bridge.\nUse the API keys mentioned [earlier](#initial-requirements):\n\n``` kotlin\nval pathToCerts = \"PATH_TO_CERTS\" // Path to .pem ssl certificate to connect with Privmx Bridge\nval initModules = setOf(\n    Modules.THREAD, // initializes ThreadApi to working with Threads\n    Modules.STORE, // initializes StoreApi to working with Stores\n    Modules.INBOX // initializes InboxApi to working with Inboxes\n) // set of modules to activate in new connection\n\nval endpointContainer = PrivmxEndpointContainer().also {\n    it.setCertsPath(pathToCerts)\n}\n\nval endpointSession = endpointContainer.connect(\n    initModules,\n    user1PrivateKey,\n    solutionId,\n    bridgeUrl\n)",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/kotlin/getting-started.mdx",
        "type": "mdx",
        "chunkIndex": 3,
        "headers": [
          "Connecting to PrivMX Bridge"
        ],
        "title": "Connecting to PrivMX Bridge",
        "lastModified": "2025-06-05T19:33:57.876Z",
        "size": 768
      }
    },
    {
      "pageContent": "```\n\nThe active connection is kept by [`container`](/reference/kotlin/privmx-endpoint-extra/com.simplito.kotlin.privmx_endpoint_extra.lib/-privmx-endpoint-container/index.html) and can be accessed using [`container.getEndpoint(Long)`](/reference/kotlin/privmx-endpoint-extra/com.simplito.kotlin.privmx_endpoint_extra.lib/-privmx-endpoint-container/get-endpoint.html) method.\n``` kotlin\nendpointContainer.getEndpoint(endpointSession.connection.getConnectionId()!!)\n```",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/kotlin/getting-started.mdx",
        "type": "mdx",
        "chunkIndex": 4,
        "codeBlocks": [
          "```\n\nThe active connection is kept by [`container`](/reference/kotlin/privmx-endpoint-extra/com.simplito.kotlin.privmx_endpoint_extra.lib/-privmx-endpoint-container/index.html) and can be accessed using [`container.getEndpoint(Long)`](/reference/kotlin/privmx-endpoint-extra/com.simplito.kotlin.privmx_endpoint_extra.lib/-privmx-endpoint-container/get-endpoint.html) method.\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.876Z",
        "size": 467
      }
    },
    {
      "pageContent": "## Disconnecting from PrivMX Bridge\n\n<Tabs groupId=\"variant\" items={[\"By Connection ID\",\"All Connections\"]}>\n<Tab >\n```kotlin\nendpointContainer.disconnect(endpointSession.connection.getConnectionId()!!)\n```\n</Tab>\n<Tab>\n\n``` kotlin\nendpointContainer.disconnectAll()\n```\n</Tab>\n</Tabs>\n\n## Closing `PrivmxEndpointContainer`\nWhen you finish working with the `container`, close it to end all connections, close the event loop, and release the resources being used.\nYou can also use a `use` function in Kotlin.\n``` kotlin\nendpointContainer.close()\n```\n\n## Next Steps\n\nWith everything ready to go, now it's time to start using all of the platform's capabilities. \n\nLearn how to use:\n\n-   [**Threads**](../start/threads/overview) - for exchanging encrypted messages;\n-   [**Stores**](../start/stores/overview) - for saving and sharing encrypted files;\n-   [**Inboxes**](../start/inboxes/overview) - for one way communication with external users.",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/kotlin/getting-started.mdx",
        "type": "mdx",
        "chunkIndex": 5,
        "headers": [
          "Disconnecting from PrivMX Bridge",
          "Closing `PrivmxEndpointContainer`",
          "Next Steps"
        ],
        "title": "Disconnecting from PrivMX Bridge",
        "codeBlocks": [
          "```kotlin\nendpointContainer.disconnect(endpointSession.connection.getConnectionId()!!)\n```",
          "``` kotlin\nendpointContainer.disconnectAll()\n```",
          "``` kotlin\nendpointContainer.close()\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.876Z",
        "size": 939
      }
    },
    {
      "pageContent": "---\ntitle: Handling Events\ndescription: How to subscribe to events, assuming you have already started listening.\n---\n\n\n\n## Connection\n\n```kotlin\nval callbacksId = \"CALLBACKS_ID\"\n\nendpointSession.registerCallback(\n    callbacksId,\n    EventType.ConnectedEvent\n){\n    // some actions when lib was connected\n}\n\nendpointSession.registerCallback(\n    callbacksId,\n    EventType.DisconnectedEvent\n){\n    // some actions when lib was disconnected\n}\n```",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/kotlin/handling-events.mdx",
        "type": "mdx",
        "chunkIndex": 0,
        "headers": [
          "Connection"
        ],
        "title": "Connection",
        "codeBlocks": [
          "```kotlin\nval callbacksId = \"CALLBACKS_ID\"\n\nendpointSession.registerCallback(\n    callbacksId,\n    EventType.ConnectedEvent\n){\n    // some actions when lib was connected\n}\n\nendpointSession.registerCallback(\n    callbacksId,\n    EventType.DisconnectedEvent\n){\n    // some actions when lib was disconnected\n}\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.876Z",
        "size": 445
      }
    },
    {
      "pageContent": "## Threads\n\n<Tabs items={[\"Threads\",\"Messages\"]}>\n<Tab value=\"Threads\">\n```kotlin\nval callbacksId = \"CALLBACKS_ID\"\n\nendpointSession.registerCallback(\n    callbacksId,\n    EventType.ThreadCreatedEvent\n){ newThreadData ->\n    // some actions when new thread created\n}\n\nendpointSession.registerCallback(\n    callbacksId,\n    EventType.ThreadUpdatedEvent\n){ threadUpdateData ->\n    // some actions when thread updated\n}\n\nendpointSession.registerCallback(\n    callbacksId,\n    EventType.ThreadStatsChangedEvent\n){ threadStatsUpdateData ->\n    // some actions when thread stats changed\n}\n\nendpointSession.registerCallback(\n    callbacksId,\n    EventType.ThreadDeletedEvent\n){ deletedThreadData ->\n    // some actions when thread deleted\n}\n```\n</Tab>\n\n<Tab value=\"Messages\">\n```kotlin\nval callbacksId = \"CALLBACKS_ID\"\nval threadID = \"THREAD_ID\"\n\nendpointSession.registerCallback(\n    callbacksId,\n    EventType.ThreadNewMessageEvent(threadID)\n){ newMessageData ->\n    // some actions on new message\n}\n\nendpointSession.registerCallback(\n    callbacksId,\n    EventType.ThreadMessageUpdatedEvent(threadID)\n){ updatedMessageData ->\n    // some actions when message updated\n}",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/kotlin/handling-events.mdx",
        "type": "mdx",
        "chunkIndex": 1,
        "headers": [
          "Threads"
        ],
        "title": "Threads",
        "codeBlocks": [
          "```kotlin\nval callbacksId = \"CALLBACKS_ID\"\n\nendpointSession.registerCallback(\n    callbacksId,\n    EventType.ThreadCreatedEvent\n){ newThreadData ->\n    // some actions when new thread created\n}\n\nendpointSession.registerCallback(\n    callbacksId,\n    EventType.ThreadUpdatedEvent\n){ threadUpdateData ->\n    // some actions when thread updated\n}\n\nendpointSession.registerCallback(\n    callbacksId,\n    EventType.ThreadStatsChangedEvent\n){ threadStatsUpdateData ->\n    // some actions when thread stats changed\n}\n\nendpointSession.registerCallback(\n    callbacksId,\n    EventType.ThreadDeletedEvent\n){ deletedThreadData ->\n    // some actions when thread deleted\n}\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.876Z",
        "size": 1163
      }
    },
    {
      "pageContent": "endpointSession.registerCallback(\n    callbacksId,\n    EventType.ThreadMessageUpdatedEvent(threadID)\n){ updatedMessageData ->\n    // some actions when message updated\n}\n\nendpointSession.registerCallback(\n    callbacksId,\n    EventType.ThreadMessageDeletedEvent(threadID)\n){ deletedMessageData ->\n    // some actions when message deleted\n}\n```\n</Tab>\n\n</Tabs>\n\n[Read more](../start/threads/listening-for-changes) about Thread events.",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/kotlin/handling-events.mdx",
        "type": "mdx",
        "chunkIndex": 2,
        "lastModified": "2025-06-05T19:33:57.876Z",
        "size": 432
      }
    },
    {
      "pageContent": "## Stores\n\n<Tabs items={[\"Stores\",\"Files\"]}>\n\n<Tab value='Stores'>\n```kotlin\nval callbacksId = \"CALLBACKS_ID\"\n\nendpointSession.registerCallback(\n    callbacksId,\n    EventType.StoreCreatedEvent\n){ newStoreData ->\n    // some actions when new store created\n}\n\nendpointSession.registerCallback(\n    callbacksId,\n    EventType.StoreUpdatedEvent\n){ storeUpdateData ->\n    // some actions when store updated\n}\n\nendpointSession.registerCallback(\n    callbacksId,\n    EventType.StoreStatsChangedEvent\n){ storeStatsUpdateData ->\n    // some actions when store stats changed\n}\n\nendpointSession.registerCallback(\n    callbacksId,\n    EventType.StoreDeletedEvent\n){ deletedStoreData ->\n    // some actions when store deleted\n}\n```\n</Tab>\n\n<Tab value=\"Files\">\n```kotlin\nval callbacksId = \"CALLBACKS_ID\"\nval storeID = \"STORE_ID\"\n\nendpointSession.registerCallback(\n    callbacksId,\n    EventType.StoreFileCreatedEvent(storeID)\n){ newFileData ->\n    // some actions on new file\n}\n\nendpointSession.registerCallback(\n    callbacksId,\n    EventType.StoreFileUpdatedEvent(storeID)\n){ updatedFileData ->\n    // some actions when file updated\n}",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/kotlin/handling-events.mdx",
        "type": "mdx",
        "chunkIndex": 3,
        "headers": [
          "Stores"
        ],
        "title": "Stores",
        "codeBlocks": [
          "```kotlin\nval callbacksId = \"CALLBACKS_ID\"\n\nendpointSession.registerCallback(\n    callbacksId,\n    EventType.StoreCreatedEvent\n){ newStoreData ->\n    // some actions when new store created\n}\n\nendpointSession.registerCallback(\n    callbacksId,\n    EventType.StoreUpdatedEvent\n){ storeUpdateData ->\n    // some actions when store updated\n}\n\nendpointSession.registerCallback(\n    callbacksId,\n    EventType.StoreStatsChangedEvent\n){ storeStatsUpdateData ->\n    // some actions when store stats changed\n}\n\nendpointSession.registerCallback(\n    callbacksId,\n    EventType.StoreDeletedEvent\n){ deletedStoreData ->\n    // some actions when store deleted\n}\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.876Z",
        "size": 1123
      }
    },
    {
      "pageContent": "endpointSession.registerCallback(\n    callbacksId,\n    EventType.StoreFileUpdatedEvent(storeID)\n){ updatedFileData ->\n    // some actions when file updated\n}\n\nendpointSession.registerCallback(\n    callbacksId,\n    EventType.StoreFileDeletedEvent(storeID)\n){ deletedFileData ->\n    // some actions when file deleted\n}\n```\n</Tab>\n\n</Tabs>\n\n[Read more](../start/stores/instant-updating) about Store events.",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/kotlin/handling-events.mdx",
        "type": "mdx",
        "chunkIndex": 4,
        "lastModified": "2025-06-05T19:33:57.876Z",
        "size": 403
      }
    },
    {
      "pageContent": "## Inboxes\n\n<Tabs items={[\"Inboxes\",\"Inbox Entries\"]}>\n\n<Tab value=\"Inboxes\">\n```kotlin\nval callbacksId = \"CALLBACKS_ID\"\n\nendpointSession.registerCallback(\n    callbacksId,\n    EventType.InboxCreatedEvent\n){ newInboxData ->\n    // some actions when new inbox created\n}\n\nendpointSession.registerCallback(\n    callbacksId,\n    EventType.InboxUpdatedEvent\n){ inboxUpdateData ->\n    // some actions when inbox updated\n}\n\nendpointSession.registerCallback(\n    callbacksId,\n    EventType.InboxDeletedEvent\n){ deletedInboxData ->\n    // some actions when inbox deleted\n}\n```\n</Tab>\n\n<Tab value='Inbox Entries'>\n```kotlin\nval callbacksId = \"CALLBACKS_ID\"\nval inboxID = \"INBOX_ID\"\n\nendpointSession.registerCallback(\n    callbacksId,\n    EventType.InboxEntryCreatedEvent(inboxID)\n){ newEntryData ->\n    // some actions on new entry\n}\n\nendpointSession.registerCallback(\n    callbacksId,\n    EventType.InboxEntryDeletedEvent(inboxID)\n){ deletedEntryData ->\n    // some actions when entry deleted\n}\n```\n</Tab>\n</Tabs>\n\n[Read more](../start/inboxes/inbox-updates) about Inbox events.",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/kotlin/handling-events.mdx",
        "type": "mdx",
        "chunkIndex": 5,
        "headers": [
          "Inboxes"
        ],
        "title": "Inboxes",
        "codeBlocks": [
          "```kotlin\nval callbacksId = \"CALLBACKS_ID\"\n\nendpointSession.registerCallback(\n    callbacksId,\n    EventType.InboxCreatedEvent\n){ newInboxData ->\n    // some actions when new inbox created\n}\n\nendpointSession.registerCallback(\n    callbacksId,\n    EventType.InboxUpdatedEvent\n){ inboxUpdateData ->\n    // some actions when inbox updated\n}\n\nendpointSession.registerCallback(\n    callbacksId,\n    EventType.InboxDeletedEvent\n){ deletedInboxData ->\n    // some actions when inbox deleted\n}\n```",
          "```kotlin\nval callbacksId = \"CALLBACKS_ID\"\nval inboxID = \"INBOX_ID\"\n\nendpointSession.registerCallback(\n    callbacksId,\n    EventType.InboxEntryCreatedEvent(inboxID)\n){ newEntryData ->\n    // some actions on new entry\n}\n\nendpointSession.registerCallback(\n    callbacksId,\n    EventType.InboxEntryDeletedEvent(inboxID)\n){ deletedEntryData ->\n    // some actions when entry deleted\n}\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.876Z",
        "size": 1069
      }
    },
    {
      "pageContent": "---\ntitle: Overview\ndescription: Inboxes are a secure way for assigned members to receive encrypted inbound traffic from public sources.\n---\n\n\n\n:::info\n\nBefore working with Inboxes, follow our [Getting Started Guide](./introduction). It will show you how to set up your project to work with PrivMX Bridge.\n\nThe sample code on this page is based on the **[initial assumptions](./introduction#initial-assumptions)**.\n\n:::\n\n:::info\n\nInbox `publicMeta` and `privateMeta` fields support any kind of data formats encoded to byte arrays.\nExamples in this section use `kotlinx-serialization-json` dependency to serialize object to JSON format.\n\n:::\n\n## What is an Inbox?\n\nInbox is a container, which is designed to be accessed only by the assigned users. It is managed similarly as Threads and Stores.\nHowever, writing to an Inbox is possible with public API, which doesn't require writer registration and access specification.",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/kotlin/inboxes.mdx",
        "type": "mdx",
        "chunkIndex": 0,
        "headers": [
          "What is an Inbox?"
        ],
        "title": "What is an Inbox?",
        "lastModified": "2025-06-05T19:33:57.877Z",
        "size": 919
      }
    },
    {
      "pageContent": "## Working with Inboxes\n\nTo access Threads methods, get the field `inboxApi` from active connection. Connection should be initialized with `Modules.INBOX` and passed to [`PrivmxEndpoint()`](/reference/kotlin/privmx-endpoint-extra/com.simplito.kotlin.privmx_endpoint_extra.lib/-privmx-endpoint/-privmx-endpoint.html).\n\n```kotlin\nval inboxApi = endpointSession.inboxApi\n```",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/kotlin/inboxes.mdx",
        "type": "mdx",
        "chunkIndex": 1,
        "headers": [
          "Working with Inboxes"
        ],
        "title": "Working with Inboxes",
        "codeBlocks": [
          "```kotlin\nval inboxApi = endpointSession.inboxApi\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.877Z",
        "size": 371
      }
    },
    {
      "pageContent": "## Creating Inboxes\n\n<Tabs groupId=\"variant\" items={[\"Basic\",\"With Config\",\"With a Name\",\"With publicMeta\"]}>\n<Tab value=\"Basic\">\nCreating a basic, unnamed Inbox, which can act as an encrypted data container:\n```kotlin\nval users : List<UserWithPubKey> = listOf(\n    UserWithPubKey(user1Id, user1PublicKey),\n    UserWithPubKey(user2Id, user2PublicKey)\n)\nval managers : List<UserWithPubKey> = listOf(\n    UserWithPubKey(user1Id, user1PublicKey)\n)\nval publicMeta = ByteArray(0)\nval privateMeta = ByteArray(0)\n\nval inboxId = inboxApi.createInbox(\n    contextId,\n    users,\n    managers,\n    publicMeta,\n    privateMeta\n)\n```\n</Tab>\n\n<Tab value=\"With Config\">\nFirst, you need to specify constraints for inbound traffic size limits:\n```kotlin\nval filesConfig = FilesConfig(\n    0L, //minCount\n    10L, //maxCount\n    500L, //maxFileSize\n    2000L //maxWholeUploadSize\n)\n```\nCreating new Inbox:\n```kotlin\nval users : List<UserWithPubKey> = listOf(\n    UserWithPubKey(user1Id, user1PublicKey),\n    UserWithPubKey(user2Id, user2PublicKey)\n)\nval managers : List<UserWithPubKey> = listOf(\n    UserWithPubKey(user1Id, user1PublicKey)\n)\nval publicMeta = ByteArray(0)\nval privateMeta = ByteArray(0)",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/kotlin/inboxes.mdx",
        "type": "mdx",
        "chunkIndex": 2,
        "headers": [
          "Creating Inboxes"
        ],
        "title": "Creating Inboxes",
        "codeBlocks": [
          "```kotlin\nval users : List<UserWithPubKey> = listOf(\n    UserWithPubKey(user1Id, user1PublicKey),\n    UserWithPubKey(user2Id, user2PublicKey)\n)\nval managers : List<UserWithPubKey> = listOf(\n    UserWithPubKey(user1Id, user1PublicKey)\n)\nval publicMeta = ByteArray(0)\nval privateMeta = ByteArray(0)\n\nval inboxId = inboxApi.createInbox(\n    contextId,\n    users,\n    managers,\n    publicMeta,\n    privateMeta\n)\n```",
          "```kotlin\nval filesConfig = FilesConfig(\n    0L, //minCount\n    10L, //maxCount\n    500L, //maxFileSize\n    2000L //maxWholeUploadSize\n)\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.877Z",
        "size": 1184
      }
    },
    {
      "pageContent": "val inboxId = inboxApi.createInbox(\n    contextId,\n    users,\n    managers,\n    publicMeta,\n    privateMeta,\n    filesConfig\n)\n```\n</Tab>\n\n<Tab value=\"With a Name\">\nYou can assign any data to private and public meta fields (e.g. the Inbox's name), as long as it is serialized to byte array:\n```kotlin\nval users : List<UserWithPubKey> = listOf(\n    UserWithPubKey(user1Id, user1PublicKey),\n    UserWithPubKey(user2Id, user2PublicKey)\n)\nval managers : List<UserWithPubKey> = listOf(\n    UserWithPubKey(user1Id, user1PublicKey)\n)\nval publicMeta = ByteArray(0)\nval inboxNameAsPrivateMeta = \"New inbox\"\n\nval inboxId = inboxApi.createInbox(\n    contextId,\n    users,\n    managers,\n    publicMeta,\n    inboxNameAsPrivateMeta.encodeToByteArray()\n)\n```\n</Tab>\n<Tab value=\"With publicMeta\">\nYou can implement a tag system, which allows you to create Inboxes with arbitrary tags. Putting them inside `publicMeta` gives your own server the ability to access it using PrivMX Bridge API.\n\nDefine Inbox public meta structure:\n```kotlin\n@Serializable\ndata class InboxPublicMeta(val tags: List<String>)",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/kotlin/inboxes.mdx",
        "type": "mdx",
        "chunkIndex": 3,
        "codeBlocks": [
          "```\n</Tab>\n\n<Tab value=\"With a Name\">\nYou can assign any data to private and public meta fields (e.g. the Inbox's name), as long as it is serialized to byte array:\n```",
          "```\n</Tab>\n<Tab value=\"With publicMeta\">\nYou can implement a tag system, which allows you to create Inboxes with arbitrary tags. Putting them inside `publicMeta` gives your own server the ability to access it using PrivMX Bridge API.\n\nDefine Inbox public meta structure:\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.877Z",
        "size": 1085
      }
    },
    {
      "pageContent": "```\n\nPrepare and create Inbox:\n```kotlin\nval users : List<UserWithPubKey> = listOf(\n    UserWithPubKey(user1Id, user1PublicKey),\n    UserWithPubKey(user2Id, user2PublicKey)\n)\nval managers : List<UserWithPubKey> = listOf(\n    UserWithPubKey(user1Id, user1PublicKey)\n)\nval publicMeta = InboxPublicMeta(\n    listOf(\"TAG1\", \"TAG2\", \"TAG3\")\n)\nval inboxNameAsPrivateMeta = \"New inbox\"\n\nval inboxID = inboxApi.createInbox(\n    contextId,\n    users,\n    managers,\n    Json.encodeToString(publicMeta).encodeToByteArray(),\n    inboxNameAsPrivateMeta.encodeToByteArray()\n)\n```\n</Tab>\n</Tabs>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/kotlin/inboxes.mdx",
        "type": "mdx",
        "chunkIndex": 4,
        "codeBlocks": [
          "```\n\nPrepare and create Inbox:\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.877Z",
        "size": 580
      }
    },
    {
      "pageContent": "## Getting Inboxes\n\nDefine Inbox item class with decoded `publicMeta` and `privateMeta`:\n```kotlin\ndata class InboxItem(\n    val inbox: Inbox,\n    val decodedPrivateMeta: String,\n    val decodedPublicMeta: InboxPublicMeta\n)",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/kotlin/inboxes.mdx",
        "type": "mdx",
        "chunkIndex": 5,
        "headers": [
          "Getting Inboxes"
        ],
        "title": "Getting Inboxes",
        "lastModified": "2025-06-05T19:33:57.877Z",
        "size": 223
      }
    },
    {
      "pageContent": "```\n\n<Tabs groupId=\"variant\" items={[\"Most Recent\",\"Oldest\",\"By inboxId\"]}>\n<Tab value=\"Most Recent\">\nFetching the most recent Inboxes in given Context:\n```kotlin\nval startIndex = 0L\nval pageSize = 100L\n\nval inboxesPagingList = inboxApi.listInboxes(\n    contextId,\n    startIndex,\n    pageSize,\n    SortOrder.DESC\n)\n\nval inboxes = inboxesPagingList.readItems.map {\n    InboxItem(\n        it,\n        it.privateMeta.decodeToString(),\n        Json.decodeFromString(it.publicMeta.decodeToString())\n    )\n}\n```\n</Tab>\n\n<Tab value=\"Oldest\">\nFetching the oldest Inboxes (by creation date) in given Context:\n```kotlin\nval startIndex = 0L\nval pageSize = 100L\n\nval inboxesPagingList = inboxApi.listInboxes(\n    contextId,\n    startIndex,\n    pageSize,\n    SortOrder.ASC\n)\n\nval inboxes = inboxesPagingList.readItems.map {\n    InboxItem(\n        it,\n        it.privateMeta.decodeToString(),\n        Json.decodeFromString(it.publicMeta.decodeToString())\n    )\n}\n```\n</Tab>\n<Tab value=\"By inboxID\">\nYou can get info about an Inbox using its `inboxId`:\n```kotlin\nval inboxID = \"INBOX_ID\"",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/kotlin/inboxes.mdx",
        "type": "mdx",
        "chunkIndex": 6,
        "codeBlocks": [
          "```\n\n<Tabs groupId=\"variant\" items={[\"Most Recent\",\"Oldest\",\"By inboxId\"]}>\n<Tab value=\"Most Recent\">\nFetching the most recent Inboxes in given Context:\n```",
          "```\n</Tab>\n\n<Tab value=\"Oldest\">\nFetching the oldest Inboxes (by creation date) in given Context:\n```",
          "```\n</Tab>\n<Tab value=\"By inboxID\">\nYou can get info about an Inbox using its `inboxId`:\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.877Z",
        "size": 1073
      }
    },
    {
      "pageContent": "val inboxItem = inboxApi.getInbox(inboxID).let {\n    InboxItem(\n        it,\n        it.privateMeta.decodeToString(),\n        Json.decodeFromString(it.publicMeta.decodeToString())\n    )\n}\n```\n</Tab>\n</Tabs>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/kotlin/inboxes.mdx",
        "type": "mdx",
        "chunkIndex": 7,
        "lastModified": "2025-06-05T19:33:57.877Z",
        "size": 205
      }
    },
    {
      "pageContent": "## Getting Public View\n\nUsers with public connection (created by [`Connection.connectPublic`](/reference/kotlin/privmx-endpoint/com.simplito.kotlin.privmx_endpoint.modules.core/-connection/-companion/connect-public.html))\nhave access to the Public View which shares not encrypted fields of the Inbox, such as `publicMeta`.\n\n```kotlin\nval inboxID = \"INBOX_ID\"\nval inboxPublicView = inboxApi.getInboxPublicView(inboxID)\nval inboxPublicMeta: InboxPublicMeta = Json.decodeFromString(\n    inboxPublicView.publicMeta.decodeToString()\n)\n```",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/kotlin/inboxes.mdx",
        "type": "mdx",
        "chunkIndex": 8,
        "headers": [
          "Getting Public View"
        ],
        "title": "Getting Public View",
        "codeBlocks": [
          "```kotlin\nval inboxID = \"INBOX_ID\"\nval inboxPublicView = inboxApi.getInboxPublicView(inboxID)\nval inboxPublicMeta: InboxPublicMeta = Json.decodeFromString(\n    inboxPublicView.publicMeta.decodeToString()\n)\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.877Z",
        "size": 533
      }
    },
    {
      "pageContent": "## Managing Inboxes\n\n<Tabs groupId=\"variant\" items={[\"Renaming Inbox\",\"Removing User\",\"Deleting Inbox\"]}>\n<Tab value=\"Renaming Inbox\">\nTo update an Inbox you must always provide its current version, as well as:\n- list of users\n- list of managers\n- new private and public meta (even if it didn't change)\n- Inbox's current version\n- Inbox FilesConfig\n- `true` if update action should be forced\n\n```kotlin\nval inboxID = \"INBOX_ID\"\nval inbox: Inbox = inboxApi.getInbox(inboxID)\nval users = inbox\n    .users\n    .map { userId ->\n        //Your application must provide a way,\n        //to get user's public key from their userId.\n        UserWithPubKey(\n            userId,\n            \"USER_PUBLIC_KEY\"\n        )\n    }\nval managers = inbox\n    .managers\n    .map { userId ->\n        //Your application must provide a way,\n        //to get user's public key from their userId.\n        UserWithPubKey(\n            userId,\n            \"USER_PUBLIC_KEY\"\n        )\n    }\nval newInboxNameAsPrivateMeta = \"New inbox name\"",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/kotlin/inboxes.mdx",
        "type": "mdx",
        "chunkIndex": 9,
        "headers": [
          "Managing Inboxes"
        ],
        "title": "Managing Inboxes",
        "lastModified": "2025-06-05T19:33:57.877Z",
        "size": 1010
      }
    },
    {
      "pageContent": "inboxApi.updateInbox(\n    inboxID,\n    users,\n    managers,\n    inbox.publicMeta,\n    newInboxNameAsPrivateMeta.encodeToByteArray(),\n    inbox.filesConfig,\n    inbox.version!!,\n    false\n)\n```\n</Tab>\n\n<Tab value=\"Removing User\">\nTo remove a user from an Inbox you must provide:\n- list of all the users, without the user you want to remove\n- list of managers\n- new private and public meta (even if it didn't change)\n- Inbox's current version\n- Inbox FilesConfig\n- `true` if update action should be forced\n\n```kotlin\nval inboxID = \"INBOX_ID\"\nval inbox: Inbox = inboxApi.getInbox(inboxID)\nval userToRemove = \"USERID_TO_REMOVE\"\nval newUsers = inbox\n    .users\n    .filter {\n        it != userToRemove\n    }.map { userId ->\n        //Your application must provide a way,\n        //to get user's public key from their userId.\n        UserWithPubKey(\n            userId,\n            \"USER_PUBLIC_KEY\"\n        )\n    }\nval managers = inbox\n    .managers\n    .map { userId ->\n        //Your application must provide a way,\n        //to get user's public key from their userId.\n        UserWithPubKey(\n            userId,\n            \"USER_PUBLIC_KEY\"\n        )\n    }",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/kotlin/inboxes.mdx",
        "type": "mdx",
        "chunkIndex": 10,
        "codeBlocks": [
          "```\n</Tab>\n\n<Tab value=\"Removing User\">\nTo remove a user from an Inbox you must provide:\n- list of all the users, without the user you want to remove\n- list of managers\n- new private and public meta (even if it didn't change)\n- Inbox's current version\n- Inbox FilesConfig\n- `true` if update action should be forced\n\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.877Z",
        "size": 1156
      }
    },
    {
      "pageContent": "inboxApi.updateInbox(\n    inboxID,\n    newUsers,\n    managers,\n    inbox.publicMeta,\n    inbox.privateMeta,\n    inbox.filesConfig,\n    inbox.version!!,\n    false\n)\n```\n</Tab>\n\n<Tab value=\"Deleting Inbox\">\nThe snippet below deletes Inbox and all its data. This action is irreversible.\n```kotlin\nval inboxID = \"INBOX_ID\"\ninboxApi.deleteInbox(inboxID)\n```\n</Tab>\n\n</Tabs>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/kotlin/inboxes.mdx",
        "type": "mdx",
        "chunkIndex": 11,
        "codeBlocks": [
          "```\n</Tab>\n\n<Tab value=\"Deleting Inbox\">\nThe snippet below deletes Inbox and all its data. This action is irreversible.\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.877Z",
        "size": 368
      }
    },
    {
      "pageContent": "---\ntitle: Overview\ndescription: This part of the documentation describes our solutions to simplify working with PrivMX Endpoint C++ library inside Java Virtual Machines.\n---",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/kotlin/introduction.mdx",
        "type": "mdx",
        "chunkIndex": 0,
        "lastModified": "2025-06-05T19:33:57.877Z",
        "size": 174
      }
    },
    {
      "pageContent": "## Libraries\n\n### PrivMX Endpoint Kotlin Extra\n\nPrivMX Endpoint Kotlin Extra is the fundamental **recommended library** for using the platform\nin the majority of cases. It encompasses all the essential logic that simplifies and secures the\nusage of our libraries.\n\nThis library implements:\n\n- Enums and static fields to reduce errors while using the methods.\n- [`PrivmxEndpoint`](/reference/kotlin/privmx-endpoint-extra/com.simplito.kotlin.privmx_endpoint_extra.lib/-privmx-endpoint/index.html) for managing connection and registering callbacks on any events.\n- [`PrivmxEndpointContainer`](/reference/kotlin/privmx-endpoint-extra/com.simplito.kotlin.privmx_endpoint_extra.lib/-privmx-endpoint-container/index.html) for managing global session with implemented event loop.\n- Classes to simplify reading and writing to files using byte arrays, InputStream/OutputStream or Source/Sink (kotlinx.io), depending on the platform and use case.\n\n[Go to Reference](/reference/kotlin/privmx-endpoint-extra/index.html) for a detailed description of each class\nor see the source code on [GitHub](https://github.com/simplito/privmx-endpoint-kotlin/tree/main/privmx-endpoint-extra).",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/kotlin/introduction.mdx",
        "type": "mdx",
        "chunkIndex": 1,
        "headers": [
          "Libraries",
          "PrivMX Endpoint Kotlin Extra"
        ],
        "title": "Libraries",
        "lastModified": "2025-06-05T19:33:57.877Z",
        "size": 1167
      }
    },
    {
      "pageContent": "### PrivMX Endpoint Kotlin\n\nPrivMX Endpoint Kotlin is the minimal wrapper library, essential for the platform’s operational\nfunctionality. It declares native functions in Kotlin using JNI. As the most minimalist library\navailable, it provides the highest degree of flexibility in customizing the platform to meet your\nspecific requirements.\n\nThis library implements models, exception catching, and the following modules:\n- `CryptoApi` - Cryptographic methods used to encrypt/decrypt and sign your data or generate keys to work with PrivMX Bridge.\n- `Connection` - Methods for managing connection with PrivMX Bridge.\n- `ThreadApi` - Methods for managing Threads and sending/reading messages.\n- `StoreApi` - Methods for managing Stores and sending/reading files.\n- `InboxApi` - Methods for managing Inboxes and entries.\n\n[Go to Reference](/reference/kotlin/privmx-endpoint/index.html) for a detailed description of each class\nor see the source code on [GitHub](https://github.com/simplito/privmx-endpoint-kotlin/tree/main/privmx-endpoint).",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/kotlin/introduction.mdx",
        "type": "mdx",
        "chunkIndex": 2,
        "headers": [
          "PrivMX Endpoint Kotlin"
        ],
        "title": "PrivMX Endpoint Kotlin",
        "lastModified": "2025-06-05T19:33:57.877Z",
        "size": 1037
      }
    },
    {
      "pageContent": "---\ntitle: Messages\ndescription: Sending messages in Threads.\n---\n\n\n\n:::info\n\nThe sample code on this page is based on the **[initial assumptions](./introduction#initial-assumptions)**.\n\n:::\n\n:::info\n\nMessage `data`, `publicMeta` and `privateMeta` fields support any kind of data formats encoded to byte arrays. Examples in this section use `kotlinx-serialization-json` dependency to serialize object to JSON format.\n\n:::\n\n## Messages inside Threads\nMessages inside Threads are sent in binary format. Before sending a message, you need to decide on the message format and choose the appropriate data serialization method.\n\nFor more information about the Threads architecture and best practices for sending messages, visit the [Threads Documentation](../start/threads/messages).",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/kotlin/messages.mdx",
        "type": "mdx",
        "chunkIndex": 0,
        "headers": [
          "Messages inside Threads"
        ],
        "title": "Messages inside Threads",
        "lastModified": "2025-06-05T19:33:57.878Z",
        "size": 777
      }
    },
    {
      "pageContent": "## Sending Messages\n\n<Tabs groupId=\"variant\" items={[\"Plain Text\", \"With Public Meta\",\"\"]}>\n<Tab value=\"Plain Text\">\nExample of sending a message in Plain Text:\n```kotlin\nval threadID = \"THREAD_ID\"\nval message = \"Message text\"\nval publicMeta = ByteArray(0)\nval privateMeta = ByteArray(0)\n\nval messageID = threadApi.sendMessage(\n    threadID,\n    publicMeta,\n    privateMeta,\n    message.encodeToByteArray()\n)\n```\n</Tab>\n<Tab value='With Public Meta'>\nThe snippet below shows how to set up a feature allowing users to respond to messages.\n\nDefine message public meta structure:\n```kotlin\n@Serializable\ndata class MessagePublicMeta(\n    val responseTo: String\n)\n```\nPrepare and send the message:\n\n```kotlin\nval threadID = \"THREAD_ID\"\nval message = \"Message text\"\nval publicMeta = MessagePublicMeta(responseTo = \"MESSAGE_ID_TO_RESPOND\")\nval privateMeta = ByteArray(0)\n\nval messageID = threadApi.sendMessage(\n    threadID,\n    Json.encodeToString(publicMeta).encodeToByteArray(),\n    privateMeta,\n    message.encodeToByteArray()\n)\n```\n</Tab>\n</Tabs>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/kotlin/messages.mdx",
        "type": "mdx",
        "chunkIndex": 1,
        "headers": [
          "Sending Messages"
        ],
        "title": "Sending Messages",
        "codeBlocks": [
          "```kotlin\nval threadID = \"THREAD_ID\"\nval message = \"Message text\"\nval publicMeta = ByteArray(0)\nval privateMeta = ByteArray(0)\n\nval messageID = threadApi.sendMessage(\n    threadID,\n    publicMeta,\n    privateMeta,\n    message.encodeToByteArray()\n)\n```",
          "```kotlin\n@Serializable\ndata class MessagePublicMeta(\n    val responseTo: String\n)\n```",
          "```kotlin\nval threadID = \"THREAD_ID\"\nval message = \"Message text\"\nval publicMeta = MessagePublicMeta(responseTo = \"MESSAGE_ID_TO_RESPOND\")\nval privateMeta = ByteArray(0)\n\nval messageID = threadApi.sendMessage(\n    threadID,\n    Json.encodeToString(publicMeta).encodeToByteArray(),\n    privateMeta,\n    message.encodeToByteArray()\n)\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.878Z",
        "size": 1045
      }
    },
    {
      "pageContent": "## Getting Messages\n\nDefine message item class with decoded `data` and `publicMeta`:\n\n```kotlin\ndata class MessageItem(\n    val message: Message,\n    val decodedData: String,\n    val decodedPublicMeta: MessagePublicMeta\n)",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/kotlin/messages.mdx",
        "type": "mdx",
        "chunkIndex": 2,
        "headers": [
          "Getting Messages"
        ],
        "title": "Getting Messages",
        "lastModified": "2025-06-05T19:33:57.878Z",
        "size": 221
      }
    },
    {
      "pageContent": "```\n\n<Tabs groupId=\"variant\" items={[\"Most Recent\",\"Oldest\",\"By Message ID\"]}>\n<Tab value=\"Most Recent\">\nFetching the most recent messages in given Thread:\n\n```kotlin\nval threadId = \"THREAD_ID\"\nval startIndex = 0L\nval pageSize = 100L\n\nval messagesPagingList = threadApi.listMessages(\n    threadId,\n    startIndex,\n    pageSize,\n    SortOrder.DESC\n)\n\nval messages = messagesPagingList.readItems.map {\n    MessageItem(\n        it,\n        it.data.decodeToString(),\n        Json.decodeFromString(it.publicMeta.decodeToString())\n    )\n}\n```\n</Tab>\n\n<Tab value=\"Oldest\">\nFetching the oldest messages (by creation date) in given Thread:\n\n```kotlin\nval threadId = \"THREAD_ID\"\nval startIndex = 0L\nval pageSize = 100L\n\nval messagesPagingList = threadApi.listMessages(\n    threadId,\n    startIndex,\n    pageSize,\n    SortOrder.ASC\n)\n\nval messages = messagesPagingList.readItems.map {\n    MessageItem(\n        it,\n        it.data.decodeToString(),\n        Json.decodeFromString(it.publicMeta.decodeToString())\n    )\n}\n```\n</Tab>\n<Tab value=\"By Message ID\">\nYou can get info about a Message using its `messageId`:\n\n```kotlin\nval messageId = \"MESSAGE_ID\"",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/kotlin/messages.mdx",
        "type": "mdx",
        "chunkIndex": 3,
        "codeBlocks": [
          "```\n\n<Tabs groupId=\"variant\" items={[\"Most Recent\",\"Oldest\",\"By Message ID\"]}>\n<Tab value=\"Most Recent\">\nFetching the most recent messages in given Thread:\n\n```",
          "```\n</Tab>\n\n<Tab value=\"Oldest\">\nFetching the oldest messages (by creation date) in given Thread:\n\n```",
          "```\n</Tab>\n<Tab value=\"By Message ID\">\nYou can get info about a Message using its `messageId`:\n\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.878Z",
        "size": 1141
      }
    },
    {
      "pageContent": "```kotlin\nval messageId = \"MESSAGE_ID\"\n\nval messageItem = threadApi.getMessage(messageId).let {\n    MessageItem(\n        it,\n        it.data.decodeToString(),\n        Json.decodeFromString(it.publicMeta.decodeToString())\n    )\n}\n```\n</Tab>\n</Tabs>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/kotlin/messages.mdx",
        "type": "mdx",
        "chunkIndex": 4,
        "codeBlocks": [
          "```kotlin\nval messageId = \"MESSAGE_ID\"\n\nval messageItem = threadApi.getMessage(messageId).let {\n    MessageItem(\n        it,\n        it.data.decodeToString(),\n        Json.decodeFromString(it.publicMeta.decodeToString())\n    )\n}\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.878Z",
        "size": 247
      }
    },
    {
      "pageContent": "## Managing Messages\n\n<Tabs groupId=\"variant\" items={[\"Updating Message\",\"Deleting Message\"]}>\n<Tab value=\"Updating Message\">\nExample of updating the message content:\n\n```kotlin\nval messageID = \"MESSAGE_ID\"\nval message: Message = threadApi.getMessage(messageID)\nval newMessage = \"New message\"\n\nthreadApi.updateMessage(\n    messageID,\n    message.publicMeta,\n    message.privateMeta,\n    newMessage.encodeToByteArray()\n)\n```\n</Tab>\n\n<Tab value=\"Deleting Message\">\nThe snippet below deletes Message and all its data. This action is irreversible.\n```kotlin\nval messageID = \"MESSAGE_ID\"\nthreadApi.deleteMessage(messageID)\n```\n</Tab>\n\n</Tabs>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/kotlin/messages.mdx",
        "type": "mdx",
        "chunkIndex": 5,
        "headers": [
          "Managing Messages"
        ],
        "title": "Managing Messages",
        "codeBlocks": [
          "```kotlin\nval messageID = \"MESSAGE_ID\"\nval message: Message = threadApi.getMessage(messageID)\nval newMessage = \"New message\"\n\nthreadApi.updateMessage(\n    messageID,\n    message.publicMeta,\n    message.privateMeta,\n    newMessage.encodeToByteArray()\n)\n```",
          "```kotlin\nval messageID = \"MESSAGE_ID\"\nthreadApi.deleteMessage(messageID)\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.878Z",
        "size": 637
      }
    },
    {
      "pageContent": "---\ntitle: Policy Builders\ndescription: PrivMX Endpoint has configurable policies that determine who can perform specified actions in Containers and Items.\n---\n\n\n\nTo learn more about Policies, see the [Policies documentation](../start/policies).\n\nPrivMX Endpoint Kotlin Extra library provides classes that provide static fields of available policy values in `ItemPolicyValues`, `ContainerPolicyValues` and `SpecialPolicyValue`,\nas well as `ItemPolicyBuilder` and `ContainerPolicyBuilder` classes for configuring the respective policies.\n\n## Combining Policy Values\n\nSome policy values like `ContainerPolicyComplexValue` or `ItemPolicyComplexValue` can be combined\nwith the same type of policy value using `AND` and `OR` methods.\n```kotlin\nval itemPolicyValue: ItemPolicyValue = ItemPolicyValues.ITEM_OWNER AND\n    ItemPolicyValues.MANAGER OR\n    ItemPolicyValues.USER\n```",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/kotlin/policy-builders.mdx",
        "type": "mdx",
        "chunkIndex": 0,
        "headers": [
          "Combining Policy Values"
        ],
        "title": "Combining Policy Values",
        "codeBlocks": [
          "```kotlin\nval itemPolicyValue: ItemPolicyValue = ItemPolicyValues.ITEM_OWNER AND\n    ItemPolicyValues.MANAGER OR\n    ItemPolicyValues.USER\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.878Z",
        "size": 871
      }
    },
    {
      "pageContent": "## Configuring a Container Policy\n\nBuilder will create an empty policy, if it's not configured yet, which is equivalent to setting `inherit` in all fields. To configure it, call the methods responsible for setting particular policies.\nThose calls can be chained together, since each of the methods setting a policy value returns the reference to the builder.\nThe `ContainerPolicyBuilder` can build both `ContainerPolicy` and `ContainerPolicyWithoutItem` by calling `.build()` and `.buildWithoutItem()` respectively.\n\nTo build the `ItemPolicy`, use `ItemPolicyBuilder` which works in the same way as `ContainerPolicyBuilder`.\n<Tabs groupId=\"variant\" items={[\"ItemPolicy\",\"ContainerPolicyWithoutItem\",\"ContainerPolicy\"]}>\n\n<Tab value=\"ItemPolicy\">\n```kotlin\nval itemPolicy: ItemPolicy = ItemPolicyBuilder()\n    .update(\n        ItemPolicyValues.ITEM_OWNER AND\n                ItemPolicyValues.MANAGER OR\n                ItemPolicyValues.USER\n    )\n    .listMy(ContainerPolicyValues.USER)\n    .build()\n```\n</Tab>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/kotlin/policy-builders.mdx",
        "type": "mdx",
        "chunkIndex": 1,
        "headers": [
          "Configuring a Container Policy"
        ],
        "title": "Configuring a Container Policy",
        "codeBlocks": [
          "```kotlin\nval itemPolicy: ItemPolicy = ItemPolicyBuilder()\n    .update(\n        ItemPolicyValues.ITEM_OWNER AND\n                ItemPolicyValues.MANAGER OR\n                ItemPolicyValues.USER\n    )\n    .listMy(ContainerPolicyValues.USER)\n    .build()\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.878Z",
        "size": 1009
      }
    },
    {
      "pageContent": "<Tab value=\"ContainerPolicyWithoutItem\">\n```kotlin\nval containerPolicyWithoutItem: ContainerPolicyWithoutItem = ContainerPolicyBuilder()\n    .get(ContainerPolicyValues.ALL)\n    .updatePolicy(\n        ContainerPolicyValues.OWNER AND\n                ContainerPolicyValues.MANAGER\n    )\n    .buildWithoutItem()\n```\n</Tab>\n\n<Tab value=\"ContainerPolicy\">\n```kotlin\nval containerPolicy: ContainerPolicy = ContainerPolicyBuilder()\n    .get(ContainerPolicyValues.ALL)\n    .item(\n        ItemPolicyBuilder()\n            .update(\n                ItemPolicyValues.ITEM_OWNER AND\n                        ItemPolicyValues.MANAGER OR\n                        ItemPolicyValues.USER\n            )\n            .listMy(ContainerPolicyValues.USER)\n            .build()\n    )\n    .build()\n```\n</Tab>\n</Tabs>\n\nAlternatively, you can use helper functions like `itemPolicy`, `containerPolicy` or `containerPolicyWithoutItem`, which offer a cleaner way to define your policies.\n\n<Tabs groupId=\"variant\" items={[\"ItemPolicy\", \"ContainerPolicyWithoutItem\", \"ContainerPolicy\"]}>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/kotlin/policy-builders.mdx",
        "type": "mdx",
        "chunkIndex": 2,
        "codeBlocks": [
          "```kotlin\nval containerPolicyWithoutItem: ContainerPolicyWithoutItem = ContainerPolicyBuilder()\n    .get(ContainerPolicyValues.ALL)\n    .updatePolicy(\n        ContainerPolicyValues.OWNER AND\n                ContainerPolicyValues.MANAGER\n    )\n    .buildWithoutItem()\n```",
          "```kotlin\nval containerPolicy: ContainerPolicy = ContainerPolicyBuilder()\n    .get(ContainerPolicyValues.ALL)\n    .item(\n        ItemPolicyBuilder()\n            .update(\n                ItemPolicyValues.ITEM_OWNER AND\n                        ItemPolicyValues.MANAGER OR\n                        ItemPolicyValues.USER\n            )\n            .listMy(ContainerPolicyValues.USER)\n            .build()\n    )\n    .build()\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.878Z",
        "size": 1050
      }
    },
    {
      "pageContent": "<Tabs groupId=\"variant\" items={[\"ItemPolicy\", \"ContainerPolicyWithoutItem\", \"ContainerPolicy\"]}>\n\n<Tab value=\"ItemPolicy\">\n```kotlin\nval itemPolicy: ItemPolicy = itemPolicy {\n    update(\n        ItemPolicyValues.ITEM_OWNER AND\n                ItemPolicyValues.MANAGER OR\n                ItemPolicyValues.USER\n    )\n    listMy(ContainerPolicyValues.USER)\n}\n```\n</Tab>\n\n<Tab value=\"ContainerPolicyWithoutItem\">\n```kotlin\nval containerPolicyWithoutItem: ContainerPolicyWithoutItem = containerPolicyWithoutItem {\n    get(ContainerPolicyValues.ALL)\n    updatePolicy(\n        ContainerPolicyValues.OWNER AND\n                ContainerPolicyValues.MANAGER\n    )\n}\n```\n</Tab>\n\n<Tab value=\"ContainerPolicy\">\n```kotlin\nval containerPolicy: ContainerPolicy = containerPolicy {\n    get(ContainerPolicyValues.ALL)\n    item(\n        itemPolicy {\n            update(\n                ItemPolicyValues.ITEM_OWNER AND\n                        ItemPolicyValues.MANAGER OR\n                        ItemPolicyValues.USER\n            )\n            listMy(ContainerPolicyValues.USER)\n        }\n    )\n}\n```\n</Tab>\n</Tabs>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/kotlin/policy-builders.mdx",
        "type": "mdx",
        "chunkIndex": 3,
        "codeBlocks": [
          "```kotlin\nval itemPolicy: ItemPolicy = itemPolicy {\n    update(\n        ItemPolicyValues.ITEM_OWNER AND\n                ItemPolicyValues.MANAGER OR\n                ItemPolicyValues.USER\n    )\n    listMy(ContainerPolicyValues.USER)\n}\n```",
          "```kotlin\nval containerPolicyWithoutItem: ContainerPolicyWithoutItem = containerPolicyWithoutItem {\n    get(ContainerPolicyValues.ALL)\n    updatePolicy(\n        ContainerPolicyValues.OWNER AND\n                ContainerPolicyValues.MANAGER\n    )\n}\n```",
          "```kotlin\nval containerPolicy: ContainerPolicy = containerPolicy {\n    get(ContainerPolicyValues.ALL)\n    item(\n        itemPolicy {\n            update(\n                ItemPolicyValues.ITEM_OWNER AND\n                        ItemPolicyValues.MANAGER OR\n                        ItemPolicyValues.USER\n            )\n            listMy(ContainerPolicyValues.USER)\n        }\n    )\n}\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.878Z",
        "size": 1094
      }
    },
    {
      "pageContent": "---\ntitle: Stores\ndescription: Stores provide encrypted block storage, enabling simple file uploading and downloading.\n---\n\n\n:::info\n\nBefore working with Stores, follow our [Getting Started Guide](./introduction). It will show you how to set up your project to work with PrivMX Bridge.\n\nThe sample code on this page is based on the **[initial assumptions](./introduction#initial-assumptions)**.\n\n:::\n\n:::info\n\nStore `publicMeta` and `privateMeta` fields support any kind of data formats encoded to byte arrays. Examples in this section use `kotlinx-serialization-json` dependency to serialize object to JSON format.\n\n:::\n\n## Working with Stores\n\nTo access Store methods, get the field `storeApi` from active connection. Connection should be initialized with `Modules.STORE` passed to [`PrivmxEndpoint()`](/reference/kotlin/privmx-endpoint-extra/com.simplito.kotlin.privmx_endpoint_extra.lib/-privmx-endpoint/-privmx-endpoint.html).\n\n```kotlin\nval storeApi = endpointSession.storeApi\n```",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/kotlin/stores.mdx",
        "type": "mdx",
        "chunkIndex": 0,
        "headers": [
          "Working with Stores"
        ],
        "title": "Working with Stores",
        "codeBlocks": [
          "```kotlin\nval storeApi = endpointSession.storeApi\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.879Z",
        "size": 986
      }
    },
    {
      "pageContent": "## Creating Stores\n\n<Tabs groupId=\"variant\" items={[\"Basic\",\"With a Name\",\"With publicMeta\"]}>\n<Tab value=\"basic\" label=\"Basic\">\nCreating a basic, unnamed Store, which can act as an encrypted data container:\n```kotlin\nval users : List<UserWithPubKey> = listOf(\n    UserWithPubKey(user1Id, user1PublicKey),\n    UserWithPubKey(user2Id, user2PublicKey)\n)\nval managers : List<UserWithPubKey> = listOf(\n    UserWithPubKey(user1Id, user1PublicKey)\n)\nval publicMeta = ByteArray(0)\nval privateMeta = ByteArray(0)\n\nval storeId = storeApi.createStore(\n    contextId,\n    users,\n    managers,\n    publicMeta,\n    privateMeta\n)\n```\n</Tab>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/kotlin/stores.mdx",
        "type": "mdx",
        "chunkIndex": 1,
        "headers": [
          "Creating Stores"
        ],
        "title": "Creating Stores",
        "codeBlocks": [
          "```kotlin\nval users : List<UserWithPubKey> = listOf(\n    UserWithPubKey(user1Id, user1PublicKey),\n    UserWithPubKey(user2Id, user2PublicKey)\n)\nval managers : List<UserWithPubKey> = listOf(\n    UserWithPubKey(user1Id, user1PublicKey)\n)\nval publicMeta = ByteArray(0)\nval privateMeta = ByteArray(0)\n\nval storeId = storeApi.createStore(\n    contextId,\n    users,\n    managers,\n    publicMeta,\n    privateMeta\n)\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.879Z",
        "size": 626
      }
    },
    {
      "pageContent": "val storeId = storeApi.createStore(\n    contextId,\n    users,\n    managers,\n    publicMeta,\n    privateMeta\n)\n```\n</Tab>\n\n<Tab value=\"With a Name\">\nYou can assign any data to private and public meta fields (e.g. the Store's name), as long as they are serialized to byte array:\n```kotlin\nval users : List<UserWithPubKey> = listOf(\n    UserWithPubKey(user1Id, user1PublicKey),\n    UserWithPubKey(user2Id, user2PublicKey)\n)\nval managers : List<UserWithPubKey> = listOf(\n    UserWithPubKey(user1Id, user1PublicKey)\n)\nval publicMeta = ByteArray(0)\nval storeNameAsPrivateMeta = \"New store\"\nval storeId = storeApi.createStore(\n    contextId,\n    users,\n    managers,\n    publicMeta,\n    storeNameAsPrivateMeta.encodeToByteArray()\n)\n```\n</Tab>\n<Tab value=\"With publicMeta\">\nYou can implement a tag system which allows you to create Stores with arbitrary tags. Putting them inside `publicMeta` gives your own server the ability to access it using PrivMX Bridge API:\n\nDefine Store public meta structure:\n```kotlin\n@Serializable\ndata class StorePublicMeta(val tags: List<String>)",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/kotlin/stores.mdx",
        "type": "mdx",
        "chunkIndex": 2,
        "codeBlocks": [
          "```\n</Tab>\n\n<Tab value=\"With a Name\">\nYou can assign any data to private and public meta fields (e.g. the Store's name), as long as they are serialized to byte array:\n```",
          "```\n</Tab>\n<Tab value=\"With publicMeta\">\nYou can implement a tag system which allows you to create Stores with arbitrary tags. Putting them inside `publicMeta` gives your own server the ability to access it using PrivMX Bridge API:\n\nDefine Store public meta structure:\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.879Z",
        "size": 1068
      }
    },
    {
      "pageContent": "```\n\nPrepare and create Store:\n```kotlin\nval users : List<UserWithPubKey> = listOf(\n    UserWithPubKey(user1Id, user1PublicKey),\n    UserWithPubKey(user2Id, user2PublicKey)\n)\nval managers : List<UserWithPubKey> = listOf(\n    UserWithPubKey(user1Id, user1PublicKey)\n)\nval publicMeta = StorePublicMeta(\n    listOf(\"TAG1\", \"TAG2\", \"TAG3\")\n)\nval storeNameAsPrivateMeta = \"New store\"\n\nval storeID = storeApi.createStore(\n    contextId,\n    users,\n    managers,\n    Json.encodeToString(publicMeta).encodeToByteArray(),\n    storeNameAsPrivateMeta.encodeToByteArray()\n)\n```\n</Tab>\n</Tabs>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/kotlin/stores.mdx",
        "type": "mdx",
        "chunkIndex": 3,
        "codeBlocks": [
          "```\n\nPrepare and create Store:\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.879Z",
        "size": 580
      }
    },
    {
      "pageContent": "## Getting Stores\n\nDefine Store item class with decoded `publicMeta` and `privateMeta`:\n```kotlin\ndata class StoreItem(\n    val store: Store,\n    val decodedPrivateMeta: String,\n    val decodedPublicMeta: StorePublicMeta\n)",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/kotlin/stores.mdx",
        "type": "mdx",
        "chunkIndex": 4,
        "headers": [
          "Getting Stores"
        ],
        "title": "Getting Stores",
        "lastModified": "2025-06-05T19:33:57.879Z",
        "size": 222
      }
    },
    {
      "pageContent": "```\n\n<Tabs groupId=\"variant\" items={[\"Most Recent\",\"Oldest\",\"By Store ID\"]}>\n<Tab value=\"Most Recent\">\nFetching the most recent Stores in given Context:\n```kotlin\nval startIndex = 0L\nval pageSize = 100L\n\nval storesPagingList = storeApi.listStores(\n    contextId,\n    startIndex,\n    pageSize,\n    SortOrder.DESC\n)\n\nval stores = storesPagingList.readItems.map {\n    StoreItem(\n        it,\n        it.privateMeta.decodeToString(),\n        Json.decodeFromString(it.publicMeta.decodeToString())\n    )\n}\n```\n</Tab>\n\n<Tab value=\"Oldest\">\nFetching the oldest Stores (by creation date) in given Context:\n```kotlin\nval startIndex = 0L\nval pageSize = 100L\n\nval storesPagingList = storeApi.listStores(\n    contextId,\n    startIndex,\n    pageSize,\n    SortOrder.ASC\n)\n\nval stores = storesPagingList.readItems.map {\n    StoreItem(\n        it,\n        it.privateMeta.decodeToString(),\n        Json.decodeFromString(it.publicMeta.decodeToString())\n    )\n}\n```\n</Tab>\n<Tab value=\"By Store ID\">\nYou can get info about a Store using its `storeId`:\n```kotlin\nval storeId = \"STORE_ID\"",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/kotlin/stores.mdx",
        "type": "mdx",
        "chunkIndex": 5,
        "codeBlocks": [
          "```\n\n<Tabs groupId=\"variant\" items={[\"Most Recent\",\"Oldest\",\"By Store ID\"]}>\n<Tab value=\"Most Recent\">\nFetching the most recent Stores in given Context:\n```",
          "```\n</Tab>\n\n<Tab value=\"Oldest\">\nFetching the oldest Stores (by creation date) in given Context:\n```",
          "```\n</Tab>\n<Tab value=\"By Store ID\">\nYou can get info about a Store using its `storeId`:\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.879Z",
        "size": 1064
      }
    },
    {
      "pageContent": "val storeItem = storeApi.getStore(storeId).let {\n    StoreItem(\n        it,\n        it.privateMeta.decodeToString(),\n        Json.decodeFromString(it.publicMeta.decodeToString())\n    )\n}\n```\n</Tab>\n</Tabs>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/kotlin/stores.mdx",
        "type": "mdx",
        "chunkIndex": 6,
        "lastModified": "2025-06-05T19:33:57.879Z",
        "size": 205
      }
    },
    {
      "pageContent": "## Managing Stores\n\n<Tabs groupId=\"variant\" items={[\"Renaming Store\",\"Removing User\",\"Deleting Store\"]}>\n<Tab value=\"Renaming Store\">\nTo update a Store you must always provide its current version, as well as:\n- list of users\n- list of managers\n- new private and public meta (even if it didn't change)\n- Store's current version\n- `true` if update action should be forced\n\n```kotlin\nval storeID = \"STORE_ID\"\nval store: Store = storeApi.getStore(storeID)\nval users = store\n    .users\n    .map { userId ->\n        //Your application must provide a way,\n        //to get user's public key from their userId.\n        UserWithPubKey(\n            userId,\n            \"USER_PUBLIC_KEY\"\n        )\n    }\nval managers = store\n    .managers\n    .map { userId ->\n        //Your application must provide a way,\n        //to get user's public key from their userId.\n        UserWithPubKey(\n            userId,\n            \"USER_PUBLIC_KEY\"\n        )\n    }\nval newStoreNameAsPrivateMeta = \"New store name\"\n\nstoreApi.updateStore(\n    storeID,\n    users,\n    managers,\n    store.publicMeta,\n    newStoreNameAsPrivateMeta.encodeToByteArray(),\n    store.version!!,\n    false\n)\n```\n</Tab>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/kotlin/stores.mdx",
        "type": "mdx",
        "chunkIndex": 7,
        "headers": [
          "Managing Stores"
        ],
        "title": "Managing Stores",
        "codeBlocks": [
          "```kotlin\nval storeID = \"STORE_ID\"\nval store: Store = storeApi.getStore(storeID)\nval users = store\n    .users\n    .map { userId ->\n        //Your application must provide a way,\n        //to get user's public key from their userId.\n        UserWithPubKey(\n            userId,\n            \"USER_PUBLIC_KEY\"\n        )\n    }\nval managers = store\n    .managers\n    .map { userId ->\n        //Your application must provide a way,\n        //to get user's public key from their userId.\n        UserWithPubKey(\n            userId,\n            \"USER_PUBLIC_KEY\"\n        )\n    }\nval newStoreNameAsPrivateMeta = \"New store name\"\n\nstoreApi.updateStore(\n    storeID,\n    users,\n    managers,\n    store.publicMeta,\n    newStoreNameAsPrivateMeta.encodeToByteArray(),\n    store.version!!,\n    false\n)\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.879Z",
        "size": 1166
      }
    },
    {
      "pageContent": "storeApi.updateStore(\n    storeID,\n    users,\n    managers,\n    store.publicMeta,\n    newStoreNameAsPrivateMeta.encodeToByteArray(),\n    store.version!!,\n    false\n)\n```\n</Tab>\n\n<Tab value=\"Removing User\">\nTo remove a user from a Store you must provide:\n- list of all the users, without the user you want to remove\n- list of managers\n- new private and public meta (even if it didn't change)\n- Store's current version\n- `true` if update action should be forced\n\n```kotlin\nval storeID = \"STORE_ID\"\nval store: Store = storeApi.getStore(storeID)\nval userToRemove = \"USERID_TO_REMOVE\"\nval newUsers = store\n    .users\n    .filter {\n        it != userToRemove\n    }.map { userId ->\n        //Your application must provide a way,\n        //to get user's public key from their userId.\n        UserWithPubKey(\n            userId,\n            \"USER_PUBLIC_KEY\"\n        )\n    }\nval managers = store\n    .managers\n    .map { userId ->\n        //Your application must provide a way,\n        //to get user's public key from their userId.\n        UserWithPubKey(\n            userId,\n            \"USER_PUBLIC_KEY\"\n        )\n    }",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/kotlin/stores.mdx",
        "type": "mdx",
        "chunkIndex": 8,
        "codeBlocks": [
          "```\n</Tab>\n\n<Tab value=\"Removing User\">\nTo remove a user from a Store you must provide:\n- list of all the users, without the user you want to remove\n- list of managers\n- new private and public meta (even if it didn't change)\n- Store's current version\n- `true` if update action should be forced\n\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.879Z",
        "size": 1112
      }
    },
    {
      "pageContent": "storeApi.updateStore(\n    storeID,\n    newUsers,\n    managers,\n    store.publicMeta,\n    store.privateMeta,\n    store.version!!,\n    false\n)\n```\n</Tab>\n\n<Tab value=\"Deleting Store\">\nThe snippet below deletes Store and all its data. This action is irreversible.\n```kotlin\nval storeID = \"STORE_ID\"\nstoreApi.deleteStore(storeID)\n```\n</Tab>\n\n</Tabs>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/kotlin/stores.mdx",
        "type": "mdx",
        "chunkIndex": 9,
        "codeBlocks": [
          "```\n</Tab>\n\n<Tab value=\"Deleting Store\">\nThe snippet below deletes Store and all its data. This action is irreversible.\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.879Z",
        "size": 345
      }
    },
    {
      "pageContent": "---\ntitle: Threads\ndescription: Threads are a secure way for assigned members to exchange encrypted messages.\n---\n\n\n\n:::info\n\nBefore working with Threads, follow our [Getting Started Guide](./introduction). It will show you how to set up your project to work with PrivMX Bridge.\n\nThe sample code on this page is based on the **[initial assumptions](./introduction#initial-assumptions)**.\n\n:::\n\n\n:::info\n\nThread `publicMeta` and `privateMeta` fields support any kind of data formats encoded to byte arrays. \nExamples in this section use `kotlinx-serialization-json` dependency to serialize object to JSON format.\n\n:::\n\n## Working with Threads\n\nTo access Threads methods, get the field `threadApi` from active connection. Connection should be initialized with `Modules.THREAD` passed to [`PrivmxEndpoint()`](/reference/kotlin/privmx-endpoint-extra/com.simplito.kotlin.privmx_endpoint_extra.lib/-privmx-endpoint/-privmx-endpoint.html).\n\n```kotlin\nval threadApi = endpointSession.threadApi\n```",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/kotlin/threads.mdx",
        "type": "mdx",
        "chunkIndex": 0,
        "headers": [
          "Working with Threads"
        ],
        "title": "Working with Threads",
        "codeBlocks": [
          "```kotlin\nval threadApi = endpointSession.threadApi\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.879Z",
        "size": 989
      }
    },
    {
      "pageContent": "## Creating Threads\n\n<Tabs groupId=\"variant\" items={[\"Basic\",\"With a Name\",\"With publicMeta\"]}>\n<Tab value=\"basic\" label=\"Basic\">\nCreating a basic, unnamed Thread, which can act as an encrypted data container.\n```kotlin\nval users : List<UserWithPubKey> = listOf(\n    UserWithPubKey(user1Id, user1PublicKey),\n    UserWithPubKey(user2Id, user2PublicKey)\n)\nval managers : List<UserWithPubKey> = listOf(\n    UserWithPubKey(user1Id, user1PublicKey)\n)\nval publicMeta = ByteArray(0)\nval privateMeta = ByteArray(0)\n\nval threadId = threadApi.createThread(\n    contextId,\n    users,\n    managers,\n    publicMeta,\n    privateMeta\n)\n```\n</Tab>\n\n<Tab value=\"With a Name\">\nYou can assign any data to private and public meta fields (e.g. the Thread's name), as long as they are serialized to byte array.\n```kotlin\nval users : List<UserWithPubKey> = listOf(\n    UserWithPubKey(user1Id, user1PublicKey),\n    UserWithPubKey(user2Id, user2PublicKey)\n)\nval managers : List<UserWithPubKey> = listOf(\n    UserWithPubKey(user1Id, user1PublicKey)\n)\nval threadNameAsPrivateMeta = \"New thread\"\nval publicMeta = ByteArray(0)",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/kotlin/threads.mdx",
        "type": "mdx",
        "chunkIndex": 1,
        "headers": [
          "Creating Threads"
        ],
        "title": "Creating Threads",
        "codeBlocks": [
          "```kotlin\nval users : List<UserWithPubKey> = listOf(\n    UserWithPubKey(user1Id, user1PublicKey),\n    UserWithPubKey(user2Id, user2PublicKey)\n)\nval managers : List<UserWithPubKey> = listOf(\n    UserWithPubKey(user1Id, user1PublicKey)\n)\nval publicMeta = ByteArray(0)\nval privateMeta = ByteArray(0)\n\nval threadId = threadApi.createThread(\n    contextId,\n    users,\n    managers,\n    publicMeta,\n    privateMeta\n)\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.879Z",
        "size": 1097
      }
    },
    {
      "pageContent": "val threadId = threadApi.createThread(\n    contextId,\n    users,\n    managers,\n    publicMeta,\n    threadNameAsPrivateMeta.encodeToByteArray()\n)\n```\n</Tab>\n<Tab value=\"With publicMeta\">\nYou can implement a tag system which allows you to create Threads with arbitrary tags. Putting them inside `publicMeta` gives your own server ability to access it using PrivMX Bridge API.\n\nDefine Thread public meta structure:\n```kotlin\n@Serializable\ndata class ThreadPublicMeta(val tags: List<String>)",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/kotlin/threads.mdx",
        "type": "mdx",
        "chunkIndex": 2,
        "codeBlocks": [
          "```\n</Tab>\n<Tab value=\"With publicMeta\">\nYou can implement a tag system which allows you to create Threads with arbitrary tags. Putting them inside `publicMeta` gives your own server ability to access it using PrivMX Bridge API.\n\nDefine Thread public meta structure:\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.879Z",
        "size": 487
      }
    },
    {
      "pageContent": "```\n\nPrepare and create Thread:\n```kotlin\nval users: List<UserWithPubKey> = listOf(\n    UserWithPubKey(user1Id, user1PublicKey),\n    UserWithPubKey(user2Id, user2PublicKey)\n)\nval managers: List<UserWithPubKey> = listOf(\n    UserWithPubKey(user1Id, user1PublicKey)\n)\nval threadNameAsPrivateMeta = \"New thread\"\nval publicMeta = ThreadPublicMeta(\n    listOf(\"TAG1\", \"TAG2\", \"TAG3\")\n)\n\nval threadId = threadApi.createThread(\n    contextId,\n    users,\n    managers,\n    Json.encodeToString(publicMeta).encodeToByteArray(),\n    threadNameAsPrivateMeta.encodeToByteArray()\n)\n```\n</Tab>\n</Tabs>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/kotlin/threads.mdx",
        "type": "mdx",
        "chunkIndex": 3,
        "codeBlocks": [
          "```\n\nPrepare and create Thread:\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.879Z",
        "size": 586
      }
    },
    {
      "pageContent": "## Getting Threads\n\nDefine Thread item class with decoded `publicMeta` and `privateMeta`:\n```kotlin\ndata class ThreadItem(\n    val thread: com.simplito.kotlin.privmx_endpoint.model.Thread,\n    val decodedPrivateMeta: String,\n    val decodedPublicMeta: ThreadPublicMeta\n)",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/kotlin/threads.mdx",
        "type": "mdx",
        "chunkIndex": 4,
        "headers": [
          "Getting Threads"
        ],
        "title": "Getting Threads",
        "lastModified": "2025-06-05T19:33:57.879Z",
        "size": 270
      }
    },
    {
      "pageContent": "```\n\n<Tabs groupId=\"variant\" items={[\"Most Recent\",\"Oldest\",\"By `threadID`\"]}>\n<Tab  label=\"Most Recent\">\nFetching the most recent Threads in given Context:\n```kotlin\nval startIndex = 0L\nval pageSize = 100L\n\nval threadsPagingList = threadApi.listThreads(\n    contextId,\n    startIndex,\n    pageSize,\n    SortOrder.DESC\n)\nval threads = threadsPagingList.readItems.map {\n    ThreadItem(\n        it,\n        it.privateMeta.decodeToString(),\n        Json.decodeFromString(it.publicMeta.decodeToString())\n    )\n}\n```\n</Tab>\n\n<Tab value=\"oldest\" label=\"Oldest\">\nFetching the oldest Threads (by creation date) in given Context:\n```kotlin\nval startIndex = 0L\nval pageSize = 100L",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/kotlin/threads.mdx",
        "type": "mdx",
        "chunkIndex": 5,
        "codeBlocks": [
          "```\n\n<Tabs groupId=\"variant\" items={[\"Most Recent\",\"Oldest\",\"By `threadID`\"]}>\n<Tab  label=\"Most Recent\">\nFetching the most recent Threads in given Context:\n```",
          "```\n</Tab>\n\n<Tab value=\"oldest\" label=\"Oldest\">\nFetching the oldest Threads (by creation date) in given Context:\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.879Z",
        "size": 670
      }
    },
    {
      "pageContent": "<Tab value=\"oldest\" label=\"Oldest\">\nFetching the oldest Threads (by creation date) in given Context:\n```kotlin\nval startIndex = 0L\nval pageSize = 100L\n\nval threadsPagingList = threadApi.listThreads(\n    contextId,\n    startIndex,\n    pageSize,\n    SortOrder.ASC\n)\nval threads = threadsPagingList.readItems.map {\n    ThreadItem(\n        it,\n        it.privateMeta.decodeToString(),\n        Json.decodeFromString(it.publicMeta.decodeToString())\n    )\n}\n```\n</Tab>\n<Tab value=\"By `threadId`\">\nYou can get info about a Thread using its `threadId`:\n```kotlin\nval threadId = \"THREAD_ID\"\nval threadItem = threadApi.getThread(threadId).let {\n    ThreadItem(\n        it,\n        it.privateMeta.decodeToString(),\n        Json.decodeFromString(it.publicMeta.decodeToString())\n    )\n}\n```\n</Tab>\n</Tabs>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/kotlin/threads.mdx",
        "type": "mdx",
        "chunkIndex": 6,
        "codeBlocks": [
          "```kotlin\nval startIndex = 0L\nval pageSize = 100L\n\nval threadsPagingList = threadApi.listThreads(\n    contextId,\n    startIndex,\n    pageSize,\n    SortOrder.ASC\n)\nval threads = threadsPagingList.readItems.map {\n    ThreadItem(\n        it,\n        it.privateMeta.decodeToString(),\n        Json.decodeFromString(it.publicMeta.decodeToString())\n    )\n}\n```",
          "```kotlin\nval threadId = \"THREAD_ID\"\nval threadItem = threadApi.getThread(threadId).let {\n    ThreadItem(\n        it,\n        it.privateMeta.decodeToString(),\n        Json.decodeFromString(it.publicMeta.decodeToString())\n    )\n}\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.879Z",
        "size": 791
      }
    },
    {
      "pageContent": "## Managing Threads\n\n<Tabs groupId=\"variant\" items={[\"Renaming Thread\",\"Removing User\",\"Deleting Thread\"]}>\n<Tab value=\"Renaming Thread\">\nTo update a Thread you must always provide its current version, as well as:\n- list of users\n- list of managers\n- new private and public meta (even if it didn't change)\n- Thread's current version\n- `true` if update action should be forced\n\n```kotlin\nval threadID = \"THREAD_ID\"\nval thread: Thread = threadApi.getThread(threadID)\nval users = thread\n    .users\n    .map { userId ->\n        //Your application must provide a way,\n        //to get user's public key from their userId.\n        UserWithPubKey(\n            userId,\n            \"USER_PUBLIC_KEY\"\n        )\n    }\nval managers = thread\n    .managers\n    .map { userId ->\n        //Your application must provide a way,\n        //to get user's public key from their userId.\n        UserWithPubKey(\n            userId,\n            \"USER_PUBLIC_KEY\"\n        )\n    }\nval newThreadNameAsPrivateMeta = \"New thread name\"\n\nthreadApi.updateThread(\n    thread.threadId,\n    users,\n    managers,\n    thread.publicMeta,\n    newThreadNameAsPrivateMeta.encodeToByteArray(),\n    thread.version!!,\n    false\n)\n```\n</Tab>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/kotlin/threads.mdx",
        "type": "mdx",
        "chunkIndex": 7,
        "headers": [
          "Managing Threads"
        ],
        "title": "Managing Threads",
        "codeBlocks": [
          "```kotlin\nval threadID = \"THREAD_ID\"\nval thread: Thread = threadApi.getThread(threadID)\nval users = thread\n    .users\n    .map { userId ->\n        //Your application must provide a way,\n        //to get user's public key from their userId.\n        UserWithPubKey(\n            userId,\n            \"USER_PUBLIC_KEY\"\n        )\n    }\nval managers = thread\n    .managers\n    .map { userId ->\n        //Your application must provide a way,\n        //to get user's public key from their userId.\n        UserWithPubKey(\n            userId,\n            \"USER_PUBLIC_KEY\"\n        )\n    }\nval newThreadNameAsPrivateMeta = \"New thread name\"\n\nthreadApi.updateThread(\n    thread.threadId,\n    users,\n    managers,\n    thread.publicMeta,\n    newThreadNameAsPrivateMeta.encodeToByteArray(),\n    thread.version!!,\n    false\n)\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.879Z",
        "size": 1196
      }
    },
    {
      "pageContent": "threadApi.updateThread(\n    thread.threadId,\n    users,\n    managers,\n    thread.publicMeta,\n    newThreadNameAsPrivateMeta.encodeToByteArray(),\n    thread.version!!,\n    false\n)\n```\n</Tab>\n\n<Tab value=\"Removing User\">\nTo remove a user from a Thread you must provide:\n- list of all the users, without the user you want to remove\n- list of managers\n- new private and public meta (even if it didn't change)\n- Thread's current version\n- `true` if update action should be forced\n\n```kotlin\nval threadID = \"THREAD_ID\"\nval thread: Thread = threadApi.getThread(threadID)\nval userToRemove = \"USER_ID_TO_REMOVE\"\nval newUsers = thread\n    .users\n    .filter {\n        it != userToRemove\n    }.map { userId ->\n        //Your application must provide a way,\n        //to get user's public key from their userId.\n        UserWithPubKey(\n            userId,\n            \"USER_PUBLIC_KEY\"\n        )\n    }\nval managers = thread\n    .managers\n    .map { userId ->\n        //Your application must provide a way,\n        //to get user's public key from their userId.\n        UserWithPubKey(\n            userId,\n            \"USER_PUBLIC_KEY\"\n        )\n    }",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/kotlin/threads.mdx",
        "type": "mdx",
        "chunkIndex": 8,
        "codeBlocks": [
          "```\n</Tab>\n\n<Tab value=\"Removing User\">\nTo remove a user from a Thread you must provide:\n- list of all the users, without the user you want to remove\n- list of managers\n- new private and public meta (even if it didn't change)\n- Thread's current version\n- `true` if update action should be forced\n\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.879Z",
        "size": 1137
      }
    },
    {
      "pageContent": "threadApi.updateThread(\n    thread.threadId,\n    newUsers,\n    managers,\n    thread.publicMeta,\n    thread.privateMeta,\n    thread.version!!,\n    false\n)\n```\n</Tab>\n\n<Tab value=\"Deleting Thread\">\nThe snippet below deletes Thread and all its data. This action is irreversible.\n```kotlin\nval threadId = \"THREAD_ID\"\nthreadApi.deleteThread(threadId)\n```\n</Tab>\n\n</Tabs>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/kotlin/threads.mdx",
        "type": "mdx",
        "chunkIndex": 9,
        "codeBlocks": [
          "```\n</Tab>\n\n<Tab value=\"Deleting Thread\">\nThe snippet below deletes Thread and all its data. This action is irreversible.\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.879Z",
        "size": 365
      }
    },
    {
      "pageContent": "---\ntitle: Hosting Assets\n---\n\n# Hosting PrivMX Web Endpoint Assets\n\nTo ensure the proper functionality and security of our library, it is essential to configure your server with specific HTTP headers on **the page containing the scripts** and **the scripts themselves** (e.g., those located in `public/privmx-assets/`).\n\nSet the following headers:\n\n- `Cross-Origin-Embedder-Policy: require-corp`\n- `Cross-Origin-Opener-Policy: same-origin`\n\nThese headers are crucial for maintaining a secure execution environment, as they help prevent potential cross-origin attacks and ensure that resources are only shared with origins that comply with the same security policies. Implementing these headers will enable seamless integration and optimal performance of our library in your application.",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/application-server.mdx",
        "type": "mdx",
        "chunkIndex": 0,
        "headers": [
          "Hosting PrivMX Web Endpoint Assets"
        ],
        "title": "Hosting PrivMX Web Endpoint Assets",
        "lastModified": "2025-06-05T19:33:57.880Z",
        "size": 787
      }
    },
    {
      "pageContent": "### Setting Up Headers in Different Environments\n\n<Tabs items={[\"Vite\",\"Next.js\",\"Express\",\"Nginx\",\"Apache\",\"Webpack\"]}>\n<Tab>\n\n#### Vite\n\nTo configure these headers in a Vite project for specific routes (such as the page containing the scripts and the scripts themselves), you need to set up a middleware in the Vite configuration file:\n\n```js\n// vite.config.js\nimport { defineConfig } from \"vite\";\n\nexport default defineConfig({\n  plugins: [\n    {\n      name: 'configure-response-headers',\n      configureServer: server => {\n        server.middlewares.use((req, res, next) => {\n          // Apply headers only to relevant paths\n          if (req.url.startsWith('/privmx-assets') || req.url === '/YOUR_SUBPAGE') {\n            res.setHeader('Cross-Origin-Embedder-Policy', 'require-corp');\n            res.setHeader('Cross-Origin-Opener-Policy', 'same-origin');\n          }\n          next();\n        });\n      },\n    },\n  ],\n});\n\n```\n\n</Tab>\n<Tab>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/application-server.mdx",
        "type": "mdx",
        "chunkIndex": 1,
        "headers": [
          "Setting Up Headers in Different Environments",
          "Vite"
        ],
        "title": "Setting Up Headers in Different Environments",
        "codeBlocks": [
          "```js\n// vite.config.js\nimport { defineConfig } from \"vite\";\n\nexport default defineConfig({\n  plugins: [\n    {\n      name: 'configure-response-headers',\n      configureServer: server => {\n        server.middlewares.use((req, res, next) => {\n          // Apply headers only to relevant paths\n          if (req.url.startsWith('/privmx-assets') || req.url === '/YOUR_SUBPAGE') {\n            res.setHeader('Cross-Origin-Embedder-Policy', 'require-corp');\n            res.setHeader('Cross-Origin-Opener-Policy', 'same-origin');\n          }\n          next();\n        });\n      },\n    },\n  ],\n});\n\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.880Z",
        "size": 947
      }
    },
    {
      "pageContent": "#### Next.js\nIn a Next.js project, you can set these headers specifically for the page containing the scripts and the script files (e.g., public/privmx-assets/) in the next.config.js file:\n```js\n// next.config.mjs\nconst nextConfig = {\n  // ..rest of the configuration\n  headers: async () => {\n    return [\n      {\n        source: '/your-page', // Page containing the scripts\n        headers: [\n          {\n            key: 'Cross-Origin-Embedder-Policy',\n            value: 'require-corp',\n          },\n          {\n            key: 'Cross-Origin-Opener-Policy',\n            value: 'same-origin',\n          },\n        ],\n      },\n      {\n        source: '/privmx-assets/(.*)', // Script files\n        headers: [\n          {\n            key: 'Cross-Origin-Embedder-Policy',\n            value: 'require-corp',\n          },\n          {\n            key: 'Cross-Origin-Opener-Policy',\n            value: 'same-origin',\n          },\n        ],\n      },\n    ];\n  },\n};\n\n\n```\n\n</Tab>\n<Tab>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/application-server.mdx",
        "type": "mdx",
        "chunkIndex": 2,
        "headers": [
          "Next.js"
        ],
        "title": "Next.js",
        "codeBlocks": [
          "```js\n// next.config.mjs\nconst nextConfig = {\n  // ..rest of the configuration\n  headers: async () => {\n    return [\n      {\n        source: '/your-page', // Page containing the scripts\n        headers: [\n          {\n            key: 'Cross-Origin-Embedder-Policy',\n            value: 'require-corp',\n          },\n          {\n            key: 'Cross-Origin-Opener-Policy',\n            value: 'same-origin',\n          },\n        ],\n      },\n      {\n        source: '/privmx-assets/(.*)', // Script files\n        headers: [\n          {\n            key: 'Cross-Origin-Embedder-Policy',\n            value: 'require-corp',\n          },\n          {\n            key: 'Cross-Origin-Opener-Policy',\n            value: 'same-origin',\n          },\n        ],\n      },\n    ];\n  },\n};\n\n\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.880Z",
        "size": 980
      }
    },
    {
      "pageContent": "#### Express\nFor an Express.js server, you can set these headers in your middleware:\n\n```js\nconst express = require('express');\nconst app = express();\n\napp.use('/privmx-assets', (req, res, next) => {\n  res.setHeader('Cross-Origin-Embedder-Policy', 'require-corp');\n  res.setHeader('Cross-Origin-Opener-Policy', 'same-origin');\n  next();\n});\n\napp.use('/your-page', (req, res, next) => {\n  res.setHeader('Cross-Origin-Embedder-Policy', 'require-corp');\n  res.setHeader('Cross-Origin-Opener-Policy', 'same-origin');\n  next();\n});\n\n// your other middleware and routes\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});\n\n```\n\n</Tab>\n<Tab>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/application-server.mdx",
        "type": "mdx",
        "chunkIndex": 3,
        "headers": [
          "Express"
        ],
        "title": "Express",
        "codeBlocks": [
          "```js\nconst express = require('express');\nconst app = express();\n\napp.use('/privmx-assets', (req, res, next) => {\n  res.setHeader('Cross-Origin-Embedder-Policy', 'require-corp');\n  res.setHeader('Cross-Origin-Opener-Policy', 'same-origin');\n  next();\n});\n\napp.use('/your-page', (req, res, next) => {\n  res.setHeader('Cross-Origin-Embedder-Policy', 'require-corp');\n  res.setHeader('Cross-Origin-Opener-Policy', 'same-origin');\n  next();\n});\n\n// your other middleware and routes\n\napp.listen(3000, () => {\n  console.log('Server is running on port 3000');\n});\n\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.880Z",
        "size": 661
      }
    },
    {
      "pageContent": "#### Nginx\nTo set these headers only for the page containing the scripts and the script files, you need to modify your Nginx configuration file:\n```\n# /etc/nginx/nginx.conf or /etc/nginx/sites-available/your-site\nserver {\n  listen 80;\n  server_name your-site.com;\n\n  location /your-page {\n    add_header Cross-Origin-Embedder-Policy require-corp;\n    add_header Cross-Origin-Opener-Policy same-origin;\n  }\n\n  location /privmx-assets/ {\n    add_header Cross-Origin-Embedder-Policy require-corp;\n    add_header Cross-Origin-Opener-Policy same-origin;\n  }\n}\n\n\n```\n\n</Tab>\n<Tab>\n#### Apache\nTo configure these headers only for the page containing the scripts and the script files, add the following directives to your .htaccess file or your site's configuration file:\n\n```\n# .htaccess or httpd.conf\n<IfModule mod_headers.c>\n  <FilesMatch \"^/your-page$\">\n    Header set Cross-Origin-Embedder-Policy \"require-corp\"\n    Header set Cross-Origin-Opener-Policy \"same-origin\"\n  </FilesMatch>\n\n  <Directory \"public/privmx-assets/\">\n    Header set Cross-Origin-Embedder-Policy \"require-corp\"\n    Header set Cross-Origin-Opener-Policy \"same-origin\"\n  </Directory>\n</IfModule>\n```\n</Tab>\n\n<Tab>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/application-server.mdx",
        "type": "mdx",
        "chunkIndex": 4,
        "headers": [
          "Nginx",
          "/etc/nginx/nginx.conf or /etc/nginx/sites-available/your-site",
          "Apache",
          ".htaccess or httpd.conf"
        ],
        "title": "Nginx",
        "codeBlocks": [
          "```\n# /etc/nginx/nginx.conf or /etc/nginx/sites-available/your-site\nserver {\n  listen 80;\n  server_name your-site.com;\n\n  location /your-page {\n    add_header Cross-Origin-Embedder-Policy require-corp;\n    add_header Cross-Origin-Opener-Policy same-origin;\n  }\n\n  location /privmx-assets/ {\n    add_header Cross-Origin-Embedder-Policy require-corp;\n    add_header Cross-Origin-Opener-Policy same-origin;\n  }\n}\n\n\n```",
          "```\n# .htaccess or httpd.conf\n<IfModule mod_headers.c>\n  <FilesMatch \"^/your-page$\">\n    Header set Cross-Origin-Embedder-Policy \"require-corp\"\n    Header set Cross-Origin-Opener-Policy \"same-origin\"\n  </FilesMatch>\n\n  <Directory \"public/privmx-assets/\">\n    Header set Cross-Origin-Embedder-Policy \"require-corp\"\n    Header set Cross-Origin-Opener-Policy \"same-origin\"\n  </Directory>\n</IfModule>\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.880Z",
        "size": 1179
      }
    },
    {
      "pageContent": "#### Webpack Dev Server\n\nBelow you will find an example configuration file for Webpack with a fully setup Webpack's Development Server:\n\n```js\n// webpack.config.cjs\nconst path = require('path');\nconst webpack = require('webpack');\nconst HtmlWebpackPlugin = require(\"html-webpack-plugin\");\nconst host = process.env.HOST || 'localhost';\nmodule.exports = {\n  devServer: {\n    static: [{\n      directory: path.join(__dirname, 'public'),\n      publicPath: '/public'\n    }],\n    compress: true,\n    liveReload: false,\n    host,\n    port: 4001,\n    headers: {\n      \"Cross-Origin-Embedder-Policy\": \"require-corp\",\n      \"Cross-Origin-Opener-Policy\": \"same-origin\",\n\n      \"Access-Control-Allow-Origin\": \"*\",\n      \"Access-Control-Allow-Methods\": \"GET, POST, PUT, DELETE, PATCH, OPTIONS\",\n      \"Access-Control-Allow-Headers\": \"X-Requested-With, content-type, Authorization\"\n    }\n  }\n};\n\n```\n\n</Tab>\n</Tabs>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/application-server.mdx",
        "type": "mdx",
        "chunkIndex": 5,
        "headers": [
          "Webpack Dev Server"
        ],
        "title": "Webpack Dev Server",
        "codeBlocks": [
          "```js\n// webpack.config.cjs\nconst path = require('path');\nconst webpack = require('webpack');\nconst HtmlWebpackPlugin = require(\"html-webpack-plugin\");\nconst host = process.env.HOST || 'localhost';\nmodule.exports = {\n  devServer: {\n    static: [{\n      directory: path.join(__dirname, 'public'),\n      publicPath: '/public'\n    }],\n    compress: true,\n    liveReload: false,\n    host,\n    port: 4001,\n    headers: {\n      \"Cross-Origin-Embedder-Policy\": \"require-corp\",\n      \"Cross-Origin-Opener-Policy\": \"same-origin\",\n\n      \"Access-Control-Allow-Origin\": \"*\",\n      \"Access-Control-Allow-Methods\": \"GET, POST, PUT, DELETE, PATCH, OPTIONS\",\n      \"Access-Control-Allow-Headers\": \"X-Requested-With, content-type, Authorization\"\n    }\n  }\n};\n\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.880Z",
        "size": 900
      }
    },
    {
      "pageContent": "---\ntitle: Entries\n---\n\n\nAll the data sent by someone to an Inbox is called an Entry.\nIn Threads and Stores, a user must be assigned to the container to send data. In Inboxes, however, \nanyone who has Inbox ID can send a reply (assuming they have the Bridge URL and Solution ID).\n\n:::info\n\nThe sample code on this page is based on the same **[assumptions](./first-app#initial-assumptions)**\n\n:::",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/entries.mdx",
        "type": "mdx",
        "chunkIndex": 0,
        "lastModified": "2025-06-05T19:33:57.880Z",
        "size": 395
      }
    },
    {
      "pageContent": "## Accessing via Public API\n\nEndpoint provides different ways to connect to a Bridge instance.\n\nWhen using \"public\" connection you don't have to pass a private key. A random private key will be generated for each connection.\n**The public connection provides only the methods related to sending Inbox entries and retrieving public metadata** related to the Inbox.\n\n### Public Connection\n\nTo submit data as unregistered user you have to connect using connectPublic(...) and then - prepare and send an Entry.\n```ts\nconst publicConnection = await Endpoint.connectPublic(\n    \"SOLUTION_ID\",\n    \"BRIDGE_URL\"\n);\n```\n\nYou have to pass required Bridge URL and Solution ID. Then use an `inboxApi`.",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/entries.mdx",
        "type": "mdx",
        "chunkIndex": 1,
        "headers": [
          "Accessing via Public API",
          "Public Connection"
        ],
        "title": "Accessing via Public API",
        "codeBlocks": [
          "```ts\nconst publicConnection = await Endpoint.connectPublic(\n    \"SOLUTION_ID\",\n    \"BRIDGE_URL\"\n);\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.880Z",
        "size": 688
      }
    },
    {
      "pageContent": "### Submitting Entries\n\n<Tabs groupId=\"variant\" items={[\"Prepare Entry\",\"With meta\",\"With Files\"]}>\n<Tab>\n\n```ts\nconst inboxHandle = await inboxApi.prepareEntry(\n    \"INBOX_ID\",\n    serializeObject(\"text to send\"),\n    [], // no files this time\n    undefined  // if logged with private connection, use user private key here.\n);\n\nawait inboxApi.sendEntry(\n    inboxHandle\n);\n```\n</Tab>\n<Tab>\n\n```ts\nconst dataToSend = serializeObject({\n        type: 'General inquiry',\n        answer: 'Example answer'\n    })\n\nconst inboxHandle = await inboxApi.prepareEntry(\n    \"INBOX_ID\",\n    dataToSend,\n    [], // no files this time\n    undefined  // if logged with private connection, use user private key here.\n);\n\nawait inboxApi.sendEntry(inboxHandle);\n```\n</Tab>\n\n<Tab>\nInboxes allow you to attach files when sending a reply. Each file is automatically streamed during submission.\nSimilar to Stores, the files can contain private/public metadata.\n\nFile info is located inside Entries:\n```ts\nconst dataToSend = serializeObject({\n    type: 'General inquiry',\n    answer: 'Example answer'\n})",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/entries.mdx",
        "type": "mdx",
        "chunkIndex": 2,
        "headers": [
          "Submitting Entries"
        ],
        "title": "Submitting Entries",
        "codeBlocks": [
          "```ts\nconst inboxHandle = await inboxApi.prepareEntry(\n    \"INBOX_ID\",\n    serializeObject(\"text to send\"),\n    [], // no files this time\n    undefined  // if logged with private connection, use user private key here.\n);\n\nawait inboxApi.sendEntry(\n    inboxHandle\n);\n```",
          "```ts\nconst dataToSend = serializeObject({\n        type: 'General inquiry',\n        answer: 'Example answer'\n    })\n\nconst inboxHandle = await inboxApi.prepareEntry(\n    \"INBOX_ID\",\n    dataToSend,\n    [], // no files this time\n    undefined  // if logged with private connection, use user private key here.\n);\n\nawait inboxApi.sendEntry(inboxHandle);\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.880Z",
        "size": 1079
      }
    },
    {
      "pageContent": "File info is located inside Entries:\n```ts\nconst dataToSend = serializeObject({\n    type: 'General inquiry',\n    answer: 'Example answer'\n})\n\nconst fileHandle = await inboxApi.createFileHandle(\n    serializeObject(\"File publicMeta\"),\n    serializeObject(\"File privateMeta\"),\n    fileSize\n);\n\nconst inboxHandle = await inboxApi.prepareEntry(\n    \"INBOX_ID\",\n    dataToSend,\n    [fileHandle], // one file this time\n    undefined  // if logged with private connection, use user private key here.\n);\n\nawait inboxApi.writeToFile(\n    inboxHandle,\n    fileHandle,\n    byteArray\n);\n// repeat in a loop if needed\n\nawait inboxApi.sendEntry(inboxHandle);\n```\n</Tab>\n</Tabs>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/entries.mdx",
        "type": "mdx",
        "chunkIndex": 3,
        "codeBlocks": [
          "```ts\nconst dataToSend = serializeObject({\n    type: 'General inquiry',\n    answer: 'Example answer'\n})\n\nconst fileHandle = await inboxApi.createFileHandle(\n    serializeObject(\"File publicMeta\"),\n    serializeObject(\"File privateMeta\"),\n    fileSize\n);\n\nconst inboxHandle = await inboxApi.prepareEntry(\n    \"INBOX_ID\",\n    dataToSend,\n    [fileHandle], // one file this time\n    undefined  // if logged with private connection, use user private key here.\n);\n\nawait inboxApi.writeToFile(\n    inboxHandle,\n    fileHandle,\n    byteArray\n);\n// repeat in a loop if needed\n\nawait inboxApi.sendEntry(inboxHandle);\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.880Z",
        "size": 663
      }
    },
    {
      "pageContent": "## Fetching Entries\n\nFetching entries requires a secure private connection.\n\n<Tabs groupId={'variant'} items={[\"Fetching entries\",\"Oldest\",\"With Meta\"]}>\n<Tab>\nFetching the most recent Entries submitted to Inbox:\n\n```js\nconst defaultListQuery = {skip:0, limit: 100, sortOrder: \"desc\"};\nconst entries = await inboxApi.listEntries(\n    \"INBOX_ID\",\n    defaultListQuery\n);",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/entries.mdx",
        "type": "mdx",
        "chunkIndex": 4,
        "headers": [
          "Fetching Entries"
        ],
        "title": "Fetching Entries",
        "lastModified": "2025-06-05T19:33:57.880Z",
        "size": 369
      }
    },
    {
      "pageContent": "```\n\n</Tab>\n<Tab >\nFetching the oldest Entries (by submission date) in given Inbox:\n\n```js\nconst defaultListQuery = {skip:0, limit: 100, sortOrder: \"asc\"};\nconst entries = await inboxApi.listEntries(\n    \"INBOX_ID\",\n    defaultListQuery\n);\n```\n</Tab>\n<Tab >\nEntries contain list of submitted files.\nEach file can contain additional metadata useful for providing info about them, for e.g: file name, size, or author.\n\n```js\nconst defaultListQuery = {skip:0, limit: 100, sortOrder: \"desc\"};\nconst entries = await inboxApi.listEntries(\n    \"INBOX_ID\",\n    defaultListQuery\n);\n\nconst deserializedEntries = entries.readItems.map(entry => {\n    return {\n        ...entry,\n        privateMeta: deserializeObject(entry.privateMeta),\n        data: deserializeObject(entry.data),\n        files: entry.files.map(file => ({\n            ...file,\n            privateMeta: deserializeObject(file.privateMeta)\n        }))\n    };\n});\n```\n</Tab>\n\n</Tabs>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/entries.mdx",
        "type": "mdx",
        "chunkIndex": 5,
        "codeBlocks": [
          "```\n\n</Tab>\n<Tab >\nFetching the oldest Entries (by submission date) in given Inbox:\n\n```",
          "```\n</Tab>\n<Tab >\nEntries contain list of submitted files.\nEach file can contain additional metadata useful for providing info about them, for e.g: file name, size, or author.\n\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.880Z",
        "size": 936
      }
    },
    {
      "pageContent": "---\ntitle: Events\ndescription: Events allow your application to dynamically respond to changes in user context instantly. These events are automatically captured when relevant changes occur. You can subscribe to them by registering event listeners.\n---\n\n## Key Considerations\n\nPlease note the following:\n\n- Events will only trigger for active connections.\n- Events are not captured unless explicitly listened for.\n- A single instance of the `eventQueue` is shared across all connections.",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/events.mdx",
        "type": "mdx",
        "chunkIndex": 0,
        "headers": [
          "Key Considerations"
        ],
        "title": "Key Considerations",
        "lastModified": "2025-06-05T19:33:57.880Z",
        "size": 487
      }
    },
    {
      "pageContent": "## Quick Start Guide\n\n<div className={'fd-steps'}>\n    <div className={'fd-step'}>\n\n        ### Start listening in the loop with `listenForEvents`. \\\n        The function `EventQueue.waitEvent` returns a event when one is captured.\n\n        ```js\n        const eventQueue = await EndpointFactory.getEventQueue();\n        function listenForEvents(eventsQueue) { // [!code highlight]\n        eventsQueue.waitEvent().then(event => {\n            console.log(\"onEvent\", event);\n            listenForEvents(eventsQueue);\n        });\n    }\n        listenForEvents(eventQueue);\n        ```\n    </div>\n    <div className={'fd-step'}>\n        ### Subscribe to Tool (e.g. Thread) events:\n\n        ```js\n        await threadApi.subscribeForMessageEvents(threadID);\n        ```\n    </div>\n    <div className={'fd-step'}>\n        ### Unsubscribe, if events no longer needed:\n\n\n        ```js\n        await threadApi.unsubscribeFromMessageEvents(threadID);\n        ```\n    </div>\n</div>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/events.mdx",
        "type": "mdx",
        "chunkIndex": 1,
        "headers": [
          "Quick Start Guide"
        ],
        "title": "Quick Start Guide",
        "codeBlocks": [
          "```js\n        const eventQueue = await EndpointFactory.getEventQueue();\n        function listenForEvents(eventsQueue) { // [!code highlight]\n        eventsQueue.waitEvent().then(event => {\n            console.log(\"onEvent\", event);\n            listenForEvents(eventsQueue);\n        });\n    }\n        listenForEvents(eventQueue);\n        ```",
          "```js\n        await threadApi.subscribeForMessageEvents(threadID);\n        ```",
          "```js\n        await threadApi.unsubscribeFromMessageEvents(threadID);\n        ```"
        ],
        "lastModified": "2025-06-05T19:33:57.880Z",
        "size": 970
      }
    },
    {
      "pageContent": "---\ntitle: Files\ndescription: Uploading and managing files.\n---\n\n\n\n:::info\n\nThe sample code on this page is based on the same **[assumptions](./first-app#initial-assumptions)**\n\n:::",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/files.mdx",
        "type": "mdx",
        "chunkIndex": 0,
        "lastModified": "2025-06-05T19:33:57.881Z",
        "size": 181
      }
    },
    {
      "pageContent": "## Managing Files\n\n<Tabs items={[\"Uploading a simple file\",\"Reading a file\",\"List of Files\"]}>\n\n<Tab >\nCreating files in Stores with additional metadata:\n\n```js\n// for example, let's put some extra file info in the file's private meta\nconst sampleFileInfo = {\n    name: file.name,\n    mimetype: file.type\n};\n\nconst sampleFileData = serializeObject(\"sample file data\");\n\nconst fileHandle = await storesApi.createFile(storeId,\n    serializeObject(\"file's public meta-data\"),\n    serializeObject(sampleFileInfo),\n    sampleFileData.length\n);\n\nawait storesApi.writeToFile(fileHandle, sampleFileData);\nconst fileId = await storesApi.closeFile(fileHandle);\n```\nA detailed code sample of how to upload (stream) a large file can be found [here](../start/stores/uploading-files).\n</Tab>\n\n<Tab >\n\n```js\n// read file contents of the file added to the Store\nconst fileInfo = await storesApi.getFile(fileId);\n\nconst fileHandle = await storesApi.openFile(fileId);\nconst data = await storesApi.readFromFile(fileHandle, fileInfo.size);\nawait storesApi.closeFile(fileHandle);",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/files.mdx",
        "type": "mdx",
        "chunkIndex": 1,
        "headers": [
          "Managing Files"
        ],
        "title": "Managing Files",
        "codeBlocks": [
          "```js\n// for example, let's put some extra file info in the file's private meta\nconst sampleFileInfo = {\n    name: file.name,\n    mimetype: file.type\n};\n\nconst sampleFileData = serializeObject(\"sample file data\");\n\nconst fileHandle = await storesApi.createFile(storeId,\n    serializeObject(\"file's public meta-data\"),\n    serializeObject(sampleFileInfo),\n    sampleFileData.length\n);\n\nawait storesApi.writeToFile(fileHandle, sampleFileData);\nconst fileId = await storesApi.closeFile(fileHandle);\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.881Z",
        "size": 1058
      }
    },
    {
      "pageContent": "const fileHandle = await storesApi.openFile(fileId);\nconst data = await storesApi.readFromFile(fileHandle, fileInfo.size);\nawait storesApi.closeFile(fileHandle);\n\nconsole.log(\"File meta\\n public: \", deserializeObject(fileInfo.publicMeta));\nconsole.log(\"private: \", deserializeObject(fileInfo.privateMeta));\nconsole.log(\"data: \", deserializeObject(data));\n```\n</Tab>\n\n<Tab >\nListing files in a chosen Store:\n\n```js\nconst defaultListQuery = {skip: 0, limit: 100, sortOrder: \"desc\"};\n\nconst filesList = await storeApi.listStores(\n    storeId,\n    defaultListQuery\n);\n```\nAs a result you will receive an object:\n```js\n// filesList:\n{\n    readItems: [<fileObject1>, <fileObject2>,..., <fileObjectN>],\n    totalAvailable: <number_of_all_files_in_the_Store>\n}\n```\nA detailed description of the `File` object fields can be found [here](/reference/js/webendpoint/api-reference/types#file).\n\n</Tab>\n</Tabs>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/files.mdx",
        "type": "mdx",
        "chunkIndex": 2,
        "codeBlocks": [
          "```\n</Tab>\n\n<Tab >\nListing files in a chosen Store:\n\n```",
          "```\nAs a result you will receive an object:\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.881Z",
        "size": 896
      }
    },
    {
      "pageContent": "## Modifying Files\n\n<Tabs items={[\"Updating info about File\",\"Deleting a File\"]}>\n<Tab >\n```js\n// Example: let's update given file's private meta to reflect the file's name change.\nconst currentFile =  storeApi.getFile(fileId);\n\nconst currentFilePrivateMeta = deserializeObject(currentFile.privateMeta);\n\nconst newFilePrivateMeta = {\n    name: \"newFileName\"\n};\nawait storeApi.updateFile(\n    fileId,\n    currentFile.publicMeta,\n    serializeObject(newFilePrivateMeta),\n    currentFile.fileSize\n);\n```\n</Tab>\n\n<Tab >\n```js\nawait storeApi.deleteFile(fileId);\n```\n</Tab>\n</Tabs>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/files.mdx",
        "type": "mdx",
        "chunkIndex": 3,
        "headers": [
          "Modifying Files"
        ],
        "title": "Modifying Files",
        "codeBlocks": [
          "```js\n// Example: let's update given file's private meta to reflect the file's name change.\nconst currentFile =  storeApi.getFile(fileId);\n\nconst currentFilePrivateMeta = deserializeObject(currentFile.privateMeta);\n\nconst newFilePrivateMeta = {\n    name: \"newFileName\"\n};\nawait storeApi.updateFile(\n    fileId,\n    currentFile.publicMeta,\n    serializeObject(newFilePrivateMeta),\n    currentFile.fileSize\n);\n```",
          "```js\nawait storeApi.deleteFile(fileId);\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.881Z",
        "size": 575
      }
    },
    {
      "pageContent": "---\ntitle: First app\n---\n\nA step-by-step tutorial that will guide you through creating your first app using JavaScript WebEndpoint with PrivMX Bridge.\n\n### PrivMX Bridge\nTo proceed with this tutorial, you should already have your Bridge Server up and running. If not, you can find step-by-step instructions on [quick start](../start/quick-start) page.\n\n### Helpers\nMost of the Endpoint's methods (for example creating or updating containers like Threads, Stores, etc.) require some data to be passed as a buffer. In JavaScript that buffer is represented as `Uint8Array`.\n\nA common way to serialize JS objects is to serialize them to a JSON string using `JSON.stringify`. Next, in order to encode strings you can use\n`TextEncoder`. Because it's so common, in our examples we will use helper functions to do these conversions underneath.\n\n```js\nfunction strToUInt8(text) {\n   return (new TextEncoder()).encode(text);\n}\n\nfunction uInt8ToStr(arr) {\n   return (new TextDecoder()).decode(arr);\n}\n\nfunction deserializeObject(binary){\n   return JSON.parse(uInt8ToStr(binary));\n}\n\nfunction serializeObject(object) {\n   return strToUInt8(JSON.stringify(object));\n}\n```",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/first-app.mdx",
        "type": "mdx",
        "chunkIndex": 0,
        "headers": [
          "PrivMX Bridge",
          "Helpers"
        ],
        "title": "PrivMX Bridge",
        "codeBlocks": [
          "```js\nfunction strToUInt8(text) {\n   return (new TextEncoder()).encode(text);\n}\n\nfunction uInt8ToStr(arr) {\n   return (new TextDecoder()).decode(arr);\n}\n\nfunction deserializeObject(binary){\n   return JSON.parse(uInt8ToStr(binary));\n}\n\nfunction serializeObject(object) {\n   return strToUInt8(JSON.stringify(object));\n}\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.881Z",
        "size": 1158
      }
    },
    {
      "pageContent": "## Initial Assumptions\n\nAll the values below like `BRIDGE_URL`, `SOLUTION_ID`, `CONTEXT_ID`\nshould be replaced by the ones corresponding to your PrivMX Bridge instance.\n\nThe private keys here are for demonstration purposes only.\nNormally, they should be kept separately by each user and stored in a safe place,\nor generated from a password (see the `derivePrivateKey()` method in the Crypto API)\n\nThe initial assumptions for all the code examples below are as follows:\n```js\nconst BRIDGE_URL = \"http://localhost:9111\";\nconst SOLUTION_ID = \"YOUR_SOLUTION_ID\";\nconst CONTEXT_ID = \"YOUR_CONTEXT_ID\";\n\nconst USER1_ID = \"user_1\";\nconst USER1_PUBLIC_KEY = \"PUBLIC_KEY_1\";\nconst USER1_PRIV = \"PRIVATE_KEY_1\";\n\nconst USER2_ID = \"user_2\";\nconst USER2_PUBLIC_KEY = \"PUBLIC_KEY_2\";\n\nconst USER3_ID = \"user_3\";\nconst USER3_PUBLIC_KEY = \"PUBLIC_KEY_3\";\n\n// Initialize Endpoint and its Wasm assets\nawait Endpoint.setup(\"/public\");\n```",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/first-app.mdx",
        "type": "mdx",
        "chunkIndex": 1,
        "headers": [
          "Initial Assumptions"
        ],
        "title": "Initial Assumptions",
        "codeBlocks": [
          "```js\nconst BRIDGE_URL = \"http://localhost:9111\";\nconst SOLUTION_ID = \"YOUR_SOLUTION_ID\";\nconst CONTEXT_ID = \"YOUR_CONTEXT_ID\";\n\nconst USER1_ID = \"user_1\";\nconst USER1_PUBLIC_KEY = \"PUBLIC_KEY_1\";\nconst USER1_PRIV = \"PRIVATE_KEY_1\";\n\nconst USER2_ID = \"user_2\";\nconst USER2_PUBLIC_KEY = \"PUBLIC_KEY_2\";\n\nconst USER3_ID = \"user_3\";\nconst USER3_PUBLIC_KEY = \"PUBLIC_KEY_3\";\n\n// Initialize Endpoint and its Wasm assets\nawait Endpoint.setup(\"/public\");\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.881Z",
        "size": 920
      }
    },
    {
      "pageContent": "### Basic Serialization Example - JSON\n```ts\nconst dataObject = {\n    content: 'MESSAGE_CONTENT',\n    type: 'text'\n};\n\nconst binaryData = serializeObject(dataObject); // returns data encoded to Uint8Array\nconst deserializedObject = deserializeObject(binaryData); // returns JavaScript object\n```",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/first-app.mdx",
        "type": "mdx",
        "chunkIndex": 2,
        "headers": [
          "Basic Serialization Example - JSON"
        ],
        "title": "Basic Serialization Example - JSON",
        "codeBlocks": [
          "```ts\nconst dataObject = {\n    content: 'MESSAGE_CONTENT',\n    type: 'text'\n};\n\nconst binaryData = serializeObject(dataObject); // returns data encoded to Uint8Array\nconst deserializedObject = deserializeObject(binaryData); // returns JavaScript object\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.881Z",
        "size": 295
      }
    },
    {
      "pageContent": "### Create Client App\nFirst, you have to connect to your Bridge instance using `Endpoint.connect` method. It requires the API keys\ngenerated while initializing your local instance earlier.\n\n```js\nimport {Endpoint} from \"@simplito/privmx-webendpoint\"\n\nconst connection = await Endpoint.connect(USER1_PRIV, SOLUTION_ID, BRIDGE_URL);\nconst threadApi  = await Endpoint.createThreadApi(connection);\n```\nWhen connected, you have access to all SDK methods. This example shows how to create a Thread, send, and download\na message.\n\nTo create a Thread inside the Context, use proper methods. Note that you have to pass user ID - public key\npair to make a list of users and managers.\n\n```js\n//using constants from initial assumptions\nconst exampleUser = {\n     userId: USER1_ID,\n     pubKey: USER1_PUBLIC_KEY,\n};\n\nconst newThreadId = await threadApi.createThread(\n   CONTEXT_ID, \n   [exampleUser], // list of users who will have access to the created Thread\n   [exampleUser], // list of managers of that Thread\n   strToUInt8(\"some public meta-data\"),\n   strToUInt8(\"some private meta-data, such as thread name\")\n);",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/first-app.mdx",
        "type": "mdx",
        "chunkIndex": 3,
        "headers": [
          "Create Client App"
        ],
        "title": "Create Client App",
        "codeBlocks": [
          "```js\nimport {Endpoint} from \"@simplito/privmx-webendpoint\"\n\nconst connection = await Endpoint.connect(USER1_PRIV, SOLUTION_ID, BRIDGE_URL);\nconst threadApi  = await Endpoint.createThreadApi(connection);\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.881Z",
        "size": 1104
      }
    },
    {
      "pageContent": "```\n\nWith the Thread created, you can now send the first message.\n\n```js\nawait threadApi.sendMessage(\n   threadId, \n   strToUInt8(\"some public meta-data\"), \n   strToUInt8(\"some private meta-data\"), \n   strToUInt8(\"some message content\")\n);\n```\n\nTo get a list of messages inside a Thread, use `listMessages` method. Because data inside messages is in `Uint8Array`\nyou have to deserialize it to human-readable string.\n**Endpoint takes care of encrypting your data before sending it to PrivMX Bridge.**\n\n```js\nconst defaultListQuery = {skip: 0, limit: 100, sortOrder: \"desc\"};\nconst messagesList = await threadApi.listMessages(threadId, defaultListQuery);\nconst decodedMessages = messages.readItems.map(x => {\n    return {\n        publicMeta: deserializedObject(x.publicMeta),\n        privateMeta: deserializedObject(x.privateMeta),\n        data: deserializedObject(x.data)\n    }\n})\n\nconsole.log(\"messages\", messages);\nconsole.log(\"messages in human-readable format\", decodedMessages)\n```",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/first-app.mdx",
        "type": "mdx",
        "chunkIndex": 4,
        "codeBlocks": [
          "```\n\nWith the Thread created, you can now send the first message.\n\n```",
          "```\n\nTo get a list of messages inside a Thread, use `listMessages` method. Because data inside messages is in `Uint8Array`\nyou have to deserialize it to human-readable string.\n**Endpoint takes care of encrypting your data before sending it to PrivMX Bridge.**\n\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.881Z",
        "size": 985
      }
    },
    {
      "pageContent": "## Next Steps\n\nWith everything ready to go, now it's time to start using all the capabilities of Endpoint and Bridge.\n\nLearn how to use:\n\n-   [**Threads**](../start/threads/overview) - for exchanging encrypted messages;\n-   [**Stores**](../start/stores/overview) - for saving and sharing encrypted files;\n-   [**Inboxes**](../start/inboxes/overview) - for one way communication with external users.",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/first-app.mdx",
        "type": "mdx",
        "chunkIndex": 5,
        "headers": [
          "Next Steps"
        ],
        "title": "Next Steps",
        "lastModified": "2025-06-05T19:33:57.881Z",
        "size": 398
      }
    },
    {
      "pageContent": "---\ntitle: Handling Events\n---\n\n\n\n\nThe `@simplito/privmx-webendpoint/extra` package provides utilities for efficiently managing event subscriptions. These utilities simplify event handling, ensuring your application remains reactive and responsive.\n\n## EventManager Features\nWith `EventManager`, you can:\n\n- Start an event loop to listen for incoming events.\n- Create scoped event managers for specific Tools (e.g., Threads, Stores, Inboxes, connections).\n- Dynamically subscribe and unsubscribe from events.",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/handling-events.mdx",
        "type": "mdx",
        "chunkIndex": 0,
        "headers": [
          "EventManager Features"
        ],
        "title": "EventManager Features",
        "lastModified": "2025-06-05T19:33:57.882Z",
        "size": 508
      }
    },
    {
      "pageContent": "## Usage Examples\n<Tabs groupId=\"tool\" items={[\"Threads\",\"Stores\",\"Inboxes\",\"Connection\"]}>\n<Tab>\nThe example below demonstrates how to use the `EventManager` for Thread events.\n\n```js\nimport { EventManager } from '@simplito/privmx-webendpoint/extra';\n\n// Get the event queue from the endpoint\nconst eventQueue = await Endpoint.getEventQueue();\n\n// Start the event loop\nconst eventManager = EventManager.startEventLoop({\n    waitEvent: eventQueue.waitEvent\n});\n\n// Create a scoped event manager for thread events\nconst threadEventManager = eventManager.getThreadEventManager(YOUR_THREAD_API);\n\n// Subscribe to the 'threadCreated' event\nconst unsubscribeFromThreadCreated = await threadEventManager.onThreadEvent({\n    event: 'threadCreated',\n    callback: (payload) => {\n        console.log(\"New thread created:\", payload);\n    }\n});\n\n// Subscribe to the 'threadNewMessage' event for a specific thread\nconst unsubscribeFromMessageCreated = await threadEventManager.onMessageEvent(THREAD_ID, {\n    event: 'threadNewMessage',\n    callback: (payload) => {\n        console.log(\"New message in thread:\", payload);\n    }\n});",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/handling-events.mdx",
        "type": "mdx",
        "chunkIndex": 1,
        "headers": [
          "Usage Examples"
        ],
        "title": "Usage Examples",
        "lastModified": "2025-06-05T19:33:57.882Z",
        "size": 1118
      }
    },
    {
      "pageContent": "// Unsubscribe when needed\nawait unsubscribeFromThreadCreated();\nawait unsubscribeFromMessageCreated();\n\n// Stop the event loop when needed\neventManager.stopEventLoop();",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/handling-events.mdx",
        "type": "mdx",
        "chunkIndex": 2,
        "lastModified": "2025-06-05T19:33:57.882Z",
        "size": 169
      }
    },
    {
      "pageContent": "```\n\nFor more information regarding Thread-related events please visit [Threads docs](../start/threads/listening-for-changes).\n</Tab>\n<Tab>\nThe example below demonstrates how to use the `EventManager` for Store events.\n\n```js\nimport { EventManager } from '@simplito/privmx-webendpoint/extra';\n\n// Get the event queue from the endpoint\nconst eventQueue = await Endpoint.getEventQueue();\n\n// Start the event loop\nconst eventManager = EventManager.startEventLoop({\n    waitEvent: eventQueue.waitEvent\n});\n\n// Create a scoped event manager for store events\nconst storeEventManager = eventManager.getStoreEventManager(YOUR_STORE_API);\n\n// Subscribe to the 'storeCreated' event\nconst unsubscribeFromStoreCreated = await storeEventManager.onStoreEvent({\n    event: 'storeCreated',\n    callback: (payload) => {\n        console.log('New store created:', payload);\n    },\n});\n\n// Subscribe to the 'storeFileCreated' event for a specific thread\nconst unsubscribeFromFileCreated = await storeEventManager.onFileEvent(STORE_ID, {\n    event: 'storeFileCreated',\n    callback: (payload) => {\n        console.log('New file in store:', payload);\n    }\n});",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/handling-events.mdx",
        "type": "mdx",
        "chunkIndex": 3,
        "codeBlocks": [
          "```\n\nFor more information regarding Thread-related events please visit [Threads docs](../start/threads/listening-for-changes).\n</Tab>\n<Tab>\nThe example below demonstrates how to use the `EventManager` for Store events.\n\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.882Z",
        "size": 1138
      }
    },
    {
      "pageContent": "// Unsubscribe when needed\nawait unsubscribeFromStoreCreated();\nawait unsubscribeFromFileCreated();\n\n// Stop the event loop when needed\neventManager.stopEventLoop();",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/handling-events.mdx",
        "type": "mdx",
        "chunkIndex": 4,
        "lastModified": "2025-06-05T19:33:57.882Z",
        "size": 165
      }
    },
    {
      "pageContent": "```\n\nFor more information regarding Store-related events please visit [Store docs](./../../stores/using-stores/05-realtime-updating.mdx).\n</Tab>\n\n<Tab>\nThe example below demonstrates how to use the `EventManager` for Inbox events.\n\n\n```js\nimport { EventManager } from '@simplito/privmx-webendpoint/extra';\n\n// Get the event queue from the endpoint\nconst eventQueue = await Endpoint.getEventQueue();\n\n// Start the event loop\nconst eventManager = EventManager.startEventLoop({\n    waitEvent: eventQueue.waitEvent\n});\n\n// Create a scoped event manager for inbox events\nconst inboxEventManager = eventManager.getInboxEventManager(YOUR_INBOX_API);\n\n// Subscribe to the 'inboxCreated' event\nconst unsubscribeFromInboxCreated = await inboxEventManager.onInboxEvent({\n    event: 'inboxCreated',\n    callback: (payload) => {\n        console.log('New inbox created:', payload);\n    },\n});\n\n// Subscribe to the 'storeFileCreated' event for a specific thread\nconst unsubscribeFromEntryCreated = await inboxEventManager.onEntryEvent(INBOX_ID, {\n    event: 'inboxEntryCreated',\n    callback: (payload) => {\n        console.log('New entry in inbox:', payload);\n    },\n});",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/handling-events.mdx",
        "type": "mdx",
        "chunkIndex": 5,
        "codeBlocks": [
          "```\n\nFor more information regarding Store-related events please visit [Store docs](./../../stores/using-stores/05-realtime-updating.mdx).\n</Tab>\n\n<Tab>\nThe example below demonstrates how to use the `EventManager` for Inbox events.\n\n\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.882Z",
        "size": 1156
      }
    },
    {
      "pageContent": "// Unsubscribe when needed\nawait unsubscribeFromInboxCreated();\nawait unsubscribeFromEntryCreated();\n\n// Stop the event loop when needed\neventManager.stopEventLoop();\n```\n</Tab>\n\n<Tab>\nThe example below demonstrates how to use the `EventManager` for connection events.\n\n```js\nimport { EventManager } from '@simplito/privmx-webendpoint/extra';\n\n// Get the event queue from the endpoint\nconst eventQueue = await Endpoint.getEventQueue();\n\n// Start the event loop\nconst eventManager = EventManager.startEventLoop({\n    waitEvent: eventQueue.waitEvent\n});\n\n// Create a scoped event manager for connections events\nconst inboxEventManager = eventManager.getConnectionEventManager(await YOUR_CONNECTION.getConnectionId());\n\n// Subscribe to the 'inboxCreated' event\nconst unsubscribeFromDisconnectedEvent = await inboxEventManager.onConnectionEvent({\n    event: 'libDisconnected',\n    callback: (payload) => {\n        console.log('Disconnected:', payload);\n    },\n});\n\n// Unsubscribe when needed\nawait unsubscribeFromDisconnectedEvent();\n\n// Stop the event loop when needed\neventManager.stopEventLoop();\n```\n</Tab>\n</Tabs>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/handling-events.mdx",
        "type": "mdx",
        "chunkIndex": 6,
        "codeBlocks": [
          "```\n</Tab>\n\n<Tab>\nThe example below demonstrates how to use the `EventManager` for connection events.\n\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.882Z",
        "size": 1114
      }
    },
    {
      "pageContent": "---\ntitle: Overview\n---\n\n\n\nInboxes are a way for users to send encrypted data to your app.\n\nThe advantage of Inboxes is that they don't require the user to be registered in order to send encrypted data.\nThis opens up various possibilities in environments where you need to gather sensitive information from unregistered users (e.g. on your website).\n\nTo learn more about Inboxes, their structure, how they are encrypted, and what are their use cases - read [Inbox Docs](../start/inboxes/overview).\n\n:::info\n\nBefore working with Inboxes, follow our [Getting Started Guide](./introduction). It will show you how to set up your project to work with PrivMX Bridge.\n\nThe sample code on this page is based on the same **[assumptions](./first-app#initial-assumptions)**\n\n:::\n\n## Working with Inboxes\n\nWhen working with Inboxes, you will use the following:\n- `inboxApi` - for methods used to manage Inboxes in given Context\n\n```js\nconst threadApi = await Endpoint.createThreadApi(connection);\nconst storeApi = await Endpoint.createStoreApi(connection);\nconst inboxApi = await Endpoint.createInboxApi(connection, threadApi, storeApi);\n```",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/inboxes.mdx",
        "type": "mdx",
        "chunkIndex": 0,
        "headers": [
          "Working with Inboxes"
        ],
        "title": "Working with Inboxes",
        "codeBlocks": [
          "```js\nconst threadApi = await Endpoint.createThreadApi(connection);\nconst storeApi = await Endpoint.createStoreApi(connection);\nconst inboxApi = await Endpoint.createInboxApi(connection, threadApi, storeApi);\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.882Z",
        "size": 1129
      }
    },
    {
      "pageContent": "## Creating an Inbox\n\n<Tabs groupId=\"variant\" items={[\"Basic\",\"With a structured Private Meta\",\"With Public View\"]}>\n<Tab>\nCreating a basic unnamed Inbox, which can be used if your app needs only one Inbox and you don't need a distinction between them:\n\n```js\nconst users = [{ userId: 'MY_USER', pubKey: 'PUB_KEY' }, { userId: 'MY_USER2', pubKey: 'PUB_KEY2' }];\nconst managers = [{ userId: 'MY_USER', pubKey: 'PUB_KEY' }];\n\n\nconst inboxId = await inboxApi.createInbox(\n    'CONTEXT_ID',\n    users,\n    managers,\n    serializeObject(\"some public-meta\"),\n    serializeObject(\"some private-meta\"),\n    undefined // optional files config\n);\n```\n</Tab>\n     \n<Tab >\n\nYou can assign any data to private and public meta fields (e.g. the name of the Inbox), as long as they are serialized to Uint8Array.\nIn this case, use the `serializeObject` function from the SDK to serialize a JavaScript object into a binary format:\n\n```js\nconst privateMeta = {\n    name: 'Contact Form'\n};\nconst users = [{ userId: 'MY_USER', pubKey: 'PUB_KEY' }, { userId: 'MY_USER2', pubKey: 'PUB_KEY2' }];\nconst managers = [{ userId: 'MY_USER', pubKey: 'PUB_KEY' }];",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/inboxes.mdx",
        "type": "mdx",
        "chunkIndex": 1,
        "headers": [
          "Creating an Inbox"
        ],
        "title": "Creating an Inbox",
        "codeBlocks": [
          "```js\nconst users = [{ userId: 'MY_USER', pubKey: 'PUB_KEY' }, { userId: 'MY_USER2', pubKey: 'PUB_KEY2' }];\nconst managers = [{ userId: 'MY_USER', pubKey: 'PUB_KEY' }];\n\n\nconst inboxId = await inboxApi.createInbox(\n    'CONTEXT_ID',\n    users,\n    managers,\n    serializeObject(\"some public-meta\"),\n    serializeObject(\"some private-meta\"),\n    undefined // optional files config\n);\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.882Z",
        "size": 1132
      }
    },
    {
      "pageContent": "const inboxId = await inboxApi.createInbox(\n    'CONTEXT_ID',\n    users,\n    managers,\n    serializeObject(\"some public-meta\"),\n    serializeObject(privateMeta),\n    undefined // optional files config\n);\n```\n</Tab>\n<Tab>\n\nIn Inboxes, `publicMeta` is exposed as `InboxPublicView`. To get it - call the getInboxPublicView(...) method.\nNote that users don't have to be added to the Inbox to have access to this method - they only need it's ID and they can connect using connectPublic(...) method.\n\nPutting data inside `publicMeta` also gives your own server the ability to access it using [PrivMX Bridge API](https://bridge.privmx.dev/).\n\n```js\nconst users = [{ userId: 'MY_USER', pubKey: 'PUB_KEY' }, { userId: 'MY_USER2', pubKey: 'PUB_KEY2' }];\nconst managers = [{ userId: 'MY_USER', pubKey: 'PUB_KEY' }];\n\nconst privateMeta = {\n    name: 'Album'\n};\n\nconst publicMeta = {\n    formScheme: [\n        { question: 'Your name' },\n        { question: 'E-mail' }\n    ]\n};\n\nconst inboxId = await inboxApi.createInbox(\n    'CONTEXT_ID',\n    users,\n    managers,\n    serializeObject(publicMeta),\n    serializeObject(privateMeta),\n    undefined // optional files config\n);",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/inboxes.mdx",
        "type": "mdx",
        "chunkIndex": 2,
        "codeBlocks": [
          "```\n</Tab>\n<Tab>\n\nIn Inboxes, `publicMeta` is exposed as `InboxPublicView`. To get it - call the getInboxPublicView(...) method.\nNote that users don't have to be added to the Inbox to have access to this method - they only need it's ID and they can connect using connectPublic(...) method.\n\nPutting data inside `publicMeta` also gives your own server the ability to access it using [PrivMX Bridge API](https://bridge.privmx.dev/).\n\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.882Z",
        "size": 1160
      }
    },
    {
      "pageContent": "```\n\n</Tab>\n</Tabs>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/inboxes.mdx",
        "type": "mdx",
        "chunkIndex": 3,
        "lastModified": "2025-06-05T19:33:57.882Z",
        "size": 19
      }
    },
    {
      "pageContent": "## Fetching Inboxes\n\n<Tabs groupId=\"variant\" items={[\"Most Recent\",\"Oldest Inboxes\",\"By Inbox ID\",\"Paging\"]}>\n<Tab >\nFetching the most recent Inboxes in given Context:\n\n```js\nconst defaultListQuery = {skip:0, limit: 100, sortOrder: \"asc\"};\n\nconst inboxList = await inboxApi.listInboxes(\n    \"CONTEXT_ID\",\n    defaultListQuery\n);\n\nconst inboxListwithDeserializedMeta = inboxList.readItems.map(inbox => {\n    return {\n        inbox: inbox,\n        privateMeta: deserializeObject(inbox.privateMeta),\n        publicMeta: deserializeObject(inbox.publicMeta)\n    };\n});\n```\n</Tab>\n\n<Tab>\nFetching the oldest Inboxes (by creation date) in given Context:\n\n```js\nconst defaultListQuery = {skip:0, limit: 100, sortOrder: \"desc\"};\n\nconst inboxList = await inboxApi.listInboxes(\n    \"CONTEXT_ID\",\n    defaultListQuery\n);\n\nconst inboxListwithDeserializedMeta = inboxList.readItems.map(inbox => {\n    return {\n        inbox: inbox,\n        privateMeta: deserializeObject(inbox.privateMeta),\n        publicMeta: deserializeObject(inbox.publicMeta)\n    };\n});\n```\n</Tab>\n\n<Tab>\nYou can get info about an Inbox using its `inboxId`:\n\n```js\nconst inbox = await inboxApi.getInbox(\"INBOX_ID\");",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/inboxes.mdx",
        "type": "mdx",
        "chunkIndex": 4,
        "headers": [
          "Fetching Inboxes"
        ],
        "title": "Fetching Inboxes",
        "codeBlocks": [
          "```js\nconst defaultListQuery = {skip:0, limit: 100, sortOrder: \"asc\"};\n\nconst inboxList = await inboxApi.listInboxes(\n    \"CONTEXT_ID\",\n    defaultListQuery\n);\n\nconst inboxListwithDeserializedMeta = inboxList.readItems.map(inbox => {\n    return {\n        inbox: inbox,\n        privateMeta: deserializeObject(inbox.privateMeta),\n        publicMeta: deserializeObject(inbox.publicMeta)\n    };\n});\n```",
          "```js\nconst defaultListQuery = {skip:0, limit: 100, sortOrder: \"desc\"};\n\nconst inboxList = await inboxApi.listInboxes(\n    \"CONTEXT_ID\",\n    defaultListQuery\n);\n\nconst inboxListwithDeserializedMeta = inboxList.readItems.map(inbox => {\n    return {\n        inbox: inbox,\n        privateMeta: deserializeObject(inbox.privateMeta),\n        publicMeta: deserializeObject(inbox.publicMeta)\n    };\n});\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.882Z",
        "size": 1172
      }
    },
    {
      "pageContent": "<Tab>\nYou can get info about an Inbox using its `inboxId`:\n\n```js\nconst inbox = await inboxApi.getInbox(\"INBOX_ID\");\n\nconst privateMeta = deserializeObject(inbox.privateMeta);\nconst publicMeta = deserializeObject(inbox.publicMeta);\n```\n</Tab>\n\n<Tab>\nYou can change how many items are on a page using `limit` in options object:\n\n```js\nconst defaultListQuery = {skip:50, limit: 20, sortOrder: \"desc\"};\n\nconst inboxList = await inboxApi.listInboxes(\n    \"CONTEXT_ID\",\n    defaultListQuery\n);\n\nconst inboxListwithDeserializedMeta = inboxList.readItems.map(inbox => {\n    return {\n        inbox: inbox,\n        privateMeta: deserializeObject(inbox.privateMeta),\n        publicMeta: deserializeObject(inbox.publicMeta)\n    };\n});",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/inboxes.mdx",
        "type": "mdx",
        "chunkIndex": 5,
        "codeBlocks": [
          "```js\nconst inbox = await inboxApi.getInbox(\"INBOX_ID\");\n\nconst privateMeta = deserializeObject(inbox.privateMeta);\nconst publicMeta = deserializeObject(inbox.publicMeta);\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.882Z",
        "size": 723
      }
    },
    {
      "pageContent": "```\n\n</Tab>\n</Tabs>\n\nRemember that data is transmitted in binary format, so you'll need to parse it back into your desired format.\nYou can use the `deserializeObject` function provided by the SDK for this purpose.",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/inboxes.mdx",
        "type": "mdx",
        "chunkIndex": 6,
        "lastModified": "2025-06-05T19:33:57.882Z",
        "size": 213
      }
    },
    {
      "pageContent": "## Modifying Inboxes\n\n<Tabs items={[\"Renaming Inboxes\",\"Removing Users\",\"Deleting Inbox\"]}>\n<Tab default>\nTo update an Inbox you must always provide its current version, as well as:\n- list of users,\n- list of managers,\n- new private and public meta (even if it didn't change).\n\n``` js\nconst inbox = await inboxApi.getInbox(\n    inboxId    \n);\n\nconst newUsers = inbox.users.map(user => ({\n        //Your application must provide a way,\n        //to get user's public key from their userId.\n        userId: user,\n        pubKey: 'USER_PUBLIC_KEY'\n    })\n);\n\nconst newManagers = newUsers.filter(user =>\n    inbox.managers.find(manager => manager == user.userId));\n\nconst newPrivateMeta = {\n    title: 'New inbox name'\n};\n\nawait inboxApi.updateInbox(\n    inboxId    \n    newUsers,\n    newManagers,\n    inbox.publicMeta,\n    serializeObject(newPrivateMeta),\n    inbox.filesConfig,\n    inbox.version,\n    false, \n    false\n);",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/inboxes.mdx",
        "type": "mdx",
        "chunkIndex": 7,
        "headers": [
          "Modifying Inboxes"
        ],
        "title": "Modifying Inboxes",
        "lastModified": "2025-06-05T19:33:57.882Z",
        "size": 919
      }
    },
    {
      "pageContent": "```\n\n</Tab>\n\n<Tab>\nTo remove a user from an Inbox you must provide:\n- list of all the users, without the user you want to remove;\n- list of managers;\n- Inbox's current version;\n- new private and public meta (even if it didn't change).\n\n``` js   \nconst inbox = await inboxApi.getInbox(inboxId);\n\nconst newUsers = inbox.users\n    .filter(user => user !== userToRemove)\n    .map(user => ({\n        //Your application must provide a way,\n        //to get user's public key from their userId.\n        userId: user,\n        pubKey: 'USER_PUBLIC_KEY'\n    })\n);\n\nconst newManagers = newUsers.filter(user =>\n    inbox.managers.find(manager => manager == user.userId));\n\nconst newPrivateMeta = {\n    title: 'New inbox name'\n};\n\nawait inboxApi.updateInbox(\n    inboxId    \n    newUsers,\n    newManagers,\n    inbox.publicMeta,\n    serializeObject(newPrivateMeta),\n    inbox.filesConfig,\n    inbox.version,\n    false, \n    false\n);\n```\n\n</Tab>\n\n<Tab>\nThe snippet below deletes the Inbox and all its data. This action is irreversible.\n\n```js\nawait inboxApi.deleteInbox(\"INBOX_ID\");\n```\n</Tab>\n</Tabs>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/inboxes.mdx",
        "type": "mdx",
        "chunkIndex": 8,
        "codeBlocks": [
          "```\n\n</Tab>\n\n<Tab>\nTo remove a user from an Inbox you must provide:\n- list of all the users, without the user you want to remove;\n- list of managers;\n- Inbox's current version;\n- new private and public meta (even if it didn't change).\n\n```",
          "```\n\n</Tab>\n\n<Tab>\nThe snippet below deletes the Inbox and all its data. This action is irreversible.\n\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.882Z",
        "size": 1086
      }
    },
    {
      "pageContent": "---\ntitle: Getting Started\n---\n\n## Initial Requirements\n\nTo start developing end-to-end encrypted applications using PrivMX Web Endpoint you need a **PrivMX Bridge** instance, you can find quick start guide [here](../start/quick-start).\n\nTo connect it to your environment, you need:\n  - `Bridge URL` - URL address of the instance of your PrivMX Bridge\n  - `Solution ID` - ID of the Solution provided by PrivMX Bridge during its initialization process\n  - `User Private Key` - the private key from the user's public-private key pair\n\nWhen you develop a project using PrivMX, you will most likely use some kind of application server – a server to manage users (and their keys), Contexts, etc. \nIt can be new or existing, depending on the specific requirements.\n\n## Using Public and Private Keys\nYou need a private key to connect the Endpoint to your Bridge. **Private key will never leave the Endpoint**.\n- PrivMX Endpoint uses the user's private key to encrypt, decrypt and verify data on the client side only.\n- PrivMX Bridge stores only the public part, i.e., the user's public key and user's ID.",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/introduction.mdx",
        "type": "mdx",
        "chunkIndex": 0,
        "headers": [
          "Initial Requirements",
          "Using Public and Private Keys"
        ],
        "title": "Initial Requirements",
        "lastModified": "2025-06-05T19:33:57.883Z",
        "size": 1097
      }
    },
    {
      "pageContent": "## Setting up Web Server to Host JavaScript Assets\n\nTo properly integrate PrivMX Web Endpoint library, it's crucial to configure your server. This will ensure the library functions correctly and maintain security. \nYou need to set up specific HTTP headers: \n- set `Cross-Origin-Embedder-Policy` to `require-corp`;\n- set `Cross-Origin-Opener-Policy` to `same-origin`.\n\nThese headers are essential to prevent potential cross-origin attacks and to maintain a secure execution environment.\n\nFor detailed instructions on how to configure these headers in different environments like Vite, Next.js, Express, and Nginx, \nrefer to our [Server Configuration](./application-server) page.\n\nYou can also take a look at our [example projects](https://github.com/simplito/privmx-webendpoint/tree/main/examples)\nto find server configuration samples.",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/introduction.mdx",
        "type": "mdx",
        "chunkIndex": 1,
        "headers": [
          "Setting up Web Server to Host JavaScript Assets"
        ],
        "title": "Setting up Web Server to Host JavaScript Assets",
        "lastModified": "2025-06-05T19:33:57.883Z",
        "size": 834
      }
    },
    {
      "pageContent": "## Setting up Web Endpoint\n\n:::warning\n\nPrivMX Web Endpoint relies heavily on WebAssembly and browser Web Workers.\nBecause of that, Web Endpoint is not compatible with the Node.js environments used on the server side and is limited to **browsers only**.\nWe are actively working on the `@simplito/privmx-endpoint-node` NPM package to support this kind of usage in the future.\n\n:::\n\nPrivMX Web Endpoint is distributed as an NPM package ([@simplito/privmx-webendpoint](https://www.npmjs.com/package/@simplito/privmx-webendpoint)) that contains\nall the necessary assets and helpers to get started.\n\nFollow these steps to get started:\n\n1. Download the NPM package for your target project by calling: `npm i @simplito/privmx-webendpoint`.\n2. Set up your Web Server to host JavaScript assets properly – [see below](#setting-up-web-server-to-host-javascript-assets).\n3. Copy the Endpoint's assets (all .js and .wasm files from `./node_modules/@simplito/privmx-webendpoint/assets`) to your Web Server's public directory.\n\nFinally, to complete the setup process, you have two ways to import the package to your project:",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/introduction.mdx",
        "type": "mdx",
        "chunkIndex": 2,
        "headers": [
          "Setting up Web Endpoint"
        ],
        "title": "Setting up Web Endpoint",
        "lastModified": "2025-06-05T19:33:57.883Z",
        "size": 1109
      }
    },
    {
      "pageContent": "### Importing NPM Package\n```ts\nimport { Endpoint, EventQueue, Types } from \"@simplito/privmx-webendpoint\";\n```\n\n### Using Bundle\n\nFirst you should copy the `privmx-endpoint-web.js` file (bundle) from the `./node_modules/@simplito/privmx-webendpoint/dist/bundle` directory to your Web Server's public directory.\n\nNext, in your `index.html` add script tag to import the bundle:\n```html\n<!DOCTYPE html>\n<html>\n    <head>\n        <script src=\"<public_dir>/privmx-endpoint-web.js\"></script>\n    </head>\n    <body>\n    </body>\n</html>\n```\nYou can use it in your app in one of the following methods:\n\n- **From global scope**\n    ```js\n    // this/window binding\n    const Endpoint = PrivmxWebEndpoint.Endpoint;\n    // or\n    const Endpoint = window.PrivmxWebEndpoint.Endpoint;\n    ```\n- **CommonJS import**\n   ```js\n   const Endpoint = require(\"privmx-webendpoint\").Endpoint;\n   ```\n- **AMD import**\n   ```js\n   require(['privmx-webendpoint'], function (privmxWebEndpoint) {\n   // Do something with the library...\n   });\n   ```",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/introduction.mdx",
        "type": "mdx",
        "chunkIndex": 3,
        "headers": [
          "Importing NPM Package",
          "Using Bundle"
        ],
        "title": "Importing NPM Package",
        "codeBlocks": [
          "```ts\nimport { Endpoint, EventQueue, Types } from \"@simplito/privmx-webendpoint\";\n```",
          "```html\n<!DOCTYPE html>\n<html>\n    <head>\n        <script src=\"<public_dir>/privmx-endpoint-web.js\"></script>\n    </head>\n    <body>\n    </body>\n</html>\n```",
          "```js\n    // this/window binding\n    const Endpoint = PrivmxWebEndpoint.Endpoint;\n    // or\n    const Endpoint = window.PrivmxWebEndpoint.Endpoint;\n    ```",
          "```js\n   const Endpoint = require(\"privmx-webendpoint\").Endpoint;\n   ```",
          "```js\n   require(['privmx-webendpoint'], function (privmxWebEndpoint) {\n   // Do something with the library...\n   });\n   ```"
        ],
        "lastModified": "2025-06-05T19:33:57.883Z",
        "size": 1021
      }
    },
    {
      "pageContent": "## Web Endpoint's APIs\nYou need your Bridge's instance specific data, mentioned [earlier](#initial-requirements), which you should get during the Bridge's setup process.\n\n```js\nconst  bridgeUrl = \"http://localhost:9111\";\nconst  solutionId = \"SOLUTION_ID\";\n\nconst  userPrivKey = \"USER_PRIVATE_KEY\";\nconst  userPubKey = \"USER_PUBLIC_KEY\";\n```\n\nFirst connect to your PrivMX Bridge instance.\nInitialize the Endpoint and its WebAssembly dependencies\n(provide the Endpoint.setup() function with your Web Server's public directory URL/path\n where the Endpoint assets were copied)\n```js\nawait Endpoint.setup(\"<public_dir>\");\n// Create connection to the Bridge Server\nconst connection = await Endpoint.connect(userPrivKey, solutionId, bridgeUrl);\n// Initialize the Threads API\nconst threadsApi = await Endpoint.createThreadApi(connection);\n// call some API methods\nconst threads = await threadsApi.listThreads(...);\n```",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/introduction.mdx",
        "type": "mdx",
        "chunkIndex": 4,
        "headers": [
          "Web Endpoint's APIs"
        ],
        "title": "Web Endpoint's APIs",
        "codeBlocks": [
          "```js\nconst  bridgeUrl = \"http://localhost:9111\";\nconst  solutionId = \"SOLUTION_ID\";\n\nconst  userPrivKey = \"USER_PRIVATE_KEY\";\nconst  userPubKey = \"USER_PUBLIC_KEY\";\n```",
          "```js\nawait Endpoint.setup(\"<public_dir>\");\n// Create connection to the Bridge Server\nconst connection = await Endpoint.connect(userPrivKey, solutionId, bridgeUrl);\n// Initialize the Threads API\nconst threadsApi = await Endpoint.createThreadApi(connection);\n// call some API methods\nconst threads = await threadsApi.listThreads(...);\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.883Z",
        "size": 910
      }
    },
    {
      "pageContent": "## Next Steps\n\nWith everything ready to go, now it's time to start using all the capabilities of Endpoint and Bridge.\n\nLearn how to use:\n\n-   [**Threads**](../start/threads/overview) - for exchanging encrypted messages;\n-   [**Stores**](../start/stores/overview) - for saving and sharing encrypted files;\n-   [**Inboxes**](../start/inboxes/overview) - for one way communication with external users.",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/introduction.mdx",
        "type": "mdx",
        "chunkIndex": 5,
        "headers": [
          "Next Steps"
        ],
        "title": "Next Steps",
        "lastModified": "2025-06-05T19:33:57.883Z",
        "size": 398
      }
    },
    {
      "pageContent": "---\ntitle: Messages\ndescription: Sending messages in Threads.\n---\n\n\n:::info\n\nThe sample code on this page is based on the same **[assumptions](../js/first-app#initial-assumptions)** mentioned in [First App](../js/first-app).\n\n:::\n\n## Messages Inside Threads\n\nMessages inside Threads are sent in binary format. Before sending a message, you need to decide on the message format and choose\nthe appropriate data serialization method.\n\nFor more information about the Threads architecture and best practices for sending messages, visit the\n[Threads Documentation](../start/threads/overview).\n\n## Serialization of Data\n\nTo send a message you have to use the Endpoint's `sendMessage` method. This method accepts arguments in `Uint8Array`, here are some of\nthe ways you can serialize your JavaScript objects:",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/messages.mdx",
        "type": "mdx",
        "chunkIndex": 0,
        "headers": [
          "Messages Inside Threads",
          "Serialization of Data"
        ],
        "title": "Messages Inside Threads",
        "lastModified": "2025-06-05T19:33:57.883Z",
        "size": 800
      }
    },
    {
      "pageContent": "## Sending Messages\n\n<Tabs groupId=\"variant\" items={[\"basic\",\"markdown\"]}>\n<Tab>\nExample of sending a message in Plain Text:\n\n```ts\nconst message = 'Message text';\n \nconst encoder = new TextEncoder();\n\nawait threadApi.sendMessage(\n    threadId, \n    serializeObject(\"some public meta-data\"), \n    serializeObject(\"some private meta-data\"), \n    serializeObject(message)\n);\n```\n</Tab>\n\n<Tab value='markdown' label='Richtext'>\n\nYour app may require sending messages in more complex formats like Markdown or HTML. Because messages in Threads\ndon't have a specified format, you can take any output from your text editor, serialize, and send it.\n\nThe example below uses `type` field in `publicMeta` to distinguish between different types of messages.\n\n```ts\nconst messageObject = {\n    //output from the chosen WYSIWYG editor\n    //or your own object definition \n};\n\nconst privateMeta = {\n    type: 'markdown'\n};\n\nconst publicMeta = {\n    tag: 'tag'\n};\n\nawait threadApi.sendMessage(\n    threadId, \n    serializeObject(publicMeta), \n    serializeObject(privateMeta),\n    serializeObject(messageObject)\n);\n```\n</Tab>\n</Tabs>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/messages.mdx",
        "type": "mdx",
        "chunkIndex": 1,
        "headers": [
          "Sending Messages"
        ],
        "title": "Sending Messages",
        "codeBlocks": [
          "```ts\nconst message = 'Message text';\n \nconst encoder = new TextEncoder();\n\nawait threadApi.sendMessage(\n    threadId, \n    serializeObject(\"some public meta-data\"), \n    serializeObject(\"some private meta-data\"), \n    serializeObject(message)\n);\n```",
          "```ts\nconst messageObject = {\n    //output from the chosen WYSIWYG editor\n    //or your own object definition \n};\n\nconst privateMeta = {\n    type: 'markdown'\n};\n\nconst publicMeta = {\n    tag: 'tag'\n};\n\nawait threadApi.sendMessage(\n    threadId, \n    serializeObject(publicMeta), \n    serializeObject(privateMeta),\n    serializeObject(messageObject)\n);\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.883Z",
        "size": 1117
      }
    },
    {
      "pageContent": "## Receiving Messages\n\nTo get a list of messages inside a Thread, use `getMessages` method. Because data inside messages is in Uint8Array\nyou have to deserialize it to human-readable string.\n**Endpoint takes care of encrypting your data before sending it to PrivMX Bridge.**\n\n```js\nconst defaultListQuery = {skip: 0, limit: 100, sortOrder: \"desc\"};\n\nconst messages = await threadApi.listMessages(threadId, defaultListQuery);\nconst decodedMessages = messages.readItems.map(x =>\n   {\n      return {\n        publicMeta: deserializedObject(x.publicMeta),\n        privateMeta: deserializedObject(x.privateMeta),\n        data: deserializedObject(x.data)\n      }\n   }\n)\nconsole.log(\"messages\", messages);\nconsole.log(\"messages in human-readable format\", decodedMessages);\n```",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/messages.mdx",
        "type": "mdx",
        "chunkIndex": 2,
        "headers": [
          "Receiving Messages"
        ],
        "title": "Receiving Messages",
        "codeBlocks": [
          "```js\nconst defaultListQuery = {skip: 0, limit: 100, sortOrder: \"desc\"};\n\nconst messages = await threadApi.listMessages(threadId, defaultListQuery);\nconst decodedMessages = messages.readItems.map(x =>\n   {\n      return {\n        publicMeta: deserializedObject(x.publicMeta),\n        privateMeta: deserializedObject(x.privateMeta),\n        data: deserializedObject(x.data)\n      }\n   }\n)\nconsole.log(\"messages\", messages);\nconsole.log(\"messages in human-readable format\", decodedMessages);\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.883Z",
        "size": 768
      }
    },
    {
      "pageContent": "---\ntitle: Store Overview\n---\n\n\n\nStores provide encrypted block storage, enabling simple file uploading and downloading.\n\n:::info\n\nBefore working with Stores, follow our [Getting Started Guide](./introduction). It will show you how to set up your project to work with PrivMX Bridge.\n\nThe sample code on this page is based on the same **[assumptions](./first-app#initial-assumptions)**\n\n:::\n\n## Working with Stores\n\nWhen working with Stores, you will use the following:\n\nWhen working with Threads, you will use the following:\n- `storeApi` - provides methods used to manage Stores in given Context\n\n```js\nconst storeApi  = await EndpointFactory.createStoreApi(CONNECTION_ID);\n```",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/stores.mdx",
        "type": "mdx",
        "chunkIndex": 0,
        "headers": [
          "Working with Stores"
        ],
        "title": "Working with Stores",
        "codeBlocks": [
          "```js\nconst storeApi  = await EndpointFactory.createStoreApi(CONNECTION_ID);\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.884Z",
        "size": 677
      }
    },
    {
      "pageContent": "## Creating Stores\n\n<Tabs groupId=\"variant\" items={[\"Basic\",\"With a Name\",\"With `publicMeta`\"]}>\n<Tab>\nCreating a basic unnamed Store, which can act as an encrypted block container:\n\n```js\nconst managers = [\n    {userId: USER1_ID, pubKey: USER1_PUBLIC_KEY}\n];\n\nconst users = [\n    {userId: USER1_ID, pubKey: USER1_PUBLIC_KEY},\n    {userId: USER2_ID, pubKey: USER2_PUBLIC_KEY}\n];\n\n// create a new Store with access for user_1 as manager and user_2 as regular user\n// for example, let's put the name of the store as an object in the store's private meta\nconst storeId = await storesApi.createStore(CONTEXT_ID, users, managers,\n    serializeObject(\"some store's public meta-data\"),\n    serializeObject(\"some store's private meta-data\")\n);\n```\n</Tab>\n<Tab>\n\nYou can assign any data to private and public meta fields (e.g. the Store's name), as long as they are serialized to `Uint8Array`.\n\n```js\nconst managers = [\n    {userId: USER1_ID, pubKey: USER1_PUBLIC_KEY}\n];\n\nconst users = [\n    {userId: USER1_ID, pubKey: USER1_PUBLIC_KEY},\n    {userId: USER2_ID, pubKey: USER2_PUBLIC_KEY}\n];\n\nconst privateMeta = {\n    name: 'Photo Album'\n};",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/stores.mdx",
        "type": "mdx",
        "chunkIndex": 1,
        "headers": [
          "Creating Stores"
        ],
        "title": "Creating Stores",
        "codeBlocks": [
          "```js\nconst managers = [\n    {userId: USER1_ID, pubKey: USER1_PUBLIC_KEY}\n];\n\nconst users = [\n    {userId: USER1_ID, pubKey: USER1_PUBLIC_KEY},\n    {userId: USER2_ID, pubKey: USER2_PUBLIC_KEY}\n];\n\n// create a new Store with access for user_1 as manager and user_2 as regular user\n// for example, let's put the name of the store as an object in the store's private meta\nconst storeId = await storesApi.createStore(CONTEXT_ID, users, managers,\n    serializeObject(\"some store's public meta-data\"),\n    serializeObject(\"some store's private meta-data\")\n);\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.884Z",
        "size": 1131
      }
    },
    {
      "pageContent": "const users = [\n    {userId: USER1_ID, pubKey: USER1_PUBLIC_KEY},\n    {userId: USER2_ID, pubKey: USER2_PUBLIC_KEY}\n];\n\nconst privateMeta = {\n    name: 'Photo Album'\n};\n\nconst storeId = storeApi.createStore(\n    CONTEXT_ID,\n    users,\n    managers,\n    serializeObject(\"some public-meta\"),\n    serializeObject(privateMeta)\n);\n```\n</Tab>\n<Tab>\n\nYou can implement a tag system, which allows to create Stores with arbitrary tags.\nPutting them inside `publicMeta` gives your own server the ability to access it using Bridge REST API.\n\n```js\nconst managers = [\n    {userId: USER1_ID, pubKey: USER1_PUBLIC_KEY}\n];\n\nconst users = [\n    {userId: USER1_ID, pubKey: USER1_PUBLIC_KEY},\n    {userId: USER2_ID, pubKey: USER2_PUBLIC_KEY}\n];\n\nconst privateMeta = {\n    name: 'Album'\n};\n\nconst publicMeta = {\n    tags: ['TAG1', 'TAG2', 'TAG3']\n};\n\nconst storeId = storeApi.createStore(\n    CONTEXT_ID,\n    users,\n    managers,\n    serializeObject(publicMeta),\n    serializeObject(privateMeta)\n);\n```\n</Tab>\n</Tabs>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/stores.mdx",
        "type": "mdx",
        "chunkIndex": 2,
        "codeBlocks": [
          "```\n</Tab>\n<Tab>\n\nYou can implement a tag system, which allows to create Stores with arbitrary tags.\nPutting them inside `publicMeta` gives your own server the ability to access it using Bridge REST API.\n\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.884Z",
        "size": 997
      }
    },
    {
      "pageContent": "## Fetching Stores\n\n<Tabs groupId=\"variant\" items={[\"Most Recent\",\"Oldest Stores\",\"By Store ID\",\"Paging\"]}>\n<Tab>\nFetching the most recent Stores in given Context:\n\n```js\nconst defaultListQuery = {skip: 0, limit: 100, sortOrder: \"desc\"};\n\nconst storesList = await storeApi.listStores(\n    CONTEXT_ID,\n    defaultListQuery\n);\n```\nAs a result you will receive an object:\n\n```js\n// storesList:\n{\n    readItems: [<storeObject1>, <storeObject2>,..., <storeObjectN>],\n    totalAvailable: <number_of_all_stores>\n}\n```\n</Tab>\n\n<Tab>\nFetching the oldest Stores (by creation date) in given Context:\n\n```js\nconst defaultListQuery = {skip: 0, limit: 100, sortOrder: \"asc\"};\n\nconst storesList = await storeApi.listStores(\n    CONTEXT_ID,\n    defaultListQuery\n);\n\n```\nAs a result you will receive an object:\n```js\n// storesList:\n{\n    readItems: [<storeObject1>, <storeObject2>,..., <storeObjectN>],\n    totalAvailable: <number_of_all_stores>\n}\n```\n</Tab>\n\n<Tab >\nYou can get info about a Store using its `storeId`:",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/stores.mdx",
        "type": "mdx",
        "chunkIndex": 3,
        "headers": [
          "Fetching Stores"
        ],
        "title": "Fetching Stores",
        "codeBlocks": [
          "```js\nconst defaultListQuery = {skip: 0, limit: 100, sortOrder: \"desc\"};\n\nconst storesList = await storeApi.listStores(\n    CONTEXT_ID,\n    defaultListQuery\n);\n```",
          "```js\n// storesList:\n{\n    readItems: [<storeObject1>, <storeObject2>,..., <storeObjectN>],\n    totalAvailable: <number_of_all_stores>\n}\n```",
          "```js\nconst defaultListQuery = {skip: 0, limit: 100, sortOrder: \"asc\"};\n\nconst storesList = await storeApi.listStores(\n    CONTEXT_ID,\n    defaultListQuery\n);\n\n```",
          "```js\n// storesList:\n{\n    readItems: [<storeObject1>, <storeObject2>,..., <storeObjectN>],\n    totalAvailable: <number_of_all_stores>\n}\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.884Z",
        "size": 1001
      }
    },
    {
      "pageContent": "<Tab >\nYou can get info about a Store using its `storeId`:\n\n```js\nconst store = await wnd.storeApi.getStore(storeId);\nconst privateMeta = deserializeObject(store.privateMeta);\nconst publicMeta = deserializeObject(store.publicMeta);\n```\nAs a result you will receive an `Store` object.\n</Tab>\n\n<Tab>\nYou can change how many items are on a page using `limit` in options object:\n\n```js\nconst defaultListQuery = {skip: 50, limit: 20, sortOrder: \"asc\"};\n\nconst storesList = await storeApi.listStores(\n    CONTEXT_ID,\n    defaultListQuery\n);\n```\nAs a result you will receive an object:\n```js\n// storesList:\n{\n    readItems: [<storeObject1>, <storeObject2>,..., <storeObjectN>],\n    totalAvailable: <number_of_all_stores>\n}\n```\n</Tab>\n</Tabs>\n\nA detailed description of the `Store` object fields can be found [here](../reference/webendpoint/api-reference/types#Store).",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/stores.mdx",
        "type": "mdx",
        "chunkIndex": 4,
        "codeBlocks": [
          "```js\nconst store = await wnd.storeApi.getStore(storeId);\nconst privateMeta = deserializeObject(store.privateMeta);\nconst publicMeta = deserializeObject(store.publicMeta);\n```",
          "```js\nconst defaultListQuery = {skip: 50, limit: 20, sortOrder: \"asc\"};\n\nconst storesList = await storeApi.listStores(\n    CONTEXT_ID,\n    defaultListQuery\n);\n```",
          "```js\n// storesList:\n{\n    readItems: [<storeObject1>, <storeObject2>,..., <storeObjectN>],\n    totalAvailable: <number_of_all_stores>\n}\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.884Z",
        "size": 860
      }
    },
    {
      "pageContent": "## Modifying Stores\n\nThe `updateStore(...)` method needs all the parameters as in the `createStore(...)` method and a few more. If you want to update \none of the parameters - provide it in a new modified form. If, on the other hand, you want to leave \nthe parameter unchanged, provide it as it was before. All current values ​​of the parameters of a given Store can be\nobtained using `getStore(threadId)`.\n\n<Tabs items={[\"Renaming Store\",\"Removing Users\",\"Deleting Store\"]}>\n<Tab>\n\n```js\nconst store = await storeApi.getStore(storeId);\n\nconst newUsers = store.users.map(user => ({\n    //Your application must provide a way,\n    //to get user's public key from their userId.\n    userId: user,\n    pubKey: 'USER_PUBLIC_KEY'\n    })\n);\n\nconst newManagers = newUsers.filter(user =>\n    store.managers.find(manager => manager == user.userId));\n\nconst newPrivateMeta = {\n    title: 'New store name'\n};\n\nawait storeApi.updateStore(\n    storeId\n    newUsers,\n    newManagers,\n    store.publicMeta,\n    serializeObject(newPrivateMeta)\n    store.version,\n    false,\n    false\n);\n```\n</Tab>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/stores.mdx",
        "type": "mdx",
        "chunkIndex": 5,
        "headers": [
          "Modifying Stores"
        ],
        "title": "Modifying Stores",
        "codeBlocks": [
          "```js\nconst store = await storeApi.getStore(storeId);\n\nconst newUsers = store.users.map(user => ({\n    //Your application must provide a way,\n    //to get user's public key from their userId.\n    userId: user,\n    pubKey: 'USER_PUBLIC_KEY'\n    })\n);\n\nconst newManagers = newUsers.filter(user =>\n    store.managers.find(manager => manager == user.userId));\n\nconst newPrivateMeta = {\n    title: 'New store name'\n};\n\nawait storeApi.updateStore(\n    storeId\n    newUsers,\n    newManagers,\n    store.publicMeta,\n    serializeObject(newPrivateMeta)\n    store.version,\n    false,\n    false\n);\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.884Z",
        "size": 1078
      }
    },
    {
      "pageContent": "await storeApi.updateStore(\n    storeId\n    newUsers,\n    newManagers,\n    store.publicMeta,\n    serializeObject(newPrivateMeta)\n    store.version,\n    false,\n    false\n);\n```\n</Tab>\n\n<Tab>\nTo remove a user from the Store you must update a list of the users/managers by removing the user you want to get rid of.\nAll the other values required for update can be taken from the current Store.\n\n```js\nconst userToRemove = 'USERID_TO_REMOVE';\n\nconst store = await storeApi.getStore(storeId);\n\nconst newUsers = store.users\n    .filter(user => user !== userToRemove)\n    .map(user => ({\n        //Your application must provide a way,\n        //to get user's public key from their userId.\n        userId: user,\n        pubKey: 'USER_PUBLIC_KEY'\n    })\n);\n\nconst newManagers = newUsers.filter(user =>\n    store.managers.find(manager => manager == user.userId));\n\nconst newPrivateMeta = {\n    title: 'New store name'\n};\n\nawait storeApi.updateStore(\n    storeId\n    newUsers,\n    newManagers,\n    store.publicMeta,\n    serializeObject(newPrivateMeta)\n    store.version,\n    false,\n    false\n);",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/stores.mdx",
        "type": "mdx",
        "chunkIndex": 6,
        "codeBlocks": [
          "```\n</Tab>\n\n<Tab>\nTo remove a user from the Store you must update a list of the users/managers by removing the user you want to get rid of.\nAll the other values required for update can be taken from the current Store.\n\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.884Z",
        "size": 1082
      }
    },
    {
      "pageContent": "```\n\n</Tab>\n\n<Tab>\nThe snippet below deletes the Store and all its data. This action is irreversible.\n\n```js\nawait storeApi.deleteStore(storeId);\n```\n</Tab>\n</Tabs>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/stores.mdx",
        "type": "mdx",
        "chunkIndex": 7,
        "codeBlocks": [
          "```\n\n</Tab>\n\n<Tab>\nThe snippet below deletes the Store and all its data. This action is irreversible.\n\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.884Z",
        "size": 164
      }
    },
    {
      "pageContent": "---\ntitle: Overview\n---\n\n\n\n\nThreads are a secure way for assigned members to exchange encrypted messages.\n\n:::info\n\nBefore working with Threads, follow our [Getting Started Guide](./introduction). It will show you how to set up your project to work with PrivMX Bridge.\nThe sample code on this page is based on the same **[assumptions](./first-app#initial-assumptions)**\n\n:::\n\n\n## Working with Threads\n\nWhen working with Threads, you will use the following:\n- `ThreadApi` - provides methods used to manage Threads in given Context\n\n```js\nconst threadApi  = await Endpoint.createThreadApi(connection);\n```",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/threads.mdx",
        "type": "mdx",
        "chunkIndex": 0,
        "headers": [
          "Working with Threads"
        ],
        "title": "Working with Threads",
        "codeBlocks": [
          "```js\nconst threadApi  = await Endpoint.createThreadApi(connection);\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.884Z",
        "size": 603
      }
    },
    {
      "pageContent": "## Creating Threads\n<Tabs groupId=\"variant\" items={[\"Basic\",\"With a Name\",\"Public Meta\"]}>\n<Tab >\nCreating a basic, unnamed Thread, which can act as an encrypted data container:\n\n```js\nconst managers = [\n    {userId: USER1_ID, pubKey: USER1_PUBLIC_KEY}\n];\n\nconst users = [\n    {userId: USER1_ID, pubKey: USER1_PUBLIC_KEY},\n    {userId: USER2_ID, pubKey: USER2_PUBLIC_KEY}\n];\n\n// create a new Thread with access for USER_1 as manager and USER_2 as regular user\nconst threadId = await threadsApi.createThread(CONTEXT_ID, users, managers,\n    serializeObject(\"some thread's public meta-data\"),\n    serializeObject(\"some thread's private meta-data\")\n);\n```\n</Tab>\n <Tab >\n\nYou can assign any data to private and public meta fields (e.g. the Thread's name), as long as they are serialized to `Uint8Array`.\n```js\nconst privateMeta = {\n    name: 'First thread'\n};\n\nconst managers = [\n    {userId: USER1_ID, pubKey: USER1_PUBLIC_KEY}\n];\n\nconst users = [\n    {userId: USER1_ID, pubKey: USER1_PUBLIC_KEY},\n    {userId: USER2_ID, pubKey: USER2_PUBLIC_KEY}\n];",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/threads.mdx",
        "type": "mdx",
        "chunkIndex": 1,
        "headers": [
          "Creating Threads"
        ],
        "title": "Creating Threads",
        "codeBlocks": [
          "```js\nconst managers = [\n    {userId: USER1_ID, pubKey: USER1_PUBLIC_KEY}\n];\n\nconst users = [\n    {userId: USER1_ID, pubKey: USER1_PUBLIC_KEY},\n    {userId: USER2_ID, pubKey: USER2_PUBLIC_KEY}\n];\n\n// create a new Thread with access for USER_1 as manager and USER_2 as regular user\nconst threadId = await threadsApi.createThread(CONTEXT_ID, users, managers,\n    serializeObject(\"some thread's public meta-data\"),\n    serializeObject(\"some thread's private meta-data\")\n);\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.884Z",
        "size": 1047
      }
    },
    {
      "pageContent": "const managers = [\n    {userId: USER1_ID, pubKey: USER1_PUBLIC_KEY}\n];\n\nconst users = [\n    {userId: USER1_ID, pubKey: USER1_PUBLIC_KEY},\n    {userId: USER2_ID, pubKey: USER2_PUBLIC_KEY}\n];\n\n// create a new Thread with access for user_1 as manager and user_2 as regular user\nconst threadId = await threadsApi.createThread(CONTEXT_ID, users, managers,\n    serializeObject(\"some thread's public meta-data\"),\n    serializeObject(privateMeta)\n);",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/threads.mdx",
        "type": "mdx",
        "chunkIndex": 2,
        "lastModified": "2025-06-05T19:33:57.884Z",
        "size": 441
      }
    },
    {
      "pageContent": "```\n\n\n</Tab>\n<Tab >\n\nYou can implement a tag system which allows you to create Threads with arbitrary tags.\nPutting them inside `publicMeta` gives your own server ability to access it using [PrivMX Bridge API](https://bridge.privmx.dev/).\n\n```js\nconst privateMeta = {\n    name: 'First Thread'\n};\n\nconst publicMeta = {\n    tags: ['TAG1', 'TAG2', 'TAG3']\n};\n\nconst managers = [\n    {userId: USER1_ID, pubKey: USER1_PUBLIC_KEY}\n];\n\nconst users = [\n    {userId: USER1_ID, pubKey: USER1_PUBLIC_KEY},\n    {userId: USER2_ID, pubKey: USER2_PUBLIC_KEY}\n];\n\n// create a new Thread with access for USER_1 as manager and USER_2 as regular user\nconst threadId = await threadsApi.createThread(CONTEXT_ID, users, managers,\n    serializeObject(publicMeta),\n    serializeObject(privateMeta)\n);\n```\n\n</Tab>\n</Tabs>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/threads.mdx",
        "type": "mdx",
        "chunkIndex": 3,
        "codeBlocks": [
          "```\n\n\n</Tab>\n<Tab >\n\nYou can implement a tag system which allows you to create Threads with arbitrary tags.\nPutting them inside `publicMeta` gives your own server ability to access it using [PrivMX Bridge API](https://bridge.privmx.dev/).\n\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.884Z",
        "size": 796
      }
    },
    {
      "pageContent": "## Fetching Threads\n\n<Tabs groupId=\"variant\" items={[\"Recent\",\"Sorting\",\"ThreadID\",\"Paging\"]}>\n<Tab value=\"recent\" label=\"Most Recent\">\nFetching the most recent Threads in given Context:\n\n```js\nconst defaultListQuery = {skip: 0, limit: 100, sortOrder: \"desc\"};\nconst threadList = await threadApi.listThreads(CONTEXT_ID, defaultListQuery);\n```\nAs a result you will receive an object:\n```js\n// threadList:\n{\n    readItems: [<threadObject1>, <threadObject2>,..., <threadObjectN>],\n    totalAvailable: <number_of_all_threads>\n}\n```\n\n</Tab>\n\n<Tab value={\"sorting\"} label={\"Oldest Threads\"}>\nFetching the oldest Threads (by creation date) in given Context:\n\n```js\nconst defaultListQuery = {skip: 0, limit: 100, sortOrder: \"asc\"};\nconst threadList = await threadApi.listThreads(CONTEXT_ID, defaultListQuery);\n```\nAs a result you will receive an object:\n```js\n// threadList:\n{\n    readItems: [<threadObject1>, <threadObject2>,..., <threadObjectN>],\n    totalAvailable: <number_of_all_threads>\n}",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/threads.mdx",
        "type": "mdx",
        "chunkIndex": 4,
        "headers": [
          "Fetching Threads"
        ],
        "title": "Fetching Threads",
        "codeBlocks": [
          "```js\nconst defaultListQuery = {skip: 0, limit: 100, sortOrder: \"desc\"};\nconst threadList = await threadApi.listThreads(CONTEXT_ID, defaultListQuery);\n```",
          "```js\n// threadList:\n{\n    readItems: [<threadObject1>, <threadObject2>,..., <threadObjectN>],\n    totalAvailable: <number_of_all_threads>\n}\n```",
          "```js\nconst defaultListQuery = {skip: 0, limit: 100, sortOrder: \"asc\"};\nconst threadList = await threadApi.listThreads(CONTEXT_ID, defaultListQuery);\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.884Z",
        "size": 986
      }
    },
    {
      "pageContent": "```\n\n</Tab>\n\n<Tab value={\"threadID\"} label={\"By Thread ID\"}>\nYou can get info about a Thread using its `threadId`:\n\n```js\nconst thread = await threadApi.getThread(\n    threadId    \n);\n\nconst privateMeta = deserializeObject(thread.privateMeta);\nconst publicMeta = deserializeObject(thread.publicMeta);\n```\nAs a result you will receive an `Thread` object.\n</Tab>\n\n<Tab value={\"paging\"} label={\"Paging\"}>\nYou can change how many items are on a page using `limit` in options object:\n```js\n\nconst defaultListQuery = {skip: 50, limit: 20, sortOrder: \"asc\"};\nconst threadList = await threadApi.listThreads(CONTEXT_ID, defaultListQuery);\n\n```\nAs a result you will receive an object:\n```js\n// threadList:\n{\n    readItems: [THREAD_1,THREAD_2,THREAD_3],\n    totalAvailable: NUMBER_OF_THREADS\n}\n```\n</Tab>\n</Tabs>\n\nA detailed description of the `Thread` object fields can be found [here](../reference/webendpoint/api-reference/types#thread).",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/threads.mdx",
        "type": "mdx",
        "chunkIndex": 5,
        "codeBlocks": [
          "```\n\n</Tab>\n\n<Tab value={\"threadID\"} label={\"By Thread ID\"}>\nYou can get info about a Thread using its `threadId`:\n\n```",
          "```\nAs a result you will receive an `Thread` object.\n</Tab>\n\n<Tab value={\"paging\"} label={\"Paging\"}>\nYou can change how many items are on a page using `limit` in options object:\n```",
          "```\nAs a result you will receive an object:\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.884Z",
        "size": 929
      }
    },
    {
      "pageContent": "## Modifying Threads",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/threads.mdx",
        "type": "mdx",
        "chunkIndex": 6,
        "headers": [
          "Modifying Threads"
        ],
        "title": "Modifying Threads",
        "lastModified": "2025-06-05T19:33:57.884Z",
        "size": 20
      }
    },
    {
      "pageContent": "### How Updates Work\nTo update a Thread you must always provide a full list of parameters.\n\nThe `updateThread(...)` method needs all the parameters as in the `createThread(...)` method and a few more. If we want to update\none of the parameters - we provide it in a new modified form. If - on the other hand - we want to leave\nthe parameter unchanged, we provide it as it was before. All current values ​​of the parameters of a given Thread can be\nobtained using `getThread(threadId)`\n\n<Tabs items={[\"Renaming Thread\",\"Removing User\",\"Deleting Thread\"]}>\n<Tab>\n\n```js\nconst thread = await threadApi.getThread(threadId);\n\nconst newUsers = thread.users.map(user => ({\n    //Your application must provide a way,\n    //to get user's public key from their userId.\n    userId: user,\n    pubKey: 'USER_PUBLIC_KEY'\n    })\n);\n\nconst newManagers = newUsers.filter(user =>\n    thread.managers.find(manager => manager == user.userId));\n\nconst newPrivateMeta = {\n    title: 'New thread name'\n};\n\nawait threadApi.updateThread(\n    threadId\n    newUsers,\n    newManagers,\n    thread.publicMeta,\n    serializeObject(newPrivateMeta),\n    thread.version,\n    false,\n    false\n);",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/threads.mdx",
        "type": "mdx",
        "chunkIndex": 7,
        "headers": [
          "How Updates Work"
        ],
        "title": "How Updates Work",
        "lastModified": "2025-06-05T19:33:57.884Z",
        "size": 1159
      }
    },
    {
      "pageContent": "```\n\n</Tab>\n<Tab>\nTo remove a user from the Thread you must update a list of the users/managers by removing the user you want to get rid of.\nAll the other values required for update can be taken from the current Thread.\n\n```js\nconst thread = await threadApi.getThread(threadId);\n\n// Get all users who were in the Thread,\n// besides the one you want to remove:\nconst newUsers = thread.users\n  .filter(user => user !== userToRemove)\n  .map(user => ({\n    // Your application must provide a way,\n    // to get user's public key from their userId.\n    userId: user,\n    pubKey: 'USER_PUBLIC_KEY'\n  }));\n\nconst newManagers = newUsers.filter(user =>\n  thread.managers.find(manager => manager == user.userId)\n);\n\nawait threadApi.updateThread(\n  threadId,\n  newUsers,\n  newManagers,\n  thread.publicMeta,\n  thread.privateMeta,\n  thread.version,\n  false,\n  false\n);\n```\n\n</Tab>\n<Tab>\nThe snippet below deletes Thread and all its data. This action is irreversible.\n\n```js\nawait threadApi.deleteThread(threadId);\n```\n</Tab>\n</Tabs>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/threads.mdx",
        "type": "mdx",
        "chunkIndex": 8,
        "codeBlocks": [
          "```\n\n</Tab>\n<Tab>\nTo remove a user from the Thread you must update a list of the users/managers by removing the user you want to get rid of.\nAll the other values required for update can be taken from the current Thread.\n\n```",
          "```\n\n</Tab>\n<Tab>\nThe snippet below deletes Thread and all its data. This action is irreversible.\n\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.884Z",
        "size": 1019
      }
    },
    {
      "pageContent": "---\ntitle: Introduction\nfull: false\n---\n\n**Safe Notes** - app for creating **E2E Encrypted** notes. You will build the app with PrivMX and Next.js.\n\n## Concepts\n\nThis tutorial will introduce the following concepts:\n\n1. Setting up your local **PrivMX Bridge**\n2. Working with the **@simplito/privmx-webendpoint** in your project\n3. Threads\n4. Event handling\n\n## Prerequisites\n\n1. Basic knowledge of JavaScript, [React](https://react.dev/) and [Next.js](https://nextjs.org/)\n2. Have [Node.js](https://nodejs.org/en), [NPM](https://www.npmjs.com/) and [Docker](https://www.docker.com/) installed on your computer.",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/next/01-introduction.mdx",
        "type": "mdx",
        "chunkIndex": 0,
        "headers": [
          "Concepts",
          "Prerequisites"
        ],
        "title": "Concepts",
        "lastModified": "2025-06-05T19:33:57.885Z",
        "size": 610
      }
    },
    {
      "pageContent": "---\ntitle: Setting up bridge\ndescription: This part will guide you on how to setup your local PrivMX Bridge.\nfull: false\n---\n\nimport { Tabs, Tab } from 'fumadocs-ui/components/tabs';\n\n<div className=\"fd-steps\">\n\n  <div className=\"fd-step\">**Clone the PrivMX Bridge Docker repository**</div>  \n\n  <Tabs items={[\"HTTPS\",\"SSH\", \"GitHub CLI\"]}>\n    <Tab>\n      ```sh\n      git clone https://github.com/simplito/privmx-bridge-docker.git\n      ```\n    </Tab>\n\n    <Tab>\n        ```sh\n      git clone git@github.com:simplito/privmx-bridge-docker.git\n      ```\n    </Tab>\n\n    <Tab>\n        ```sh\n      gh repo clone simplito/privmx-bridge-docker\n      ```\n    </Tab>\n  </Tabs>\n\n  <div className=\"fd-step\">**Spin up the PrivMX Bridge instance**</div>\n\n  Navigate into the cloned repository and run the setup script:\n\n  ```sh\n  cd privmx-bridge-docker\n  ./setup.sh\n  ```\n  This script will:\n\n  - Start the necessary Docker containers\n  - Generate an **API Key**\n  - Create a default **Solution** and **Context**\n\n  <div className=\"fd-step\">**Verify Installation**</div>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/next/02-privmx-bridge.mdx",
        "type": "mdx",
        "chunkIndex": 0,
        "codeBlocks": [
          "```sh\n      git clone https://github.com/simplito/privmx-bridge-docker.git\n      ```",
          "```sh\n      git clone git@github.com:simplito/privmx-bridge-docker.git\n      ```",
          "```sh\n      gh repo clone simplito/privmx-bridge-docker\n      ```",
          "```sh\n  cd privmx-bridge-docker\n  ./setup.sh\n  ```"
        ],
        "lastModified": "2025-06-05T19:33:57.885Z",
        "size": 1060
      }
    },
    {
      "pageContent": "Once the setup is complete, you should see an output similar to this:\n  ```sh\n  ***************************************************************************\n  *                                                                         *\n  *     _____      _       __  ____   __  ____       _     _                *\n  *    |  __ \\    (_)     |  \\/  \\ \\ / / |  _ \\     (_)   | |               *\n  *    | |__) | __ ___   _| \\  / |\\ V /  | |_) |_ __ _  __| | __ _  ___     *\n  *    |  ___/ '__| \\ \\ / / |\\/| | > <   |  _ <| '__| |/ _` |/ _` |/ _ \\    *\n  *    | |   | |  | |\\ V /| |  | |/ . \\  | |_) | |  | | (_| | (_| |  __/    *\n  *    |_|   |_|  |_| \\_/ |_|  |_/_/ \\_\\ |____/|_|  |_|\\__,_|\\__, |\\___|    *\n  *                                                           __/ |         *\n  *                                                          |___/          *\n  *                                                                         *\n  *            Installation Complete! Thank you for choosing us :)          *\n  *                                                                         *\n  ***************************************************************************",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/next/02-privmx-bridge.mdx",
        "type": "mdx",
        "chunkIndex": 1,
        "lastModified": "2025-06-05T19:33:57.885Z",
        "size": 1169
      }
    },
    {
      "pageContent": "PrivMX Bridge URL:  http://localhost:9111\n\n            API Key ID:  18fae62538b99c51b36a7f9a29d84b3a\n        API Key Secret:  661fbf74bb78614db971131ad4def48b\n\n      IDs generated for your application:\n            Solution ID:  6b95b01e-7f24-486c-b8f6-44116c292ca6\n            Context ID:  b8e2a6de-7ee1-4948-b578-173590eaa0d1\n\n  All the data above is saved in the ./volumes/.env file.\n  To learn what you can do with PrivMX Bridge, visit https://docs.privmx.dev/bridge#after-installing",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/next/02-privmx-bridge.mdx",
        "type": "mdx",
        "chunkIndex": 2,
        "lastModified": "2025-06-05T19:33:57.885Z",
        "size": 486
      }
    },
    {
      "pageContent": "```\n\n  These credentials are necessary for interacting with **PrivMX Bridge**.\n</div>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/next/02-privmx-bridge.mdx",
        "type": "mdx",
        "chunkIndex": 3,
        "lastModified": "2025-06-05T19:33:57.885Z",
        "size": 85
      }
    },
    {
      "pageContent": "---\ntitle: Create app\ndescription: Create Next.js project\nfull: false\n---\nimport { Tab, Tabs } from 'fumadocs-ui/components/tabs';\n\n\n<div className=\"fd-steps\">\n\n  <div className=\"fd-step\">\n  **Create Next.js project**\n  </div>\n\n  Start by creating a new **Next.js** application using the following command:\n\n  ```sh\n  npx create-next-app@latest --ts --tailwind --eslint --app --src-dir --turbopack safe-notes && cd safe-notes",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/next/app/03-create-app.mdx",
        "type": "mdx",
        "chunkIndex": 0,
        "lastModified": "2025-06-05T19:33:57.885Z",
        "size": 425
      }
    },
    {
      "pageContent": "```\n\n  This command will:\n  - Set up a **Next.js** project with **TypeScript**\n  - Include **Tailwind CSS** for styling\n  - Enable **ESLint** for code quality\n  - Use **Turbopack** for faster builds\n  - Organize code inside a `src/` directory\n\n  <div className=\"fd-step\">\n  **Configure NPM Scripts**\n  </div>\n  To simplify asset handling, update the `scripts` section in your `package.json`:\n  ```json title=\"package.json\"\n  \"scripts\": {\n    \"dev\": \"next dev --turbopack\",\n    \"build\": \"next build\",\n    \"start\": \"next start\",\n    \"lint\": \"next lint\",\n    \"update-endpoint\": \"npm install @simplito/privmx-webendpoint@latest && npm run copy-privmx-assets\",   // [!code highlight]\n    \"copy-privmx-assets\": \"mkdir -p public/privmx-assets && cp -r node_modules/@simplito/privmx-webendpoint/assets/* public/privmx-assets/\",  // [!code highlight]\n    \"postinstall\": \"npm run copy-privmx-assets\"  // [!code highlight]\n  },",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/next/app/03-create-app.mdx",
        "type": "mdx",
        "chunkIndex": 1,
        "codeBlocks": [
          "```\n\n  This command will:\n  - Set up a **Next.js** project with **TypeScript**\n  - Include **Tailwind CSS** for styling\n  - Enable **ESLint** for code quality\n  - Use **Turbopack** for faster builds\n  - Organize code inside a `src/` directory\n\n  <div className=\"fd-step\">\n  **Configure NPM Scripts**\n  </div>\n  To simplify asset handling, update the `scripts` section in your `package.json`:\n  ```"
        ],
        "lastModified": "2025-06-05T19:33:57.885Z",
        "size": 916
      }
    },
    {
      "pageContent": "```\n\n  This adds:\n  - `update-endpoint` – Installs the **PrivMX WebEndpoint** package and copies its assets.\n  - `copy-privmx-assets` – Ensures PrivMX assets are placed in `public/privmx-assets/`.\n  - `postinstall` – Automatically runs `copy-privmx-assets` after installing dependencies.\n\n\n  <div className=\"fd-step\">\n  **Install WebEndpoint**\n  </div>\n  Run the following command to download the PrivMX WebEndpoint package and copy its assets to your public directory:\n\n  ```package-install\n  npm run update-endpoint\n  ```\n\n  <div className=\"fd-step\">\n  **Setup your environment variables**\n  </div>\n\n  Create a file named `.env.local` in your `src` folder and fill in the variables\n\n  ```sh title=\".env.local\"\n  NEXT_PUBLIC_CONTEXT_ID=\n  NEXT_PUBLIC_SOLUTION_ID=\n  NEXT_PUBLIC_BRIDGE_URL=http://localhost:9111\n  BRIDGE_API_URL=$NEXT_PUBLIC_BRIDGE_URL/api\n\n  API_KEY_ID=\n  API_KEY_SECRET=",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/next/app/03-create-app.mdx",
        "type": "mdx",
        "chunkIndex": 2,
        "codeBlocks": [
          "```\n\n  This adds:\n  - `update-endpoint` – Installs the **PrivMX WebEndpoint** package and copies its assets.\n  - `copy-privmx-assets` – Ensures PrivMX assets are placed in `public/privmx-assets/`.\n  - `postinstall` – Automatically runs `copy-privmx-assets` after installing dependencies.\n\n\n  <div className=\"fd-step\">\n  **Install WebEndpoint**\n  </div>\n  Run the following command to download the PrivMX WebEndpoint package and copy its assets to your public directory:\n\n  ```",
          "```\n\n  <div className=\"fd-step\">\n  **Setup your environment variables**\n  </div>\n\n  Create a file named `.env.local` in your `src` folder and fill in the variables\n\n  ```"
        ],
        "lastModified": "2025-06-05T19:33:57.885Z",
        "size": 889
      }
    },
    {
      "pageContent": "```\n\n  <div className=\"fd-step\">\n  **Setup [COEP](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cross-Origin-Embedder-Policy) and [COOP](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cross-Origin-Opener-Policy) headers for WASM**\n\n  ```ts title=\"next.config.ts\"\n  import type { NextConfig } from 'next';\n\n  const nextConfig: NextConfig = {\n      headers: async () => {\n          return [\n              {\n                  source: '/(.*)',\n                  headers: [\n                      {\n                          key: 'Cross-Origin-Embedder-Policy',\n                          value: 'require-corp'\n                      },\n                      {\n                          key: 'Cross-Origin-Opener-Policy',\n                          value: 'same-origin'\n                      }\n                  ]\n              }\n          ];\n      }\n  };\n\n  export default nextConfig;\n  ``` \n  </div>\n\n  <div className=\"fd-step\">\n  **Test your project**\n  </div>\n  Run the command below and open http://localhost:3000 in your browser\n  ``` package-install\n  npm run dev\n  ```\n</div>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/next/app/03-create-app.mdx",
        "type": "mdx",
        "chunkIndex": 3,
        "codeBlocks": [
          "```\n\n  <div className=\"fd-step\">\n  **Setup [COEP](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cross-Origin-Embedder-Policy) and [COOP](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cross-Origin-Opener-Policy) headers for WASM**\n\n  ```",
          "``` \n  </div>\n\n  <div className=\"fd-step\">\n  **Test your project**\n  </div>\n  Run the command below and open http://localhost:3000 in your browser\n  ```"
        ],
        "lastModified": "2025-06-05T19:33:57.885Z",
        "size": 1097
      }
    },
    {
      "pageContent": "---\ntitle: Register flow\ndescription: This part of the guide will walk you through how to create a sign up flow\nfull: false\n---\n\nimport { Tabs, Tab } from 'fumadocs-ui/components/tabs';\n\n\n<div className=\"flex items-center justify-center\">\n  ![Sign up form](./sign-up.png)\n  </div>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/next/app/04-sign-up.mdx",
        "type": "mdx",
        "chunkIndex": 0,
        "lastModified": "2025-06-05T19:33:57.886Z",
        "size": 280
      }
    },
    {
      "pageContent": "## Overview\nThe sign-up flow consists of these key components:\n\n1. Server action for user registration\n2. API route for handling sign-up requests\n3. Client-side hook for managing sign-up state\n4. User interface for registration\n\n\nLet's break down each component step by step.\n\n<div className=\"fd-steps\">\n  <div className=\"fd-step\">\n  **Authenticating with PrivMX Bridge**\n  </div>\n\n  First, we need to create a function to obtain an access token from PrivMX Bridge. This token will be used to authenticate subsequent API requests.\n\n    ```ts title=\"lib/bridge.ts\"\n    'use server';\n\n    export async function getBridgeAccessToken() {\n        // Create the request body with your API credentials\n        const requestBody = {\n            jsonrpc: '2.0',\n            id: 128,\n            method: 'manager/auth',\n            params: {\n                scope: ['solution:*', 'context'],\n                grantType: 'api_key_credentials',\n                apiKeyId: process.env.API_KEY_ID,\n                apiKeySecret: process.env.API_KEY_SECRET\n            }\n        };",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/next/app/04-sign-up.mdx",
        "type": "mdx",
        "chunkIndex": 1,
        "headers": [
          "Overview"
        ],
        "title": "Overview",
        "lastModified": "2025-06-05T19:33:57.886Z",
        "size": 1063
      }
    },
    {
      "pageContent": "// Send request to the Bridge API\n        const tokenRequest = await fetch(process.env.BRIDGE_API_URL!, {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify(requestBody)\n        });\n\n        const response = await tokenRequest.json();\n\n        // Handle errors in the response\n        if ('error' in response) {\n            console.error(response.error);\n            throw new Error('Unable to get access token');\n        }\n\n        // Return the access token if successful\n        if (tokenRequest.status === 200) {\n            return response.result.accessToken;\n        }\n\n        throw new Error('Error getting access token');\n    }\n    ```\n    **How this works**:\n\n    - The function creates a JSON-RPC request with your API credentials\n    - It sends this request to the PrivMX Bridge API endpoint\n    - Upon success, it returns the access token\n    - If there's an error, it throws an appropriate exception",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/next/app/04-sign-up.mdx",
        "type": "mdx",
        "chunkIndex": 2,
        "lastModified": "2025-06-05T19:33:57.886Z",
        "size": 1012
      }
    },
    {
      "pageContent": "<div className=\"fd-step\">\n    **Creating a Server Action for User Registration**\n    </div>\n    \n    Next, we'll create a server action that adds a user to a specific context within PrivMX.\n\n  ```ts title=\"lib/actions/register-user.ts\"\n  'use server';\n\n    import { SignUpPayload } from '@/app/api/sign-up/route';\n    import { getBridgeAccessToken } from '@/lib/bridge';\n\n    export async function addUserToContext(\n        payload: SignUpPayload\n    ): Promise<{ status: 'success' | 'error'; message: string }> {\n        // Get the context ID from environment variables\n        const contextId = process.env.NEXT_PUBLIC_CONTEXT_ID;\n\n        try {\n            const accessToken = await getBridgeAccessToken();\n\n            // Prepare request to add user to context\n            const requestBody = {\n                jsonrpc: '2.0',\n                id: 128,\n                method: 'context/addUserToContext',\n                params: {\n                    contextId: contextId,\n                    userId: payload.userId,\n                    userPubKey: payload.publicKey\n                }\n            };",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/next/app/04-sign-up.mdx",
        "type": "mdx",
        "chunkIndex": 3,
        "lastModified": "2025-06-05T19:33:57.886Z",
        "size": 1102
      }
    },
    {
      "pageContent": "// Send the request\n            const addToContextRequest = await fetch(process.env.BRIDGE_API_URL!, {\n                method: 'POST',\n                headers: {\n                    'Content-Type': 'application/json',\n                    Authorization: `Bearer ${accessToken}`\n                },\n                body: JSON.stringify(requestBody)\n            });\n\n            const response = await addToContextRequest.json();\n\n            // Handle error in response\n            if ('error' in response) {\n                return {\n                    status: 'error',\n                    message: response.error.message\n                };\n            }\n\n            // Check status code\n            if (addToContextRequest.status !== 200) {\n                return {\n                    status: 'error',\n                    message: 'Error adding user to context'\n                };\n            }",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/next/app/04-sign-up.mdx",
        "type": "mdx",
        "chunkIndex": 4,
        "lastModified": "2025-06-05T19:33:57.886Z",
        "size": 895
      }
    },
    {
      "pageContent": "return {\n                status: 'success',\n                message: 'Successfully signed up!'\n            };\n        } catch (error) {\n            return {\n                status: 'error',\n                message: error instanceof Error ? error.message : 'An unexpected error occurred'\n            };\n        }\n    }\n  ```\n    **What this server action does**:\n\n    - Takes a `SignUpPayload` containing the user ID and public key\n    - Gets an access token from PrivMX Bridge using our previous function\n    - Sends a request to add the user to the specified context\n\n\n    <div className=\"fd-step\">\n    **Creating an API Route for Sign-Up**\n    </div>\n\n    Now, let's create a Next.js API route to handle sign-up requests from the client.\n\n    First, let's install [**zod**](https://zod.dev/) for input validation\n\n    ```package-install\n    npm i zod",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/next/app/04-sign-up.mdx",
        "type": "mdx",
        "chunkIndex": 5,
        "codeBlocks": [
          "```\n    **What this server action does**:\n\n    - Takes a `SignUpPayload` containing the user ID and public key\n    - Gets an access token from PrivMX Bridge using our previous function\n    - Sends a request to add the user to the specified context\n\n\n    <div className=\"fd-step\">\n    **Creating an API Route for Sign-Up**\n    </div>\n\n    Now, let's create a Next.js API route to handle sign-up requests from the client.\n\n    First, let's install [**zod**](https://zod.dev/) for input validation\n\n    ```"
        ],
        "lastModified": "2025-06-05T19:33:57.886Z",
        "size": 852
      }
    },
    {
      "pageContent": "```\n\n    Then create the sign-up route:\n\n  ```ts title=\"app/api/sign-up/route.ts\"\n  import { addUserToContext } from '@/lib/actions/register-user';\n  import { NextResponse } from 'next/server';\n  import z from 'zod';\n\n// Define the schema for validating sign-up payload\n  export const signUpSchema = z.object({\n      userId: z.string(),\n      publicKey: z.string()\n  });\n// Export the type for use in other files\n\n  export type SignUpPayload = z.infer<typeof signUpSchema>;\n\n  export async function POST(request: Request) {\n      try {\n        // Parse the request body\n          const body = await request.json();\n\n        // Validate the input\n          const { success, data, error } = signUpSchema.safeParse(body);\n          if (!success) {\n              return NextResponse.json(\n                  {\n                      message: error\n                  },\n                  {\n                      status: 400\n                  }\n              );\n          }\n        // Call the server action to add the user\n          const { status, message } = await addUserToContext(data);",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/next/app/04-sign-up.mdx",
        "type": "mdx",
        "chunkIndex": 6,
        "codeBlocks": [
          "```\n\n    Then create the sign-up route:\n\n  ```"
        ],
        "lastModified": "2025-06-05T19:33:57.886Z",
        "size": 1083
      }
    },
    {
      "pageContent": "// Return appropriate response\n          if (status === 'success') {\n              return NextResponse.json(\n                  {\n                      message\n                  },\n                  {\n                      status: 201\n                  }\n              );\n          }\n\n          return NextResponse.json(\n              {\n                  message\n              },\n              { status: 500 }\n          );\n      } catch (e) {\n          return NextResponse.json(\n              {\n                  message: e\n              },\n              { status: 500 }\n          );\n      }\n  }\n  ```\n    **What this API route does**:\n\n    - Validates the incoming request data using Zod schema\n    - Calls our server action to register the user\n    - Returns appropriate HTTP responses based on the outcome\n    - Handles any exceptions that may occur\n\n  <div className=\"fd-step\">\n  **Creating a Hook for Sign-Up Logic**\n  </div>\n\n  Now, let's create a React hook to manage the sign-up process on the client side:\n\n\n  ```ts title=\"hooks/useSignUp.ts\"\n  'use client';",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/next/app/04-sign-up.mdx",
        "type": "mdx",
        "chunkIndex": 7,
        "codeBlocks": [
          "```\n    **What this API route does**:\n\n    - Validates the incoming request data using Zod schema\n    - Calls our server action to register the user\n    - Returns appropriate HTTP responses based on the outcome\n    - Handles any exceptions that may occur\n\n  <div className=\"fd-step\">\n  **Creating a Hook for Sign-Up Logic**\n  </div>\n\n  Now, let's create a React hook to manage the sign-up process on the client side:\n\n\n  ```"
        ],
        "lastModified": "2025-06-05T19:33:57.886Z",
        "size": 1066
      }
    },
    {
      "pageContent": "Now, let's create a React hook to manage the sign-up process on the client side:\n\n\n  ```ts title=\"hooks/useSignUp.ts\"\n  'use client';\n\n  import { SignUpPayload } from '@/app/api/sign-up/route';\n  import { PrivmxClient } from '@/lib/PrivmxClient';\n  import { useState } from 'react';\n\n    // Define possible states for the sign-up process\n  interface DefaultState {\n      type: 'default';\n  }\n\n  interface LoadingState {\n      type: 'loading';\n  }\n\n  interface ErrorState {\n      type: 'error';\n      message: string;\n  }\n\n  interface SuccessState {\n      type: 'success';\n      message: string;\n  }\n\n  type FormState = DefaultState | LoadingState | ErrorState | SuccessState;\n\n  export function useSignUp() {\n        // Initialize state\n\n      const [status, setStatus] = useState<FormState>({ type: 'default' });\n\n      const signUp = async (username: string, password: string) => {\n          setStatus({ type: 'loading' });\n          try {\n            // Get cryptographic API\n              const cryptoApi = await PrivmxClient.getCryptoApi();",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/next/app/04-sign-up.mdx",
        "type": "mdx",
        "chunkIndex": 8,
        "lastModified": "2025-06-05T19:33:57.886Z",
        "size": 1045
      }
    },
    {
      "pageContent": "// Generate keys from username and password\n              const privateKey = await cryptoApi.derivePrivateKey2(username, password);\n              const publicKey = await cryptoApi.derivePublicKey(privateKey);\n\n            // Prepare sign-up payload\n              const signUpBody: SignUpPayload = {\n                  userId: username,\n                  publicKey\n              };\n\n            // Send sign-up request\n              const signUpRequest = await fetch('/api/sign-up', {\n                  body: JSON.stringify(signUpBody),\n                  method: 'POST'\n              });\n\n\n            // Handle response\n\n              if (signUpRequest.status !== 201) {\n                  setStatus({ type: 'error', message: 'Sign-up failed.' });\n                  return;\n              }\n\n              setStatus({ type: 'success', message: 'Sign-up successful!' });\n          } catch (e) {\n              console.error(e);\n              setStatus({\n                  type: 'error',\n                  message: 'An unexpected error occurred during sign-up.'\n              });\n          }\n      };\n\n      return { signUp, status };\n  }\n  ```\n  **How this hook works:**",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/next/app/04-sign-up.mdx",
        "type": "mdx",
        "chunkIndex": 9,
        "lastModified": "2025-06-05T19:33:57.886Z",
        "size": 1165
      }
    },
    {
      "pageContent": "return { signUp, status };\n  }\n  ```\n  **How this hook works:**\n\n    - Provides a signUp function that:\n        - Derives cryptographic keys from the username and password\n        - Sends the sign-up request to our API endpoint\n        - Updates the status based on the response\n    - Returns both the signUp function and current status for use in components\n\n  <div className=\"fd-step\">\n  **Creating the Sign-Up Form Component**\n  </div>\n    Finally, let's create the UI component for our sign-up form:\n\n  ```ts title=\"app/sign-up/page.tsx\"\n  'use client';\n\n  import { useSignUp } from '@/hooks/useSignUp';\n  import Link from 'next/link';\n  import { useState } from 'react';\n\n  export default function SignUpForm() {\n    // Use our sign-up hook\n      const { signUp, status } = useSignUp();\n\n    // Local state for form fields\n      const [formState, setFormState] = useState<{\n          username: string;\n          password: string;\n      }>({\n          username: '',\n          password: ''\n      });",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/next/app/04-sign-up.mdx",
        "type": "mdx",
        "chunkIndex": 10,
        "codeBlocks": [
          "```\n  **How this hook works:**\n\n    - Provides a signUp function that:\n        - Derives cryptographic keys from the username and password\n        - Sends the sign-up request to our API endpoint\n        - Updates the status based on the response\n    - Returns both the signUp function and current status for use in components\n\n  <div className=\"fd-step\">\n  **Creating the Sign-Up Form Component**\n  </div>\n    Finally, let's create the UI component for our sign-up form:\n\n  ```"
        ],
        "lastModified": "2025-06-05T19:33:57.886Z",
        "size": 1002
      }
    },
    {
      "pageContent": "// Handle input changes\n      const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n          const { name, value } = e.target;\n          setFormState((prevState) => ({\n              ...prevState,\n              [name]: value\n          }));\n      };\n\n    // Handle form submission\n      const handleSubmit = async (e: React.FormEvent) => {\n          e.preventDefault();\n          await signUp(formState.username, formState.password);\n      };\n\n      return (\n          <div className=\"flex min-h-screen items-center justify-center bg-gray-50 p-4\">\n              <div className=\"w-full max-w-md rounded-lg bg-white p-8 shadow-lg\">\n                  <div className=\"mb-6\">\n                      <h2 className=\"text-2xl font-bold text-gray-900\">Create an account</h2>\n                      <p className=\"mt-1 text-sm text-gray-600\">\n                          Enter your details below to create your account\n                      </p>\n                  </div>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/next/app/04-sign-up.mdx",
        "type": "mdx",
        "chunkIndex": 11,
        "lastModified": "2025-06-05T19:33:57.886Z",
        "size": 967
      }
    },
    {
      "pageContent": "<form className=\"space-y-4\" onSubmit={handleSubmit}>\n                      <div>\n                          <label\n                              htmlFor=\"username\"\n                              className=\"block text-sm font-medium text-gray-700\">\n                              Username\n                          </label>\n                          <input\n                              id=\"username\"\n                              name=\"username\"\n                              type=\"text\"\n                              placeholder=\"Username\"\n                              required\n                              className=\"mt-1 block w-full rounded-md border border-gray-300 px-3 py-2 text-gray-900 shadow-sm focus:border-blue-500 focus:outline-none focus:ring-1 focus:ring-blue-500\"\n                              value={formState.username}\n                              onChange={handleChange}\n                          />\n                      </div>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/next/app/04-sign-up.mdx",
        "type": "mdx",
        "chunkIndex": 12,
        "lastModified": "2025-06-05T19:33:57.886Z",
        "size": 947
      }
    },
    {
      "pageContent": "<div>\n                          <label\n                              htmlFor=\"password\"\n                              className=\"block text-sm font-medium text-gray-700\">\n                              Password\n                          </label>\n                          <input\n                              id=\"password\"\n                              name=\"password\"\n                              type=\"password\"\n                              placeholder=\"*******\"\n                              required\n                              className=\"mt-1 block w-full rounded-md border border-gray-300 px-3 py-2 text-gray-900 shadow-sm focus:border-blue-500 focus:outline-none focus:ring-1 focus:ring-blue-500\"\n                              value={formState.password}\n                              onChange={handleChange}\n                          />\n                      </div>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/next/app/04-sign-up.mdx",
        "type": "mdx",
        "chunkIndex": 13,
        "lastModified": "2025-06-05T19:33:57.886Z",
        "size": 875
      }
    },
    {
      "pageContent": "<button\n                          type=\"submit\"\n                          className=\"mt-6 w-full rounded-md bg-blue-600 px-4 py-2 text-sm font-medium text-white hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2\"\n                          disabled={status.type === 'loading'}>\n                          {status.type === 'loading' ? 'Signing Up...' : 'Sign Up'}\n                      </button>\n\n                      {status.type === 'error' && (\n                          <p className=\"text-red-500\">{status.message || 'Error signing up'}</p>\n                      )}\n\n                      {status.type === 'success' && (\n                          <p className=\"text-green-500\">\n                              {status.message || 'Successfully signed up!'}\n                          </p>\n                      )}\n                  </form>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/next/app/04-sign-up.mdx",
        "type": "mdx",
        "chunkIndex": 14,
        "lastModified": "2025-06-05T19:33:57.886Z",
        "size": 876
      }
    },
    {
      "pageContent": "<p className=\"mt-4 text-center text-sm text-gray-600\">\n                      Already a member?{' '}\n                      <Link href=\"/\" className=\"font-medium text-blue-600 hover:text-blue-500\">\n                          Sign in now\n                      </Link>\n                  </p>\n              </div>\n          </div>\n      );\n  }\n  ```\n    **What the form component does:**\n\n    - Uses our useSignUp hook to handle the sign-up logic\n    - Maintains local state for form inputs\n    - Handles form submission and input changes\n    - Displays appropriate feedback based on the current status\n    - Provides a link to the sign-in page for existing users\n</div>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/next/app/04-sign-up.mdx",
        "type": "mdx",
        "chunkIndex": 15,
        "lastModified": "2025-06-05T19:33:57.886Z",
        "size": 664
      }
    },
    {
      "pageContent": "## How Everything Works Together\n\n1. User enters their username and password in the sign-up form\n2. On form submission, the useSignUp hook:\n    - Generates cryptographic keys from the credentials\n    - Sends the user ID and public key to the API route\n3. The API route:\n    - Validates the incoming data\n    - Calls the server action to register the user\n4. The server action:\n    - Gets an access token from PrivMX Bridge\n    - Uses the token to add the user to the specified context\n5. The result is returned to the client and displayed to the user",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/next/app/04-sign-up.mdx",
        "type": "mdx",
        "chunkIndex": 16,
        "headers": [
          "How Everything Works Together"
        ],
        "title": "How Everything Works Together",
        "lastModified": "2025-06-05T19:33:57.886Z",
        "size": 550
      }
    },
    {
      "pageContent": "---\ntitle: Login Flow\ndescription: This part of the guide will walk you through how to create a sign in flow\nfull: false\n---\n\nimport { Tabs, Tab } from 'fumadocs-ui/components/tabs';\n\n<div className=\"flex items-center justify-center\">\n  ![Sign in form](./sign-in.png)\n</div>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/next/app/05-sign-in.mdx",
        "type": "mdx",
        "chunkIndex": 0,
        "lastModified": "2025-06-05T19:33:57.887Z",
        "size": 274
      }
    },
    {
      "pageContent": "### Overview\n\nThe login system uses: \n- React Context API for state management\n- Custom hooks for authentication logic\n\n<div className=\"fd-steps\">\n  <div className=\"fd-step\">\n  **Create the PrivmxContext** \n  </div>\n    First, we'll create a context to manage user connections and notes throughout the application.\n    The context provides:\n\n    - Client connection management\n    - Thread ID tracking\n    - Notes data storage\n\n    ```tsx title=\"context/PrivmxContext.tsx\"\n    import { PrivmxClient } from '@/lib/PrivmxClient';\n    import { Types } from '@simplito/privmx-webendpoint';\n    import { createContext, ReactNode, useContext, useEffect, useReducer } from 'react';\n\n    // Define the state structure for our context\n    type PrivmxState = {\n        client: PrivmxClient | null;\n        threadId?: string;\n        notes: Types.Message[];\n    };\n\n    // Define possible actions for our reducer\n    type PrivmxAction =\n        | { type: 'SET_CLIENT'; payload: PrivmxClient }\n        | { type: 'SET_THREAD_ID'; payload: string }\n        | { type: 'SET_NOTES'; payload: Types.Message[] }",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/next/app/05-sign-in.mdx",
        "type": "mdx",
        "chunkIndex": 1,
        "headers": [
          "Overview"
        ],
        "title": "Overview",
        "lastModified": "2025-06-05T19:33:57.887Z",
        "size": 1092
      }
    },
    {
      "pageContent": "const initialState: PrivmxState = {\n        client: null,\n        threadId: undefined,\n        notes: []\n    };",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/next/app/05-sign-in.mdx",
        "type": "mdx",
        "chunkIndex": 2,
        "lastModified": "2025-06-05T19:33:57.887Z",
        "size": 111
      }
    },
    {
      "pageContent": "```\n\n    The reducer function handles state updates based on dispatched actions:\n    ```ts title=\"context/PrivmxContext.tsx\"\n\n    // Reducer to handle state updates\n    function privmxReducer(state: PrivmxState, action: PrivmxAction): PrivmxState {\n        switch (action.type) {\n            case 'SET_CLIENT':\n                return { ...state, client: action.payload };\n            case 'SET_THREAD_ID':\n                return { ...state, threadId: action.payload };\n            case 'SET_NOTES':\n                return { ...state, notes: action.payload };\n            default:\n                return state;\n        }\n    }",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/next/app/05-sign-in.mdx",
        "type": "mdx",
        "chunkIndex": 3,
        "codeBlocks": [
          "```\n\n    The reducer function handles state updates based on dispatched actions:\n    ```"
        ],
        "lastModified": "2025-06-05T19:33:57.887Z",
        "size": 625
      }
    },
    {
      "pageContent": "```\n\n    Now let's create the context and provider component:\n\n    ```ts title=\"context/PrivmxContext.tsx\"\n    // Create the context with default values\n    const PrivmxContext = createContext<{\n        client: PrivmxClient | null;\n        setConnection: (client: PrivmxClient) => void;\n        setThreadId: (threadId: string) => void;\n        threadId?: string;\n        notes?: Types.Message[];\n    }>({\n        client: null,\n        setConnection: () => {},\n        setThreadId: () => {}\n    });\n\n    // Custom hook for easy context consumption\n    export const usePrivmxContext = () => {\n        const ctx = useContext(PrivmxContext);\n\n        if (!ctx) {\n            throw new Error('usePrivmxContext can only be use inside a PrivmxProvider');\n        }\n\n        return ctx;\n    };\n\n    export const PrivmxProvider = ({ children }: { children: ReactNode }) => {\n        const [state, dispatch] = useReducer(privmxReducer, initialState);\n\n        useEffect(() => {\n            PrivmxClient.setup('/privmx-assets');\n        }, []);\n\n        const setConnection = (client: PrivmxClient) => {\n            dispatch({ type: 'SET_CLIENT', payload: client });\n        };",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/next/app/05-sign-in.mdx",
        "type": "mdx",
        "chunkIndex": 4,
        "codeBlocks": [
          "```\n\n    Now let's create the context and provider component:\n\n    ```"
        ],
        "lastModified": "2025-06-05T19:33:57.887Z",
        "size": 1166
      }
    },
    {
      "pageContent": "const setConnection = (client: PrivmxClient) => {\n            dispatch({ type: 'SET_CLIENT', payload: client });\n        };\n\n        const setThreadId = (threadId: string) => {\n            dispatch({ type: 'SET_THREAD_ID', payload: threadId });\n        };\n\n        useEffect(() => {\n            (async () => {\n                if (state.threadId && state.client) {\n                    // Fetch all notes\n                    const threadApi = await state.client.getThreadApi();\n                    const messages = await threadApi.listMessages(state.threadId, {\n                        limit: 100,\n                        skip: 0,\n                        sortOrder: 'desc'\n                    });\n                    dispatch({ type: 'SET_NOTES', payload: messages.readItems });\n                }\n            })();\n        }, [state.threadId, state.client]);",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/next/app/05-sign-in.mdx",
        "type": "mdx",
        "chunkIndex": 5,
        "lastModified": "2025-06-05T19:33:57.887Z",
        "size": 856
      }
    },
    {
      "pageContent": "return (\n            <PrivmxContext.Provider\n                value={{\n                    client: state.client,\n                    setConnection,\n                    setThreadId,\n                    threadId: state.threadId,\n                    notes: state.notes\n                }}>\n                {children}\n            </PrivmxContext.Provider>\n        );\n    };",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/next/app/05-sign-in.mdx",
        "type": "mdx",
        "chunkIndex": 6,
        "lastModified": "2025-06-05T19:33:57.887Z",
        "size": 367
      }
    },
    {
      "pageContent": "```\n\n    <div className=\"fd-step\">\n        Set Up the Provider in Your Layout\n    </div>\n\n    Wrap your application with the PrivmxProvider to make the context available throughout:\n\n    ```ts title=\"app/layout.tsx\"\n    import type { Metadata } from 'next';\n    import { Geist, Geist_Mono } from 'next/font/google';\n    import './globals.css';\n    import { PrivmxProvider } from '../context/PrivmxContext';\n\n    const geistSans = Geist({\n        variable: '--font-geist-sans',\n        subsets: ['latin']\n    });\n\n    const geistMono = Geist_Mono({\n        variable: '--font-geist-mono',\n        subsets: ['latin']\n    });\n\n    export const metadata: Metadata = {\n        title: 'Simple notes app',\n    };\n\n    export default function RootLayout({\n        children\n    }: Readonly<{\n        children: React.ReactNode;\n    }>) {\n        return (\n            <html lang=\"en\">\n                <body className={`${geistSans.variable} ${geistMono.variable} antialiased`}>\n                    <PrivmxProvider>{children}</PrivmxProvider> // [!code highlight]\n                </body>\n            </html>\n        );\n    }",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/next/app/05-sign-in.mdx",
        "type": "mdx",
        "chunkIndex": 7,
        "codeBlocks": [
          "```\n\n    <div className=\"fd-step\">\n        Set Up the Provider in Your Layout\n    </div>\n\n    Wrap your application with the PrivmxProvider to make the context available throughout:\n\n    ```"
        ],
        "lastModified": "2025-06-05T19:33:57.887Z",
        "size": 1111
      }
    },
    {
      "pageContent": "```\n\n    <div className=\"fd-step\">\n       **Create a Sign-In Hook**\n    </div>\n\n\n    Next, we'll create a custom hook to handle the sign-in process:\n    ```ts title=\"hooks/useSignIn.ts\"\n\n    'use client';\n\n    import { usePrivmxContext } from '@/context/PrivmxContext';\n    import { PrivmxClient } from '@/lib/PrivmxClient';\n    import { useState } from 'react';\n\n    interface DefaultState {\n        type: 'default';\n    }\n\n    interface LoadingState {\n        type: 'loading';\n    }\n\n    interface ErrorState {\n        type: 'error';\n        message: string;\n    }\n\n    interface SuccessState {\n        type: 'success';\n        message: string;\n    }\n\n    type FormState = DefaultState | LoadingState | ErrorState | SuccessState;",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/next/app/05-sign-in.mdx",
        "type": "mdx",
        "chunkIndex": 8,
        "codeBlocks": [
          "```\n\n    <div className=\"fd-step\">\n       **Create a Sign-In Hook**\n    </div>\n\n\n    Next, we'll create a custom hook to handle the sign-in process:\n    ```"
        ],
        "lastModified": "2025-06-05T19:33:57.887Z",
        "size": 731
      }
    },
    {
      "pageContent": "```\n\n    Now let's implement the actual hook functionality:\n\n    ```ts title=\"hooks/useSignIn.ts\"\n\n    export function useSignIn() {\n        const [status, setStatus] = useState<FormState>({ type: 'default' });\n        const { setConnection, setThreadId } = usePrivmxContext();\n\n        const signIn = async (username: string, password: string) => {\n            setStatus({ type: 'loading' });\n            try {\n                 // Step 1: Create private key based on user credentials\n                const cryptoApi = await PrivmxClient.getCryptoApi();\n                const privateKey = await cryptoApi.derivePrivateKey2(username, password);\n\n                // Step 2: Connect to the PrivMX Bridge\n                const connection = await PrivmxClient.connect(\n                    privateKey,\n                    process.env.NEXT_PUBLIC_SOLUTION_ID!,\n                    process.env.NEXT_PUBLIC_BRIDGE_URL!\n                );\n\n                // Step 3: Update application state with the new connection\n                setStatus({ type: 'success', message: 'Sign-up successful!' });\n                setConnection(connection);",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/next/app/05-sign-in.mdx",
        "type": "mdx",
        "chunkIndex": 9,
        "codeBlocks": [
          "```\n\n    Now let's implement the actual hook functionality:\n\n    ```"
        ],
        "lastModified": "2025-06-05T19:33:57.887Z",
        "size": 1128
      }
    },
    {
      "pageContent": "// Step 3: Update application state with the new connection\n                setStatus({ type: 'success', message: 'Sign-up successful!' });\n                setConnection(connection);\n\n                // Step 4: List available threads\n                const threadApi = await connection.getThreadApi();\n                const threads = await threadApi.listThreads(process.env.NEXT_PUBLIC_CONTEXT_ID!, {\n                    limit: 10,\n                    skip: 0,\n                    sortOrder: 'desc'\n                });",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/next/app/05-sign-in.mdx",
        "type": "mdx",
        "chunkIndex": 10,
        "lastModified": "2025-06-05T19:33:57.887Z",
        "size": 517
      }
    },
    {
      "pageContent": "// Step 5: Either create a new thread or use an existing one\n                if (threads.totalAvailable === 0) {\n                    // If no threads exist, create a new one\n                    const userPubKey = await cryptoApi.derivePublicKey(privateKey);\n                    const threadId = await threadApi.createThread(\n                        process.env.NEXT_PUBLIC_CONTEXT_ID!,\n                        [\n                            {\n                                userId: username,\n                                pubKey: userPubKey\n                            }\n                        ],\n                        [\n                            {\n                                userId: username,\n                                pubKey: userPubKey\n                            }\n                        ],\n                        new Uint8Array(),\n                        new Uint8Array()\n                    );",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/next/app/05-sign-in.mdx",
        "type": "mdx",
        "chunkIndex": 11,
        "lastModified": "2025-06-05T19:33:57.887Z",
        "size": 919
      }
    },
    {
      "pageContent": "setThreadId(threadId);\n                } else {\n                      // If a thread already exists, use the first one\n                    setThreadId(threads.readItems[0].threadId);\n                }\n            } catch (e) {\n                console.error(e);\n                setStatus({\n                    type: 'error',\n                    message: e as string\n                });\n            }\n        };\n\n        return { signIn, status };\n    }",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/next/app/05-sign-in.mdx",
        "type": "mdx",
        "chunkIndex": 12,
        "lastModified": "2025-06-05T19:33:57.887Z",
        "size": 451
      }
    },
    {
      "pageContent": "```\n\n\n  <div className=\"fd-step\">\n  **Create the Sign-In Form Component**\n  </div>\n\n    Now let's create the UI component that users will interact with:\n\n  ```tsx title=\"components/SignInForm.tsx\"\n  'use client';\n\n  import { useSignIn } from '@/hooks/useSignIn';\n  import Link from 'next/link';\n  import { useState } from 'react';\n\n  export function SignInForm() {\n        // Use our custom hook for sign-in functionality\n        const { signIn, status } = useSignIn();\n\n        // Local state for form inputs\n\n        const [formState, setFormState] = useState<{\n            username: string;\n            password: string;\n        }>({\n            username: '',\n            password: ''\n        });\n\n        // Handle input changes\n        const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n            const { name, value } = e.target;\n            setFormState((prevState) => ({\n                ...prevState,\n                [name]: value\n            }));\n        };\n\n        // Handle form submission\n        const handleSubmit = async (e: React.FormEvent) => {\n            e.preventDefault();\n            await signIn(formState.username, formState.password);\n        };",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/next/app/05-sign-in.mdx",
        "type": "mdx",
        "chunkIndex": 13,
        "codeBlocks": [
          "```\n\n\n  <div className=\"fd-step\">\n  **Create the Sign-In Form Component**\n  </div>\n\n    Now let's create the UI component that users will interact with:\n\n  ```"
        ],
        "lastModified": "2025-06-05T19:33:57.887Z",
        "size": 1189
      }
    },
    {
      "pageContent": "```\n\n    Now let's implement the form UI:\n\n    ```tsx title=\"components/SignInForm.tsx\"",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/next/app/05-sign-in.mdx",
        "type": "mdx",
        "chunkIndex": 14,
        "codeBlocks": [
          "```\n\n    Now let's implement the form UI:\n\n    ```"
        ],
        "lastModified": "2025-06-05T19:33:57.887Z",
        "size": 87
      }
    },
    {
      "pageContent": "return (\n          <div className=\"w-full max-w-md rounded-lg bg-white p-8 shadow-lg\">\n              <div className=\"mb-6\">\n                  <h2 className=\"text-2xl font-bold text-gray-900\">Sign in to your account</h2>\n                  <p className=\"mt-1 text-sm text-gray-600\">\n                      Enter your details below to sign in to your account\n                  </p>\n              </div>\n              <form className=\"space-y-4\" onSubmit={handleSubmit}>\n                  <div>\n                      <label htmlFor=\"username\" className=\"block text-sm font-medium text-gray-700\">\n                          Username\n                      </label>\n                      <input\n                          id=\"username\"\n                          name=\"username\"\n                          type=\"text\"\n                          placeholder=\"Username\"\n                          required\n                          className=\"mt-1 block w-full rounded-md border border-gray-300 px-3 py-2 text-gray-900 shadow-sm focus:border-blue-500 focus:outline-none focus:ring-1 focus:ring-blue-500\"\n                          value={formState.username}\n                          onChange={handleChange}",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/next/app/05-sign-in.mdx",
        "type": "mdx",
        "chunkIndex": 15,
        "lastModified": "2025-06-05T19:33:57.887Z",
        "size": 1190
      }
    },
    {
      "pageContent": "value={formState.username}\n                          onChange={handleChange}\n                      />\n                  </div>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/next/app/05-sign-in.mdx",
        "type": "mdx",
        "chunkIndex": 16,
        "lastModified": "2025-06-05T19:33:57.887Z",
        "size": 126
      }
    },
    {
      "pageContent": "<div>\n                      <label htmlFor=\"password\" className=\"block text-sm font-medium text-gray-700\">\n                          Password\n                      </label>\n                      <input\n                          id=\"password\"\n                          name=\"password\"\n                          type=\"password\"\n                          placeholder=\"*******\"\n                          required\n                          className=\"mt-1 block w-full rounded-md border border-gray-300 px-3 py-2 text-gray-900 shadow-sm focus:border-blue-500 focus:outline-none focus:ring-1 focus:ring-blue-500\"\n                          value={formState.password}\n                          onChange={handleChange}\n                      />\n                  </div>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/next/app/05-sign-in.mdx",
        "type": "mdx",
        "chunkIndex": 17,
        "lastModified": "2025-06-05T19:33:57.887Z",
        "size": 759
      }
    },
    {
      "pageContent": "<button\n                      type=\"submit\"\n                      className=\"mt-6 w-full rounded-md bg-blue-600 px-4 py-2 text-sm font-medium text-white hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2\"\n                      disabled={status.type === 'loading'}>\n                      {status.type === 'loading' ? 'Signing Up...' : 'Sign Up'}\n                  </button>\n\n                  {status.type === 'error' && (\n                      <p className=\"text-red-500\">{status.message || 'Error signing up'}</p>\n                  )}\n\n                  {status.type === 'success' && (\n                      <p className=\"text-green-500\">{status.message || 'Successfully signed up!'}</p>\n                  )}\n              </form>\n              <p className=\"mt-4 text-center text-sm text-gray-600\">\n                  Not a member?{' '}\n                  <Link href=\"/sign-up\" className=\"font-medium text-blue-600 hover:text-blue-500\">\n                      Sign up now\n                  </Link>\n              </p>\n          </div>\n      );\n  }",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/next/app/05-sign-in.mdx",
        "type": "mdx",
        "chunkIndex": 18,
        "lastModified": "2025-06-05T19:33:57.887Z",
        "size": 1084
      }
    },
    {
      "pageContent": "```\n\n  <div className=\"fd-step\">\n    Use the Sign-In Form on Your Home Page\n  </div>\n\n    Finally, add the sign-in form to your home page:\n\n    ```ts title=\"app/page.tsx\"\n    'use client';\n    import { SignInForm } from '@/components/SignInForm';\n    import { usePrivmxContext } from '../context/PrivmxContext';\n\n    export default function Page() {\n        const { client } = usePrivmxContext();\n        return (\n            <div className=\"flex min-h-screen items-center justify-center bg-gray-50 p-4 text-gray-900\">\n                {client === null ? <SignInForm /> : 'Connected'}\n            </div>\n        );\n    }\n    ```\n</div>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/next/app/05-sign-in.mdx",
        "type": "mdx",
        "chunkIndex": 19,
        "codeBlocks": [
          "```\n\n  <div className=\"fd-step\">\n    Use the Sign-In Form on Your Home Page\n  </div>\n\n    Finally, add the sign-in form to your home page:\n\n    ```"
        ],
        "lastModified": "2025-06-05T19:33:57.887Z",
        "size": 634
      }
    },
    {
      "pageContent": "### Key Concepts\n\n1. **Context Management**: The PrivmxContext provides application-wide state management for user authentication.\n2. **Custom Hooks**: The useSignIn hook encapsulates all authentication logic, making it reusable across the application.\n3. **Form State Handling**: The form tracks multiple states (loading, error, success) to provide feedback to users.\n4. **Thread Management**: Upon successful authentication, the application either creates a new thread or uses an existing one.\n5. **User Experience**: The sign-in form includes appropriate loading states, error messages, and a link to sign up.\n\n\n### Implementation Flow\n\n1. User enters username and password\n2. The application derives a private key from these credentials\n3. It establishes a connection with the PrivMX service\n4. It retrieves or creates a thread for the user\n5. It updates the application state with the connection and thread information\n6. The UI reflects the authenticated state",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/next/app/05-sign-in.mdx",
        "type": "mdx",
        "chunkIndex": 20,
        "headers": [
          "Key Concepts",
          "Implementation Flow"
        ],
        "title": "Key Concepts",
        "lastModified": "2025-06-05T19:33:57.887Z",
        "size": 966
      }
    },
    {
      "pageContent": "---\ntitle: Setup events\ndescription: This guide will walk you through how to implement real-time event handling in your application using the PrivmxClient.\nfull: false\n---",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/next/app/06-setup-events.mdx",
        "type": "mdx",
        "chunkIndex": 0,
        "lastModified": "2025-06-05T19:33:57.888Z",
        "size": 171
      }
    },
    {
      "pageContent": "## Overview\nWhen building interactive applications, you need a way to respond to changes that happen in real-time, such as:\n- New messages being created\n- Existing messages being updated\n- Messages being deleted\n\nThis guide shows you how to set up event listeners to keep your UI in sync with these changes.\n\n<div className=\"fd-steps\">\n  <div className=\"fd-step\">\n    Extend the Reducer with New Actions\n    </div>\n\n    First, we need to extend our reducer to handle the new events:\n\n    ```ts title=\"context/PrivmxContext.tsx\"\n    // Define action types\n    type PrivmxAction =\n        | { type: 'SET_CLIENT'; payload: PrivmxClient }\n        | { type: 'SET_THREAD_ID'; payload: string }\n        | { type: 'SET_NOTES'; payload: Types.Message[] }\n        | { type: 'ADD_MESSAGE'; payload: Types.Message } // [!code highlight]\n        | { type: 'UPDATE_MESSAGE'; payload: Types.Message } // [!code highlight]\n        | { type: 'DELETE_MESSAGE'; payload: { messageId: string } }; // [!code highlight]",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/next/app/06-setup-events.mdx",
        "type": "mdx",
        "chunkIndex": 1,
        "headers": [
          "Overview"
        ],
        "title": "Overview",
        "lastModified": "2025-06-05T19:33:57.888Z",
        "size": 997
      }
    },
    {
      "pageContent": "```",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/next/app/06-setup-events.mdx",
        "type": "mdx",
        "chunkIndex": 2,
        "lastModified": "2025-06-05T19:33:57.888Z",
        "size": 3
      }
    },
    {
      "pageContent": "Then, modify the reducer function to handle these new action types:\n    ```ts title=\"context/PrivmxContext.tsx\"\n    // Reducer function\n    function privmxReducer(state: PrivmxState, action: PrivmxAction): PrivmxState {\n        switch (action.type) {\n            case 'SET_CLIENT':\n                return { ...state, client: action.payload };\n            case 'SET_THREAD_ID':\n                return { ...state, threadId: action.payload };\n            case 'SET_NOTES':\n                return { ...state, notes: action.payload };\n            case 'ADD_MESSAGE': // [!code highlight]\n                // [!code highlight]\n                // Add new message to the beginning of the array (for 'desc' order)\n                return { ...state, notes: [action.payload, ...state.notes] }; // [!code highlight]\n            case 'UPDATE_MESSAGE': // [!code highlight]\n                // [!code highlight]\n                // Replace the updated message\n                return { // [!code highlight] \n                    ...state, // [!code highlight]\n                    notes: state.notes.map((note) => // [!code highlight]",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/next/app/06-setup-events.mdx",
        "type": "mdx",
        "chunkIndex": 3,
        "lastModified": "2025-06-05T19:33:57.888Z",
        "size": 1114
      }
    },
    {
      "pageContent": "return { // [!code highlight] \n                    ...state, // [!code highlight]\n                    notes: state.notes.map((note) => // [!code highlight]\n                        note.info.messageId === action.payload.info.messageId ? action.payload : note // [!code highlight] \n                    ) // [!code highlight]\n                }; // [!code highlight]\n            case 'DELETE_MESSAGE': // [!code highlight]\n            // [!code highlight]\n            // Remove the deleted message\n                return { // [!code highlight]\n                    ...state, // [!code highlight] \n                    notes: state.notes.filter( // [!code highlight]\n                        (note) => note.info.messageId !== action.payload.messageId // [!code highlight]\n                    ) // [!code highlight]\n                }; // [!code highlight]\n            default: \n                return state;\n        }\n    }",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/next/app/06-setup-events.mdx",
        "type": "mdx",
        "chunkIndex": 4,
        "lastModified": "2025-06-05T19:33:57.888Z",
        "size": 914
      }
    },
    {
      "pageContent": "```\n\n    <div className=\"fd-step\">\n    Manage Event Listeners\n    </div>\n    Now, let's modify the PrivmxProvider to handle event registration and cleanup:\n\n    ```ts title=\"context/PrivmxContext.tsx\"\n    export const PrivmxProvider = ({ children }: { children: ReactNode }) => {\n        const [state, dispatch] = useReducer(privmxReducer, initialState);\n\n        // [!code highlight]\n        // Keep track of cleanup functions for event listeners\n        // [!code highlight]\n        // This will help us properly remove listeners when needed\n        const cleanupListenersRef = useRef<Array<() => Promise<void>>>([]);  // [!code highlight]",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/next/app/06-setup-events.mdx",
        "type": "mdx",
        "chunkIndex": 5,
        "codeBlocks": [
          "```\n\n    <div className=\"fd-step\">\n    Manage Event Listeners\n    </div>\n    Now, let's modify the PrivmxProvider to handle event registration and cleanup:\n\n    ```"
        ],
        "lastModified": "2025-06-05T19:33:57.888Z",
        "size": 641
      }
    },
    {
      "pageContent": "// [!code highlight]\n        // Initialize PrivmxClient and set up cleanup on unmount\n        useEffect(() => {\n            PrivmxClient.setup('/privmx-assets');\n            // [!code highlight]\n            // Cleanup listeners on unmount \n            return () => { // [!code highlight]\n                cleanupListenersRef.current.forEach((cleanup) => cleanup()); // [!code highlight] \n                cleanupListenersRef.current = []; // [!code highlight]\n            };\n        }, []);\n    ```\n    <div className=\"fd-step\">\n    Update Connection Methods\n    </div>\n    Modify the connection methods to handle cleanup when connections change:\n\n    ```ts title=\"context/PrivmxContext.tsx\"\n\n        const setConnection = (client: PrivmxClient) => {\n            dispatch({ type: 'SET_CLIENT', payload: client });\n        };",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/next/app/06-setup-events.mdx",
        "type": "mdx",
        "chunkIndex": 6,
        "codeBlocks": [
          "```\n    <div className=\"fd-step\">\n    Update Connection Methods\n    </div>\n    Modify the connection methods to handle cleanup when connections change:\n\n    ```"
        ],
        "lastModified": "2025-06-05T19:33:57.888Z",
        "size": 822
      }
    },
    {
      "pageContent": "```ts title=\"context/PrivmxContext.tsx\"\n\n        const setConnection = (client: PrivmxClient) => {\n            dispatch({ type: 'SET_CLIENT', payload: client });\n        };\n\n        const setThreadId = (threadId: string) => {\n            dispatch({ type: 'SET_THREAD_ID', payload: threadId });\n            // [!code highlight]\n            // Cleanup existing listeners when thread changes \n            cleanupListenersRef.current.forEach((cleanup) => cleanup()); // [!code highlight]\n            cleanupListenersRef.current = []; // [!code highlight]\n        };\n    ```\n    <div className=\"fd-step\">\n    Implement the Event Setup Logic\n    </div>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/next/app/06-setup-events.mdx",
        "type": "mdx",
        "chunkIndex": 7,
        "codeBlocks": [
          "```ts title=\"context/PrivmxContext.tsx\"\n\n        const setConnection = (client: PrivmxClient) => {\n            dispatch({ type: 'SET_CLIENT', payload: client });\n        };\n\n        const setThreadId = (threadId: string) => {\n            dispatch({ type: 'SET_THREAD_ID', payload: threadId });\n            // [!code highlight]\n            // Cleanup existing listeners when thread changes \n            cleanupListenersRef.current.forEach((cleanup) => cleanup()); // [!code highlight]\n            cleanupListenersRef.current = []; // [!code highlight]\n        };\n    ```"
        ],
        "lastModified": "2025-06-05T19:33:57.888Z",
        "size": 646
      }
    },
    {
      "pageContent": "Create a function to set up all the event listeners we need:\n    ```ts title=\"context/PrivmxContext.tsx\"\n        useEffect(() => { \n            (async () => {\n                if (state.threadId && state.client) {\n                    const threadApi = await state.client.getThreadApi();\n                    const messages = await threadApi.listMessages(state.threadId, {\n                        limit: 100,\n                        skip: 0,\n                        sortOrder: 'desc'\n                    });\n                    dispatch({ type: 'SET_NOTES', payload: messages.readItems });\n                    // [!code highlight]\n                    // Setup event listeners \n                    setupEvents(state.client, state.threadId); // [!code highlight]\n                }\n            })();\n        }, [state.threadId, state.client]);",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/next/app/06-setup-events.mdx",
        "type": "mdx",
        "chunkIndex": 8,
        "lastModified": "2025-06-05T19:33:57.888Z",
        "size": 837
      }
    },
    {
      "pageContent": "```",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/next/app/06-setup-events.mdx",
        "type": "mdx",
        "chunkIndex": 9,
        "lastModified": "2025-06-05T19:33:57.888Z",
        "size": 3
      }
    },
    {
      "pageContent": "Now, implement the `setupEvents` function that will register all event listeners:\n    ```ts title=\"context/PrivmxContext.tsx\"\n        const setupEvents = async (client: PrivmxClient, threadId: string) => { \n            const threadEvents = await client.getThreadEventManager(); \n            // Creates a event listener for threadNewMessage event\n            const removeNewMessageListener = await threadEvents.onMessageEvent(threadId, { \n                event: 'threadNewMessage',\n                callback: (event) => { \n                    const message = event.data; \n                    dispatch({ type: 'ADD_MESSAGE', payload: message }); \n                } \n            });\n            // Creates a new event listener for threadMessageUpdated \n            const removeUpdatedMessageListener = await threadEvents.onMessageEvent(threadId, { \n                event: 'threadMessageUpdated', \n                callback: (event) => {\n                    const message = event.data; // [!code highlight\n                    dispatch({ type: 'UPDATE_MESSAGE', payload: message }); \n                } \n            }); \n            // Creates a new event listener for threadMessageDeleted",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/next/app/06-setup-events.mdx",
        "type": "mdx",
        "chunkIndex": 10,
        "lastModified": "2025-06-05T19:33:57.888Z",
        "size": 1181
      }
    },
    {
      "pageContent": "dispatch({ type: 'UPDATE_MESSAGE', payload: message }); \n                } \n            }); \n            // Creates a new event listener for threadMessageDeleted \n            const removeDeletedMessageListener = await threadEvents.onMessageEvent(threadId, { \n                event: 'threadMessageDeleted', \n                callback: (event) => { \n                    const messageId = event.data.messageId; \n                    dispatch({ type: 'DELETE_MESSAGE', payload: { messageId } }); \n                }\n            }); \n            // Store cleanup functions to remove listeners later \n            cleanupListenersRef.current = [ \n                removeNewMessageListener, \n                removeUpdatedMessageListener, \n                removeDeletedMessageListener\n            ]; \n        }; \n    ```\n</div>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/next/app/06-setup-events.mdx",
        "type": "mdx",
        "chunkIndex": 11,
        "lastModified": "2025-06-05T19:33:57.888Z",
        "size": 814
      }
    },
    {
      "pageContent": "## How the Event System Works\n\n1. **Event Registration**: When a client connects to a thread, we register listeners for all relevant events (new messages, updates, deletions).\n2. **Event Handling**: Each event type has a specific callback that dispatches the appropriate action to update our application state.\n3. **State Updates**: The reducer handles each event by updating the state in the appropriate way:\n    - Adding new messages to the list\n    - Replacing updated messages\n    - Removing deleted messages\n\n## Benefits of This Approach\n\n- **Real-time Updates**: Your UI will automatically reflect changes as they happen\n- **Optimized Rendering**: State updates trigger UI re-renders only when needed\n- **Consistent State**: The reducer ensures state updates follow a predictable pattern",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/next/app/06-setup-events.mdx",
        "type": "mdx",
        "chunkIndex": 12,
        "headers": [
          "How the Event System Works",
          "Benefits of This Approach"
        ],
        "title": "How the Event System Works",
        "lastModified": "2025-06-05T19:33:57.888Z",
        "size": 793
      }
    },
    {
      "pageContent": "---\ntitle: Handling notes\ndescription: This part will walk you through creating, updating and deleting notes\nfull: false\n---\nimport { Tabs, Tab } from 'fumadocs-ui/components/tabs';\n\n<div className=\"flex items-center justify-center\">\n  ![Notes](./notes.png)\n</div>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/next/app/07-list-notes.mdx",
        "type": "mdx",
        "chunkIndex": 0,
        "lastModified": "2025-06-05T19:33:57.888Z",
        "size": 264
      }
    },
    {
      "pageContent": "## Overview\nThe notes functionality allows users to:\n\n- Create new notes with title and content\n- View a list of existing notes\n- Edit note titles and content\n- Delete unwanted notes\n\n<div className=\"fd-steps\">\n  <div className=\"fd-step\">\n  Create Components for Note Handling\n  </div>\n\n  We'll create four main components to handle different aspects of note management:\n\n  1. **NewNoteForm**: For creating new notes\n  2. **EditNoteForm**: For modifying existing notes\n  3. **NoteDisplay**: For displaying individual notes\n  4. **NoteList**: The main component that manages all note operations\n\n  <div className=\"fd-step\">\n  Create the NewNoteForm Component\n  </div>\n\n  This component provides a form for creating new notes with a title and content.\n\n   ```ts title=\"components/NewNoteForm.tsx\"\n    import { useState } from 'react';",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/next/app/07-list-notes.mdx",
        "type": "mdx",
        "chunkIndex": 1,
        "headers": [
          "Overview"
        ],
        "title": "Overview",
        "lastModified": "2025-06-05T19:33:57.888Z",
        "size": 832
      }
    },
    {
      "pageContent": "This component provides a form for creating new notes with a title and content.\n\n   ```ts title=\"components/NewNoteForm.tsx\"\n    import { useState } from 'react';\n\n    export function NewNoteForm({\n        onCreate,\n        onCancel,\n        loading\n    }: {\n        onCreate: (title: string, content: string) => void;\n        onCancel: () => void;\n        loading: boolean;\n    }) {\n        // State for tracking form inputs\n        const [newNoteText, setNewNoteText] = useState('');\n        const [newNoteContent, setNewNoteContent] = useState('');\n\n        const handleCreate = () => {\n            onCreate(newNoteText.trim(), newNoteContent.trim());\n\n            // Reset form after submission\n            setNewNoteText('');\n            setNewNoteContent('');\n        };",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/next/app/07-list-notes.mdx",
        "type": "mdx",
        "chunkIndex": 2,
        "lastModified": "2025-06-05T19:33:57.888Z",
        "size": 776
      }
    },
    {
      "pageContent": "return (\n            <div className=\"mb-6 p-4 border rounded shadow-sm\">\n                <input\n                    type=\"text\"\n                    className=\"w-full p-2 border rounded mb-2\"\n                    placeholder=\"Enter your note title...\"\n                    value={newNoteText}\n                    onChange={(e) => setNewNoteText(e.target.value)}\n                />\n                <textarea\n                    className=\"w-full h-32 p-2 border rounded mb-4\"\n                    placeholder=\"Enter your note content...\"\n                    value={newNoteContent}\n                    onChange={(e) => setNewNoteContent(e.target.value)}\n                />\n                <div className=\"flex justify-end gap-2\">\n                    <button\n                        onClick={onCancel}\n                        className=\"px-3 py-1 border rounded hover:bg-gray-100\"\n                        disabled={loading}>\n                        Cancel\n                    </button>\n                    <button\n                        onClick={handleCreate}\n                        className=\"px-3 py-1 bg-green-600 text-white rounded hover:bg-green-700\"",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/next/app/07-list-notes.mdx",
        "type": "mdx",
        "chunkIndex": 3,
        "lastModified": "2025-06-05T19:33:57.888Z",
        "size": 1150
      }
    },
    {
      "pageContent": "<button\n                        onClick={handleCreate}\n                        className=\"px-3 py-1 bg-green-600 text-white rounded hover:bg-green-700\"\n                        disabled={loading || !newNoteText.trim()}>\n                        {loading ? 'Saving...' : 'Save Note'}\n                    </button>\n                </div>\n            </div>\n        );\n    }",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/next/app/07-list-notes.mdx",
        "type": "mdx",
        "chunkIndex": 4,
        "lastModified": "2025-06-05T19:33:57.888Z",
        "size": 369
      }
    },
    {
      "pageContent": "```\n\n  **Key poin ts about NewNoteForm:**\n  - Uses React state to track title and content inputs\n  - Disables the save button if the title is empty or while saving\n  - Shows a loading state during save operations\n  - Provides cancel functionality to exit note creation\n\n\n  <div className=\"fd-step\">\n  Create the EditNoteForm Component\n  </div>\n  This component allows users to modify existing notes.\n\n   ```ts title=\"components/EditNoteForm.tsx\"\n    import { Types } from '@simplito/privmx-webendpoint';\n    import { Utils } from '@simplito/privmx-webendpoint/extra';\n    import { useState } from 'react';\n\n    export function NoteEditForm({\n      note,\n      onSave,\n      onCancel,\n      loading\n    }: {\n      note: Types.Message;\n      onSave: (messageId: string, title: string, content: string) => void;\n      onCancel: () => void;\n      loading: boolean;\n    }) {\n      // Initialize form with existing note data\n      const [editTitle, setEditTitle] = useState(Utils.deserializeObject(note.privateMeta).title);\n      const [editContent, setEditContent] = useState(Utils.deserializeObject(note.data).content);",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/next/app/07-list-notes.mdx",
        "type": "mdx",
        "chunkIndex": 5,
        "codeBlocks": [
          "```\n\n  **Key poin ts about NewNoteForm:**\n  - Uses React state to track title and content inputs\n  - Disables the save button if the title is empty or while saving\n  - Shows a loading state during save operations\n  - Provides cancel functionality to exit note creation\n\n\n  <div className=\"fd-step\">\n  Create the EditNoteForm Component\n  </div>\n  This component allows users to modify existing notes.\n\n   ```"
        ],
        "lastModified": "2025-06-05T19:33:57.888Z",
        "size": 1115
      }
    },
    {
      "pageContent": "return (\n          <div className=\"space-y-2\">\n              <input\n                  type=\"text\"\n                  className=\"w-full p-2 border rounded\"\n                  value={editTitle}\n                  onChange={(e) => setEditTitle(e.target.value)}\n              />\n              <textarea\n                  className=\"w-full h-32 p-2 border rounded\"\n                  value={editContent}\n                  onChange={(e) => setEditContent(e.target.value)}\n              />\n              <div className=\"flex justify-end gap-2\">\n                  <button\n                      onClick={onCancel}\n                      className=\"px-3 py-1 border rounded hover:bg-gray-100\"\n                      disabled={loading}>\n                      Cancel\n                  </button>\n                  <button\n                      onClick={() => onSave(note.info.messageId, editTitle, editContent)}\n                      className=\"px-3 py-1 bg-green-600 text-white rounded hover:bg-green-700\"\n                      disabled={loading || !editTitle.trim()}>\n                      {loading ? 'Saving...' : 'Save Changes'}\n                  </button>\n              </div>\n          </div>\n      );",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/next/app/07-list-notes.mdx",
        "type": "mdx",
        "chunkIndex": 6,
        "lastModified": "2025-06-05T19:33:57.888Z",
        "size": 1188
      }
    },
    {
      "pageContent": "{loading ? 'Saving...' : 'Save Changes'}\n                  </button>\n              </div>\n          </div>\n      );\n    }",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/next/app/07-list-notes.mdx",
        "type": "mdx",
        "chunkIndex": 7,
        "lastModified": "2025-06-05T19:33:57.888Z",
        "size": 121
      }
    },
    {
      "pageContent": "```\n\n  **Key points about EditNoteForm:**\n  - Pre-populates form fields with existing note data\n  - Uses PrivMX's utility functions to deserialize stored data\n  - Provides similar save/cancel functionality as the new note form\n  - Validates that the title is not empty before allowing save\n\n  <div className=\"fd-step\">\n  Create the NoteDisplay Component\n  </div>\n\n  This component handles the display of individual notes.\n\n  ```ts title=\"components/NoteDisplay.tsx\"\n  import { Types } from '@simplito/privmx-webendpoint';\n  import { Utils } from '@simplito/privmx-webendpoint/extra';\n\n  export function NoteDisplay({\n    note,\n    onEdit,\n    onDelete\n  }: {\n    note: Types.Message;\n    onEdit: (note: Types.Message) => void;\n    onDelete: (messageId: string) => void;\n  }) {\n    // Extract note data from PrivMX message format\n    const title = Utils.deserializeObject(note.privateMeta).title;\n    const content = Utils.deserializeObject(note.data).content;",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/next/app/07-list-notes.mdx",
        "type": "mdx",
        "chunkIndex": 8,
        "codeBlocks": [
          "```\n\n  **Key points about EditNoteForm:**\n  - Pre-populates form fields with existing note data\n  - Uses PrivMX's utility functions to deserialize stored data\n  - Provides similar save/cancel functionality as the new note form\n  - Validates that the title is not empty before allowing save\n\n  <div className=\"fd-step\">\n  Create the NoteDisplay Component\n  </div>\n\n  This component handles the display of individual notes.\n\n  ```"
        ],
        "lastModified": "2025-06-05T19:33:57.889Z",
        "size": 959
      }
    },
    {
      "pageContent": "return (\n        <>\n            <div className=\"flex justify-between items-start mb-2\">\n                <h3 className=\"text-lg font-semibold\">{title}</h3>\n                <div className=\"text-sm text-gray-500\">\n                    {new Date(note.info.createDate).toLocaleString()}\n                </div>\n            </div>\n            <div className=\"mb-4 prose max-w-none\">\n                <p>{content}</p>\n            </div>\n            <div className=\"flex justify-end gap-2\">\n                <button\n                    onClick={() => onEdit(note)}\n                    className=\"px-3 py-1 text-blue-600 hover:bg-blue-50 rounded\">\n                    Edit\n                </button>\n                <button\n                    onClick={() => onDelete(note.info.messageId)}\n                    className=\"px-3 py-1 text-red-600 hover:bg-red-50 rounded\">\n                    Delete\n                </button>\n            </div>\n        </>\n    );\n  }\n  ```\n  **Key points about NoteDisplay:**",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/next/app/07-list-notes.mdx",
        "type": "mdx",
        "chunkIndex": 9,
        "lastModified": "2025-06-05T19:33:57.889Z",
        "size": 992
      }
    },
    {
      "pageContent": "- Displays the note title, content, and creation timestamp\n  - Provides edit and delete buttons for note management\n  - Uses PrivMX utilities to extract data from the message format\n  - Formats the creation date for better readability\n\n\n  <div className=\"fd-step\">\n  Create the NoteList Component\n  </div>\n\n  This is the main component that brings everything together and manages all note operations.\n\n  ```ts title=\"components/NoteList.tsx\"\n  // Part 1: Imports and component setup\n\n  import { usePrivmxContext } from '@/context/PrivmxContext';\n  import { Utils } from '@simplito/privmx-webendpoint/extra';\n  import { useState } from 'react';\n  import { NewNoteForm } from './NewNoteForm';\n  import { NoteEditForm } from './EditNoteForm';\n  import { NoteDisplay } from './NoteDisplay';\n\n  export default function NoteList() {\n    // Get PrivMX context data\n    const { client, notes, threadId } = usePrivmxContext();\n\n    // Component state\n    const [isCreating, setIsCreating] = useState(false);\n    const [loading, setLoading] = useState(false);\n    const [editingNote, setEditingNote] = useState<string | null>(null);",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/next/app/07-list-notes.mdx",
        "type": "mdx",
        "chunkIndex": 10,
        "lastModified": "2025-06-05T19:33:57.889Z",
        "size": 1122
      }
    },
    {
      "pageContent": "```\n\n  This first part sets up the component with necessary imports and state variables:\n\n  - `isCreating`: Tracks if the new note form should be displayed\n  - `loading`: Manages loading state during API operations\n  - `editingNote`: Tracks which note is currently being edited (if any)\n\n  ```ts title=\"components/NoteList.tsx\"\n     // Part 2: Note creation function\n\n    // Create a new note\n    const createNote = async (title: string, content: string) => {\n        if (!client || !threadId || !title.trim()) {\n            return;\n        }\n\n        setLoading(true);\n        try {\n            const threadApi = await client.getThreadApi();\n            await threadApi.sendMessage(\n                threadId,\n                new Uint8Array(), // Public Meta\n                Utils.serializeObject({ title: title.trim() }), // Private Meta\n                Utils.serializeObject({ content: content.trim() }) // Data\n            );\n            setIsCreating(false);\n        } catch (error) {\n            console.error('Failed to create note:', error);\n        } finally {\n            setLoading(false);\n        }\n    };",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/next/app/07-list-notes.mdx",
        "type": "mdx",
        "chunkIndex": 11,
        "codeBlocks": [
          "```\n\n  This first part sets up the component with necessary imports and state variables:\n\n  - `isCreating`: Tracks if the new note form should be displayed\n  - `loading`: Manages loading state during API operations\n  - `editingNote`: Tracks which note is currently being edited (if any)\n\n  ```"
        ],
        "lastModified": "2025-06-05T19:33:57.889Z",
        "size": 1116
      }
    },
    {
      "pageContent": "```\n\n    The `createNote` function:\n\n    - Validates required data is available\n    - Uses the PrivMX thread API to send a new message\n    - Structures note data with title in privateMeta and content in data\n    - Handles errors and loading state\n\n    ```ts title=\"components/NoteList.tsx\"\n    // Part 3: Note deletion function\n\n    // Delete a note\n    const deleteNote = async (messageId: string) => {\n        if (!client) return;\n\n        if (window.confirm('Are you sure you want to delete this note?')) {\n            setLoading(true);\n            try {\n                const threadApi = await client.getThreadApi();\n                await threadApi.deleteMessage(messageId);\n            } catch (error) {\n                console.error('Failed to delete note:', error);\n            } finally {\n                setLoading(false);\n            }\n        }\n    };",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/next/app/07-list-notes.mdx",
        "type": "mdx",
        "chunkIndex": 12,
        "codeBlocks": [
          "```\n\n    The `createNote` function:\n\n    - Validates required data is available\n    - Uses the PrivMX thread API to send a new message\n    - Structures note data with title in privateMeta and content in data\n    - Handles errors and loading state\n\n    ```"
        ],
        "lastModified": "2025-06-05T19:33:57.889Z",
        "size": 862
      }
    },
    {
      "pageContent": "```\n\n    The `deleteNote` function:\n\n    - Confirms with the user before deletion\n    - Uses the PrivMX API to remove the message\n    - Handles errors and manages loading state\n\n    ```ts title=\"components/NoteList.tsx\"\n    //Part 4: Note update functions\n\n    // Update a note\n    const updateNote = async (messageId: string, title: string, content: string) => {\n        if (!client) return;\n        const threadApi = await client.getThreadApi();\n\n        await threadApi.updateMessage(\n            messageId,\n            new Uint8Array(),\n            Utils.serializeObject({ title }),\n            Utils.serializeObject({ content })\n        );\n    };\n\n    // Save note update\n    const saveNoteUpdate = async (messageId: string, title: string, content: string) => {\n        if (!client || !title.trim()) return;\n\n        setLoading(true);\n        try {\n            await updateNote(messageId, title, content);\n            setEditingNote(null);\n        } catch (error) {\n            console.error('Failed to update note:', error);\n        } finally {\n            setLoading(false);\n        }\n    };\n    ```\n    \n    These functions:",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/next/app/07-list-notes.mdx",
        "type": "mdx",
        "chunkIndex": 13,
        "codeBlocks": [
          "```\n\n    The `deleteNote` function:\n\n    - Confirms with the user before deletion\n    - Uses the PrivMX API to remove the message\n    - Handles errors and manages loading state\n\n    ```"
        ],
        "lastModified": "2025-06-05T19:33:57.889Z",
        "size": 1132
      }
    },
    {
      "pageContent": "- `updateNote`: Handles the core API call to update the message\n    - `saveNoteUpdate`: Provides a wrapper with validation, error handling, and state management\n\n    ```ts title=\"components/NoteList.tsx\"\n    // Part 5: Component render\n\n    return (\n        <div className=\"w-full max-w-4xl mx-auto p-4\">\n            {/* Header with title and create button */}\n            <div className=\"flex justify-between items-center mb-6\">\n                <h1 className=\"text-2xl font-bold\">Notes</h1>\n                {!isCreating && (\n                    <button\n                        onClick={() => setIsCreating(true)}\n                        className=\"px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 transition-colors\"\n                        disabled={!client || !threadId}>\n                        Create New Note\n                    </button>\n                )}\n            </div>\n\n            {/* New note form (conditionally rendered) */}\n            {isCreating && (\n                <NewNoteForm\n                    onCreate={createNote}\n                    onCancel={() => setIsCreating(false)}\n                    loading={loading}\n                />\n            )}",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/next/app/07-list-notes.mdx",
        "type": "mdx",
        "chunkIndex": 14,
        "lastModified": "2025-06-05T19:33:57.889Z",
        "size": 1181
      }
    },
    {
      "pageContent": "{/* Connection status message */}\n            {(!client || !threadId) && (\n                <div className=\"text-center p-6 bg-gray-100 rounded\">\n                    <p>Connect to a PrivMX server and select a thread to view notes.</p>\n                </div>\n            )}\n\n            {/* Empty state message */}\n            {client && threadId && notes && notes.length === 0 && (\n                <div className=\"text-center p-6 bg-gray-100 rounded\">\n                    <p>No notes found in this thread. Create your first note!</p>\n                </div>\n            )}",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/next/app/07-list-notes.mdx",
        "type": "mdx",
        "chunkIndex": 15,
        "lastModified": "2025-06-05T19:33:57.889Z",
        "size": 570
      }
    },
    {
      "pageContent": "{/* Note list */}\n            <div className=\"space-y-4\">\n                {notes?.map((note) => (\n                    <div key={note.info.messageId} className=\"p-4 border rounded shadow-sm\">\n                        {editingNote === note.info.messageId ? (\n                            <NoteEditForm\n                                note={note}\n                                onSave={saveNoteUpdate}\n                                onCancel={() => setEditingNote(null)}\n                                loading={loading}\n                            />\n                        ) : (\n                            <NoteDisplay\n                                note={note}\n                                onEdit={() => setEditingNote(note.info.messageId)}\n                                onDelete={deleteNote}\n                            />\n                        )}\n                    </div>\n                ))}\n            </div>\n        </div>\n    );\n    ```\n    The render method:",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/next/app/07-list-notes.mdx",
        "type": "mdx",
        "chunkIndex": 16,
        "lastModified": "2025-06-05T19:33:57.889Z",
        "size": 977
      }
    },
    {
      "pageContent": "- Provides a create button when not in creation mode\n  - Conditionally renders the new note form\n  - Shows appropriate status messages based on connection and note availability\n  - Renders the list of notes, each with either display or edit mode based on state\n\n  <div className=\"fd-step\">\n  Update the Home Page\n  </div>\n\n  Finally, update the main page to render the NoteList component when the user is signed in.\n\n  ```ts title=\"app/page.tsx\"\n  'use client';\n\n  import { SignInForm } from '@/components/SignInForm';\n  import { usePrivmxContext } from '../context/PrivmxContext';\n  import NoteList from '@/components/NoteList';\n\n  export default function Page() {\n      const { client } = usePrivmxContext();\n      return (\n          <div className=\"flex min-h-screen items-center justify-center bg-gray-50 p-4 text-gray-900\">\n              {client === null ? <SignInForm /> : <NoteList />} // [!code highlight]\n          </div>\n      );\n  }\n  ```\n</div>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/next/app/07-list-notes.mdx",
        "type": "mdx",
        "chunkIndex": 17,
        "codeBlocks": [
          "```ts title=\"app/page.tsx\"\n  'use client';\n\n  import { SignInForm } from '@/components/SignInForm';\n  import { usePrivmxContext } from '../context/PrivmxContext';\n  import NoteList from '@/components/NoteList';\n\n  export default function Page() {\n      const { client } = usePrivmxContext();\n      return (\n          <div className=\"flex min-h-screen items-center justify-center bg-gray-50 p-4 text-gray-900\">\n              {client === null ? <SignInForm /> : <NoteList />} // [!code highlight]\n          </div>\n      );\n  }\n  ```"
        ],
        "lastModified": "2025-06-05T19:33:57.889Z",
        "size": 956
      }
    },
    {
      "pageContent": "## Data Structure\n\nNotes in PrivMX are stored as messages with the following structure:\n- **Public Meta**: Empty (not used for notes)\n- **Private Meta**: Contains the note title as `{ title: \"Note Title\" }`\n- **Data**: Contains the note content as `{ content: \"Note content text\" }`",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/js/next/app/07-list-notes.mdx",
        "type": "mdx",
        "chunkIndex": 18,
        "headers": [
          "Data Structure"
        ],
        "title": "Data Structure",
        "lastModified": "2025-06-05T19:33:57.889Z",
        "size": 282
      }
    },
    {
      "pageContent": "---\ntitle: Downloading Files\n---\n\nDownloading file content and accessing files.\n\n:::info\n\nThe sample code on this page is based on the **[initial assumptions](./introduction)**.\n\n:::\n\n<Tabs groupId=\"variant\" items={['Basic Download',\"Using Streams\"]}>\n<Tab value=\"Basic Download\">\nDownloading a file from the Store and saving it by chunk to ByteArray:\n```kotlin\nval fileID = \"FILE_ID\"\nvar data = ByteArray(0)\n\nval closedFileID = StoreFileStreamReader.openFile(\n    storeApi,\n    fileID,\n).also {\n    do {\n        val chunk = it.read(StoreFileStream.OPTIMAL_SEND_SIZE)\n        data += chunk\n    } while (chunk.size.toLong() == StoreFileStream.OPTIMAL_SEND_SIZE)\n}.close()\n```\n</Tab>\n\n<Tab value=\"Using Streams\">\nDownloading a file from the Store and writing by chunk to `OutputStream`:\n```kotlin\nval fileID = \"FILE_ID\"\nval file = File(\"PATH_TO_FILE\")\nval outputStream: OutputStream = file.outputStream()\nval streamController = object: StoreFileStream.Controller(){\n    override fun onChunkProcessed(processedBytes: Long?) {\n        super.onChunkProcessed(processedBytes)\n        println(\"Full read size: $processedBytes\")\n    }\n}",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/java/downloading-files.mdx",
        "type": "mdx",
        "chunkIndex": 0,
        "codeBlocks": [
          "```kotlin\nval fileID = \"FILE_ID\"\nvar data = ByteArray(0)\n\nval closedFileID = StoreFileStreamReader.openFile(\n    storeApi,\n    fileID,\n).also {\n    do {\n        val chunk = it.read(StoreFileStream.OPTIMAL_SEND_SIZE)\n        data += chunk\n    } while (chunk.size.toLong() == StoreFileStream.OPTIMAL_SEND_SIZE)\n}.close()\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.889Z",
        "size": 1128
      }
    },
    {
      "pageContent": "val closedFileID = StoreFileStreamReader.openFile(\n    storeApi,\n    fileID,\n    outputStream,\n    streamController\n)\n```\n</Tab>\n</Tabs>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/java/downloading-files.mdx",
        "type": "mdx",
        "chunkIndex": 1,
        "lastModified": "2025-06-05T19:33:57.889Z",
        "size": 136
      }
    },
    {
      "pageContent": "---\ntitle: Entries\n---\n\n\nAll the data sent by someone to an Inbox is called an Entry.\nIn Threads and Stores, a user must be assigned to the container to send data. In Inboxes, however, \nanyone who has Inbox ID can send a reply (assuming they have the Bridge URL and Solution ID).\n\n:::info\n\nThe sample code on this page is based on the **[initial assumptions](./introduction#initial-assumptions)**.\n\n:::\n\n:::info\n\nEntry's `publicMeta` and `privateMeta` fields support any kind of data formats encoded to byte arrays. Examples in this section use `kotlinx-serialization-json-jvm` dependency for Kotlin and `com.google.code.gson:gson` for Java to serialize object to JSON format.\n\n:::",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/java/entries.mdx",
        "type": "mdx",
        "chunkIndex": 0,
        "lastModified": "2025-06-05T19:33:57.890Z",
        "size": 681
      }
    },
    {
      "pageContent": "## Sending Entries using Public API\n\nPublic submissions require using `platformConnectPublic` function, provided by the `Connection` class, to establish a public connection to the platform.\nAfter connecting, create an `InboxApi` instance, which allows to operate on Inboxes.\n\n```kotlin\nval connection = Connection.connectPublic(\n    solutionId,\n    bridgeUrl,\n)\nval publicInboxApi = InboxApi(connection)\n```\nAssuming you need some kind of structure in entries, define a data struct `InboxPublicEntryData`, and its instance:\nDefine structure of data sending to Inbox entry:\n```kotlin\n@Serializable\ndata class InboxPublicEntryData(\n    val name: String,\n    val surname: String,\n    val email: String,\n    val comment : String\n)\n```\nNow, having established public connection and `inboxApi`, you can send data to the Inbox:\n\n<Tabs groupId=\"variant\" items={[\"Basic\",\"With Files\"]}>\n<Tab value=\"basic\" label=\"Basic\">\n```kotlin\nval inboxID = \"INBOX_ID\"\nval inboxPublicEntryData = InboxPublicEntryData(\n    \"NAME\",\n    \"SURNAME\",\n    \"EMAIL\",\n    \"COMMENT\"\n)",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/java/entries.mdx",
        "type": "mdx",
        "chunkIndex": 1,
        "headers": [
          "Sending Entries using Public API"
        ],
        "title": "Sending Entries using Public API",
        "codeBlocks": [
          "```kotlin\nval connection = Connection.connectPublic(\n    solutionId,\n    bridgeUrl,\n)\nval publicInboxApi = InboxApi(connection)\n```",
          "```kotlin\n@Serializable\ndata class InboxPublicEntryData(\n    val name: String,\n    val surname: String,\n    val email: String,\n    val comment : String\n)\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.890Z",
        "size": 1051
      }
    },
    {
      "pageContent": "publicInboxApi.prepareEntry(\n    inboxID,\n    Json.encodeToString(inboxPublicEntryData).encodeToByteArray(),\n).let {\n    publicInboxApi.sendEntry(it)\n}\n```\n</Tab>\n\n<Tab value=\"With Files\">\n    <div className={'fd-steps'}>\n       <div className={'fd-step'} >\n\n\nCreate `InboxFileHandle` for each file:\n```kotlin\nval fileContents: List<ByteArray> = (0..5).map {\n    \"File content $it\".encodeToByteArray()\n}\nval filePublicMeta = ByteArray(0)\nval filePrivateMeta = ByteArray(0)\nval fileHandles = fileContents.map {\n    publicInboxApi.createFileHandle(\n        filePublicMeta,\n        filePrivateMeta,\n        it.size.toLong()\n    )\n}",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/java/entries.mdx",
        "type": "mdx",
        "chunkIndex": 2,
        "codeBlocks": [
          "```\n</Tab>\n\n<Tab value=\"With Files\">\n    <div className={'fd-steps'}>\n       <div className={'fd-step'} >\n\n\nCreate `InboxFileHandle` for each file:\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.890Z",
        "size": 628
      }
    },
    {
      "pageContent": "```\n\n</div>\n    <div className={'fd-step'} >\nCreate `InboxHandle` with `fileHandles` passed as a parameter:\n```kotlin\nval inboxID = \"INBOX_ID\"\nval inboxPublicEntryData = InboxPublicEntryData(\n    \"NAME\",\n    \"SURNAME\",\n    \"EMAIL\",\n    \"COMMENT\"\n)\n\nval inboxHandle = publicInboxApi.prepareEntry(\n    inboxID,\n    Json.encodeToString(inboxPublicEntryData).encodeToByteArray(),\n    fileHandles\n)\n```\n\n    </div>\n        <div className={'fd-step'} >\nUpload all files using `writeToFile` method from `InboxApi`:\n```kotlin\nfileContents.zip(fileHandles).forEach { (content, fileHandle) ->\n    publicInboxApi.writeToFile(inboxHandle, fileHandle, content)\n}\n```\n\n        </div>\n            <div className={'fd-step'} >\nCall `sendEntry` which sends `inboxPublicEntryData` data to Inbox and closes all file handles:\n```kotlin\npublicInboxApi.sendEntry(inboxHandle)\n```\n            </div>\n            </div>\n</Tab>\n</Tabs>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/java/entries.mdx",
        "type": "mdx",
        "chunkIndex": 3,
        "codeBlocks": [
          "```\n\n</div>\n    <div className={'fd-step'} >\nCreate `InboxHandle` with `fileHandles` passed as a parameter:\n```",
          "```\n\n    </div>\n        <div className={'fd-step'} >\nUpload all files using `writeToFile` method from `InboxApi`:\n```",
          "```\n\n        </div>\n            <div className={'fd-step'} >\nCall `sendEntry` which sends `inboxPublicEntryData` data to Inbox and closes all file handles:\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.890Z",
        "size": 910
      }
    },
    {
      "pageContent": "## Getting Entries\n\nCreated entries can be listed by non-public connections created using [`PrivmxEndpoint`](../reference/privmx-endpoint-java-extra/core/privmx-endpoint) class.\n\n<Tabs groupId=\"variant\" items={[\"Most Recent\",\"Oldest\"]}>\n<Tab value=\"Most Recent\">\nFetching the most recent Entries in given Inbox:\n```kotlin\nval inboxID = \"INBOX_ID\"\nval startIndex = 0L\nval pageSize = 100L\n\nval entriesPagingList = inboxApi.listEntries(\n    inboxID,\n    startIndex,\n    pageSize,\n    SortOrder.DESC\n)\n\nval entries = entriesPagingList.readItems.map {\n    EntryItem(\n        it,\n        Json.decodeFromString(it.data.decodeToString())\n    )\n}\n```\n</Tab>\n\n<Tab value=\"Oldest\">\nFetching the oldest Entries (by creation date) in given Inbox:\n```kotlin\nval inboxID = \"INBOX_ID\"\nval startIndex = 0L\nval pageSize = 100L\n\nval entriesPagingList = inboxApi.listEntries(\n    inboxID,\n    startIndex,\n    pageSize,\n    SortOrder.ASC\n)\n\nval entries = entriesPagingList.readItems.map {\n    EntryItem(\n        it,\n        Json.decodeFromString(it.data.decodeToString())\n    )\n}\n```\n</Tab>\n</Tabs>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/java/entries.mdx",
        "type": "mdx",
        "chunkIndex": 4,
        "headers": [
          "Getting Entries"
        ],
        "title": "Getting Entries",
        "codeBlocks": [
          "```kotlin\nval inboxID = \"INBOX_ID\"\nval startIndex = 0L\nval pageSize = 100L\n\nval entriesPagingList = inboxApi.listEntries(\n    inboxID,\n    startIndex,\n    pageSize,\n    SortOrder.DESC\n)\n\nval entries = entriesPagingList.readItems.map {\n    EntryItem(\n        it,\n        Json.decodeFromString(it.data.decodeToString())\n    )\n}\n```",
          "```kotlin\nval inboxID = \"INBOX_ID\"\nval startIndex = 0L\nval pageSize = 100L\n\nval entriesPagingList = inboxApi.listEntries(\n    inboxID,\n    startIndex,\n    pageSize,\n    SortOrder.ASC\n)\n\nval entries = entriesPagingList.readItems.map {\n    EntryItem(\n        it,\n        Json.decodeFromString(it.data.decodeToString())\n    )\n}\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.890Z",
        "size": 1077
      }
    },
    {
      "pageContent": "## Reading Entries Files\n\nFiles from Entries can be read by non-public connections created using [`PrivmxEndpoint`](../reference/privmx-endpoint-java-extra/core/privmx-endpoint) class.\n\n```kotlin\nval entryID = \"ENTRY_ID\"\nval inboxEntry = inboxApi.readEntry(entryID)\n\nval files: List<File> = inboxEntry.files\nval filesContent: List<ByteArray> = files.map { file ->\n    inboxApi.openFile(file.info.fileId)\n        .let { fileHandle ->\n            var fileContent = ByteArray(0)\n            do {\n                val chunk = inboxApi.readFromFile(fileHandle, StoreFileStream.OPTIMAL_SEND_SIZE)\n                fileContent += chunk\n            } while (chunk.size.toLong() == StoreFileStream.OPTIMAL_SEND_SIZE)\n            inboxApi.closeFile(fileHandle)\n            fileContent\n        }\n}\n```",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/java/entries.mdx",
        "type": "mdx",
        "chunkIndex": 5,
        "headers": [
          "Reading Entries Files"
        ],
        "title": "Reading Entries Files",
        "codeBlocks": [
          "```kotlin\nval entryID = \"ENTRY_ID\"\nval inboxEntry = inboxApi.readEntry(entryID)\n\nval files: List<File> = inboxEntry.files\nval filesContent: List<ByteArray> = files.map { file ->\n    inboxApi.openFile(file.info.fileId)\n        .let { fileHandle ->\n            var fileContent = ByteArray(0)\n            do {\n                val chunk = inboxApi.readFromFile(fileHandle, StoreFileStream.OPTIMAL_SEND_SIZE)\n                fileContent += chunk\n            } while (chunk.size.toLong() == StoreFileStream.OPTIMAL_SEND_SIZE)\n            inboxApi.closeFile(fileHandle)\n            fileContent\n        }\n}\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.890Z",
        "size": 788
      }
    },
    {
      "pageContent": "---\ntitle: Events\n---\n\n\n\nEvents enable your application to react dynamically to changes within user context.\n\n\n:::info\n\nBefore working with Events, follow our [Getting Started Guide](./introduction). It will show you how to set up your project to work with PrivMX Bridge.\n\nThe sample code on this page is based on the **[initial assumptions](./introduction#initial-assumptions)**.\n\n:::\n\nThese events are triggered automatically when a relevant change occurs. You can subscribe to them by registering event listeners. This allows you to respond to changes as they happen in real-time.\n\n\n## Caveats\n\n- All callback are related to the connection on which they were registered.\n- Calling [`PrivmxEndpointContainer.stopListening()`](../reference/privmx-endpoint-java-extra/core/privmx-endpoint-container#stoplistening) does not delete event listeners.\n- Disconnecting deletes all event listeners related to the connection.",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/java/events.mdx",
        "type": "mdx",
        "chunkIndex": 0,
        "headers": [
          "Caveats"
        ],
        "title": "Caveats",
        "lastModified": "2025-06-05T19:33:57.890Z",
        "size": 917
      }
    },
    {
      "pageContent": "## Quick start\n\n<div className={'fd-steps'}>\n   <div className={'fd-step'}>\n\nStart the event loop:\n```kotlin\nendpointContainer.startListening()\n```\n   </div>\n       <div className={'fd-step'}>\nAdd event listener for 'ThreadCreatedEvent' related with `callbackID`\n```kotlin\nval callbackID = \"CALLBACK_ID\"\nendpointSession.registerCallback(\n    callbackID,\n    EventType.ThreadCreatedEvent\n){ newThreadData ->\n    // some actions with newThreadData\n}\n```\n       </div>\n           <div className={'fd-step'}>\nRemove the event listener when no longer needed:\n```kotlin\nendpointSession.unregisterCallbacks(callbackID)\n```\n   </div>\n</div>\n## Unregister callbacks\n\n<Tabs groupId=\"variant\" items={[\"By Callback ID\", \"All Callbacks\"]}>\n<Tab value=\"By Callback ID\">\nUnregister all callbacks identified by `callbacksID`:\n```kotlin\nval callbacksID = \"CALLBACKS_ID\"\nendpointSession.unregisterCallbacks(callbacksID)\n```\n</Tab>\n\n<Tab value=\"All Callbacks\">\nUnregister all callbacks from the connection:\n```kotlin\nendpointSession.unregisterAll()\n```\n</Tab>\n\n</Tabs>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/java/events.mdx",
        "type": "mdx",
        "chunkIndex": 1,
        "headers": [
          "Quick start",
          "Unregister callbacks"
        ],
        "title": "Quick start",
        "codeBlocks": [
          "```kotlin\nendpointContainer.startListening()\n```",
          "```kotlin\nval callbackID = \"CALLBACK_ID\"\nendpointSession.registerCallback(\n    callbackID,\n    EventType.ThreadCreatedEvent\n){ newThreadData ->\n    // some actions with newThreadData\n}\n```",
          "```kotlin\nendpointSession.unregisterCallbacks(callbackID)\n```",
          "```kotlin\nval callbacksID = \"CALLBACKS_ID\"\nendpointSession.unregisterCallbacks(callbacksID)\n```",
          "```kotlin\nendpointSession.unregisterAll()\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.890Z",
        "size": 1049
      }
    },
    {
      "pageContent": "---\ntitle: Files\n---\n\n\n\nUploading and managing files.\n\n:::info\n\nThe sample code on this page is based on the **[initial assumptions](./introduction#initial-assumptions)**.\n\n:::\n\n:::info\n\nFile `publicMeta` and `privateMeta` fields support any kind of data formats encoded to byte arrays. Examples in this section use `kotlinx-serialization-json-jvm` dependency for Kotlin and `com.google.code.gson:gson` for Java to serialize object to JSON format.\n\n:::",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/java/files.mdx",
        "type": "mdx",
        "chunkIndex": 0,
        "lastModified": "2025-06-05T19:33:57.891Z",
        "size": 452
      }
    },
    {
      "pageContent": "## Uploading Files\n\n<Tabs groupId=\"variant\" items={[\"Basic Upload\",\"With File Meta\",\"Using Streams\"]}>\n<Tab >\nUploading file to a Store in the most basic way:\n```kotlin\nval storeID = \"STORE_ID\"\nval fileContent = \"Text file content\".encodeToByteArray()\nval publicMeta = ByteArray(0)\nval privateMeta = ByteArray(0)\n\nval fileId = StoreFileStreamWriter.createFile(\n    storeApi,\n    storeID,\n    publicMeta,\n    privateMeta,\n    fileContent.size.toLong(),\n).also {\n    it.write(fileContent)\n}.close()\n```\n</Tab>\n<Tab >\n\nUploading file to a Store with additional meta data.\n\nDefine file `privateMeta` structure:\n```kotlin\n@Serializable\ndata class FilePrivateMeta(\n    val name: String,\n    val mimetype: String\n)\n```\nPrepare and upload the file:\n```kotlin\nval storeID = \"STORE_ID\"\nval fileContent = \"Text file content\".encodeToByteArray()\nval publicMeta = ByteArray(0)\nval privateMeta = FilePrivateMeta(\n    name = \"Example text file\",\n    mimetype = \"text/plain\"\n)",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/java/files.mdx",
        "type": "mdx",
        "chunkIndex": 1,
        "headers": [
          "Uploading Files"
        ],
        "title": "Uploading Files",
        "codeBlocks": [
          "```kotlin\nval storeID = \"STORE_ID\"\nval fileContent = \"Text file content\".encodeToByteArray()\nval publicMeta = ByteArray(0)\nval privateMeta = ByteArray(0)\n\nval fileId = StoreFileStreamWriter.createFile(\n    storeApi,\n    storeID,\n    publicMeta,\n    privateMeta,\n    fileContent.size.toLong(),\n).also {\n    it.write(fileContent)\n}.close()\n```",
          "```kotlin\n@Serializable\ndata class FilePrivateMeta(\n    val name: String,\n    val mimetype: String\n)\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.891Z",
        "size": 960
      }
    },
    {
      "pageContent": "val fileId = StoreFileStreamWriter.createFile(\n    storeApi,\n    storeID,\n    publicMeta,\n    Json.encodeToString(privateMeta).encodeToByteArray(),\n    fileContent.size.toLong(),\n).also {\n    it.write(fileContent)\n}.close()\n```\n</Tab>\n<Tab value='Using Streams'>\nThe snippet below shows how to send `InputStream` directly to a file.\n\nDefine file `privateMeta` structure:\n```kotlin\n@Serializable\ndata class FilePrivateMeta(\n    val name: String,\n    val mimetype: String\n)\n```\nPrepare and upload the file:\n```kotlin\nval storeID = \"STORE_ID\"\nval file = File(\"PATH_TO_FILE\")\nval inputStream: InputStream = file.inputStream()\nval publicMeta = ByteArray(0)\nval privateMeta = FilePrivateMeta(\n    name = file.name,\n    mimetype = Files.probeContentType(file.toPath())\n)\nval streamController = object : StoreFileStream.Controller() {\n    override fun onChunkProcessed(processedBytes: Long?) {\n        super.onChunkProcessed(processedBytes)\n        println(\"Processed size: $processedBytes\")\n    }\n}",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/java/files.mdx",
        "type": "mdx",
        "chunkIndex": 2,
        "codeBlocks": [
          "```\n</Tab>\n<Tab value='Using Streams'>\nThe snippet below shows how to send `InputStream` directly to a file.\n\nDefine file `privateMeta` structure:\n```",
          "```\nPrepare and upload the file:\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.891Z",
        "size": 991
      }
    },
    {
      "pageContent": "val fileId = StoreFileStreamWriter.createFile(\n    storeApi,\n    storeID,\n    publicMeta,\n    Json.encodeToString(privateMeta).encodeToByteArray(),\n    inputStream.available().toLong(),\n    inputStream,\n    streamController\n)\n```\n</Tab>\n</Tabs>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/java/files.mdx",
        "type": "mdx",
        "chunkIndex": 3,
        "lastModified": "2025-06-05T19:33:57.891Z",
        "size": 244
      }
    },
    {
      "pageContent": "## Getting Files\n\nDefine file item class with decoded `privateMeta`.\n```kotlin\ndata class FileItem(\n    val file: File,\n    val decodedPrivateMeta: FilePrivateMeta\n)",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/java/files.mdx",
        "type": "mdx",
        "chunkIndex": 4,
        "headers": [
          "Getting Files"
        ],
        "title": "Getting Files",
        "lastModified": "2025-06-05T19:33:57.891Z",
        "size": 165
      }
    },
    {
      "pageContent": "```\n\n<Tabs groupId=\"variant\" items={[\"Most Recent\",\"Oldest\",\"By File ID\"]}>\n<Tab value=\"Most Recent\">\nFetching the most recent files in given Store:\n```kotlin\nval storeId = \"STORE_ID\"\nval startIndex = 0L\nval pageSize = 100L\n\nval filesPagingList = storeApi.listFiles(\n    storeId,\n    startIndex,\n    pageSize,\n    SortOrder.DESC\n)\n\nval files = filesPagingList.readItems.map {\n    FileItem(\n        it,\n        Json.decodeFromString(it.privateMeta.decodeToString())\n    )\n}\n```\n</Tab>\n\n<Tab value=\"Oldest\">\nFetching the oldest files (by creation date) in given Store:\n```kotlin\nval storeId = \"STORE_ID\"\nval startIndex = 0L\nval pageSize = 100L\n\nval filesPagingList = storeApi.listFiles(\n    storeId,\n    startIndex,\n    pageSize,\n    SortOrder.ASC\n)\n\nval files = filesPagingList.readItems.map {\n    FileItem(\n        it,\n        Json.decodeFromString(it.privateMeta.decodeToString())\n    )\n}\n```\n</Tab>\n<Tab value=\"By File ID\">\nYou can get info about a file using its `fileId`:\n```kotlin\nval fileID = \"FILE_ID\"\n\nval fileItem = storeApi.getFile(fileID).let {\n    FileItem(\n        it,\n        Json.decodeFromString(it.privateMeta.decodeToString())\n    )\n}\n```\n</Tab>\n</Tabs>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/java/files.mdx",
        "type": "mdx",
        "chunkIndex": 5,
        "codeBlocks": [
          "```\n\n<Tabs groupId=\"variant\" items={[\"Most Recent\",\"Oldest\",\"By File ID\"]}>\n<Tab value=\"Most Recent\">\nFetching the most recent files in given Store:\n```",
          "```\n</Tab>\n\n<Tab value=\"Oldest\">\nFetching the oldest files (by creation date) in given Store:\n```",
          "```\n</Tab>\n<Tab value=\"By File ID\">\nYou can get info about a file using its `fileId`:\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.891Z",
        "size": 1171
      }
    },
    {
      "pageContent": "## Managing Files\n\n<Tabs groupId=\"variant\" items={[\"Changing File Name\",\"Overwriting File Content\",\"Deleting File\"]}>\n<Tab value=\"Changing File Name\">\n```kotlin\nval fileID = \"FILE_ID\"\nval file = storeApi.getFile(fileID)\nvar filePrivateMeta: FilePrivateMeta = Json.decodeFromString(file.privateMeta.decodeToString())\nfilePrivateMeta = filePrivateMeta.copy(\n    name = \"New file name\"\n)\n\nstoreApi.updateFileMeta(\n    fileID,\n    file.publicMeta,\n    Json.encodeToString(filePrivateMeta).encodeToByteArray(),\n)\n```\n</Tab>\n\n<Tab value=\"Overwriting File Content\">\n```kotlin\nval fileID = \"FILE_ID\"\nval newFile = File(\"PATH_TO_FILE\")\nval inputStream: InputStream = newFile.inputStream()\nval streamController = object : StoreFileStream.Controller() {\n    override fun onChunkProcessed(processedBytes: Long?) {\n        super.onChunkProcessed(processedBytes)\n        println(\"Processed size: $processedBytes\")\n    }\n}\nval file = storeApi.getFile(fileID)\n\nStoreFileStreamWriter.updateFile(\n    storeApi,\n    fileID,\n    file.publicMeta,\n    file.privateMeta,\n    inputStream.available().toLong(),\n    inputStream,\n    streamController\n)\n```\n</Tab>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/java/files.mdx",
        "type": "mdx",
        "chunkIndex": 6,
        "headers": [
          "Managing Files"
        ],
        "title": "Managing Files",
        "codeBlocks": [
          "```kotlin\nval fileID = \"FILE_ID\"\nval file = storeApi.getFile(fileID)\nvar filePrivateMeta: FilePrivateMeta = Json.decodeFromString(file.privateMeta.decodeToString())\nfilePrivateMeta = filePrivateMeta.copy(\n    name = \"New file name\"\n)\n\nstoreApi.updateFileMeta(\n    fileID,\n    file.publicMeta,\n    Json.encodeToString(filePrivateMeta).encodeToByteArray(),\n)\n```",
          "```kotlin\nval fileID = \"FILE_ID\"\nval newFile = File(\"PATH_TO_FILE\")\nval inputStream: InputStream = newFile.inputStream()\nval streamController = object : StoreFileStream.Controller() {\n    override fun onChunkProcessed(processedBytes: Long?) {\n        super.onChunkProcessed(processedBytes)\n        println(\"Processed size: $processedBytes\")\n    }\n}\nval file = storeApi.getFile(fileID)\n\nStoreFileStreamWriter.updateFile(\n    storeApi,\n    fileID,\n    file.publicMeta,\n    file.privateMeta,\n    inputStream.available().toLong(),\n    inputStream,\n    streamController\n)\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.891Z",
        "size": 1136
      }
    },
    {
      "pageContent": "StoreFileStreamWriter.updateFile(\n    storeApi,\n    fileID,\n    file.publicMeta,\n    file.privateMeta,\n    inputStream.available().toLong(),\n    inputStream,\n    streamController\n)\n```\n</Tab>\n\n<Tab value=\"Deleting File\">\n```kotlin\nval fileID = \"FILE_ID\"\nstoreApi.deleteFile(fileID)\n```\n</Tab>\n</Tabs>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/java/files.mdx",
        "type": "mdx",
        "chunkIndex": 7,
        "codeBlocks": [
          "```\n</Tab>\n\n<Tab value=\"Deleting File\">\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.891Z",
        "size": 300
      }
    },
    {
      "pageContent": "---\ntitle: Getting Started\n---\n\n\n## Initial Requirements\n\nBefore starting developing using PrivMX Endpoint Java follow our [quick start guide](../start/quick-start)\n\nTo connect it to your environment, you need:\n  - `Bridge URL` - URL address of the instance of your PrivMX Bridge\n  - `Solution ID` - ID of the Solution provided by PrivMX Bridge during its initialization process\n  - `User Private Key` - the private key from the user's public-private key pair\n\nYou also need to use your own application server to manage users (and their keys) and Contexts.",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/java/getting-started.mdx",
        "type": "mdx",
        "chunkIndex": 0,
        "headers": [
          "Initial Requirements"
        ],
        "title": "Initial Requirements",
        "lastModified": "2025-06-05T19:33:57.891Z",
        "size": 556
      }
    },
    {
      "pageContent": "## Installation\n\nOur Java libraries contain all the necessary assets and helpers to get started with PrivMX Endpoint. Select which level is the best for you. \nGo to Java [overview](../java/introduction) to see the descriptions of each library.\n\n### Java Dependencies\n\n1. Add `mavenCentral()` repository to your `settings.gradle`:\n\n```groovy\ndependencyResolutionManagement{\n    repositories{\n        mavenCentral()\n    }\n}\n```\n\n2. Add dependency to `build.gradle`:\n\n```groovy\ndependencies {\n    def privmxLibVersion = \"2.2.0\" // privmx-endpoint-version\n    implementation(\"com.simplito.java:privmx-endpoint-extra:$privmxLibVersion\")\n    //implementation(\"com.simplito.java:privmx-endpoint:$privmxLibVersion\")  #for base Java library\n    //implementation(\"com.simplito.java:privmx-endpoint-android:$privmxLibVersion\")  #for Android Java library\n}\n```",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/java/getting-started.mdx",
        "type": "mdx",
        "chunkIndex": 1,
        "headers": [
          "Installation",
          "Java Dependencies"
        ],
        "title": "Installation",
        "codeBlocks": [
          "```groovy\ndependencyResolutionManagement{\n    repositories{\n        mavenCentral()\n    }\n}\n```",
          "```groovy\ndependencies {\n    def privmxLibVersion = \"2.2.0\" // privmx-endpoint-version\n    implementation(\"com.simplito.java:privmx-endpoint-extra:$privmxLibVersion\")\n    //implementation(\"com.simplito.java:privmx-endpoint:$privmxLibVersion\")  #for base Java library\n    //implementation(\"com.simplito.java:privmx-endpoint-android:$privmxLibVersion\")  #for Android Java library\n}\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.891Z",
        "size": 848
      }
    },
    {
      "pageContent": "### Shared Libraries\nJava projects require you to install shared native libraries in a specified path and pass this path to java command as argument `-Djava.library.path=`.\nIn Android, you just need to put the libraries in the `src/main/jniLibs` directory.\n\nUse our gradle plugin to download and unzip the shared libraries.\n\n1. Add `mavenCentral()` repository to your `settings.gradle`:\n\n```groovy\npluginManagement {\n    repositories{\n        mavenCentral()\n    }\n}\n```\n\n2. Add and configure the plugin in `build.gradle`:\n\n```groovy\nplugins {\n    id \"com.simplito.privmx-endpoint-install-native\" version \"$pluginVersion\"\n}\n\nprivmxEndpointInstallJni{\n    version = $nativeLibVersion // this version should be the same as privmx-endpoint-java version\n}\n```\n\nFor more information about the plugin, go to its dedicated [section](./plugin-configuration).\n\nAlternatively, download them from [GitHub releases](https://github.com/simplito/privmx-endpoint-java/releases) assets with the same version as your `privmx-endpoint-java` library.",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/java/getting-started.mdx",
        "type": "mdx",
        "chunkIndex": 2,
        "headers": [
          "Shared Libraries"
        ],
        "title": "Shared Libraries",
        "codeBlocks": [
          "```groovy\npluginManagement {\n    repositories{\n        mavenCentral()\n    }\n}\n```",
          "```groovy\nplugins {\n    id \"com.simplito.privmx-endpoint-install-native\" version \"$pluginVersion\"\n}\n\nprivmxEndpointInstallJni{\n    version = $nativeLibVersion // this version should be the same as privmx-endpoint-java version\n}\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.891Z",
        "size": 1030
      }
    },
    {
      "pageContent": "## Initial Assumptions\nThe initial assumptions for all the code examples below are as follows:\n\n<Tabs groupId=\"variant\" items={[\"Java\",\"Kotlin\"]}>\n<Tab >\n```java\n/*\n    All the values below like BRIDGE_URL, SOLUTION_ID, CONTEXT_ID\n    should be replaced by the ones corresponding to your Bridge Server instance.\n\n    The private keys here are for demonstration purposes only.\n    Normally, they should be kept separately by each user and stored in a safe place,\n    or generated from a password (see the derivePrivateKey2() method in the Crypto API)\n*/\n\nString bridgeUrl = \"YOUR_BRIDGE_URL\";\nString solutionId = \"YOUR_SOLUTION_ID\";\nString contextId = \"YOUR_CONTEXT_ID\";\n\nString user1Id = \"USER_ID_1\";\nString user1PublicKey = \"PUBLIC_KEY_1\";\nString user1PrivateKey = \"PRIVATE_KEY_1\";\n\nString user2Id = \"USER_ID_2\";\nString user2PublicKey = \"PUBLIC_KEY_2\";\n```\n</Tab>\n<Tab >\n``` kotlin\n/*\n    All the values below like BRIDGE_URL, SOLUTION_ID, CONTEXT_ID\n    should be replaced by the ones corresponding to your Bridge Server instance.",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/java/getting-started.mdx",
        "type": "mdx",
        "chunkIndex": 3,
        "headers": [
          "Initial Assumptions"
        ],
        "title": "Initial Assumptions",
        "codeBlocks": [
          "```java\n/*\n    All the values below like BRIDGE_URL, SOLUTION_ID, CONTEXT_ID\n    should be replaced by the ones corresponding to your Bridge Server instance.\n\n    The private keys here are for demonstration purposes only.\n    Normally, they should be kept separately by each user and stored in a safe place,\n    or generated from a password (see the derivePrivateKey2() method in the Crypto API)\n*/\n\nString bridgeUrl = \"YOUR_BRIDGE_URL\";\nString solutionId = \"YOUR_SOLUTION_ID\";\nString contextId = \"YOUR_CONTEXT_ID\";\n\nString user1Id = \"USER_ID_1\";\nString user1PublicKey = \"PUBLIC_KEY_1\";\nString user1PrivateKey = \"PRIVATE_KEY_1\";\n\nString user2Id = \"USER_ID_2\";\nString user2PublicKey = \"PUBLIC_KEY_2\";\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.891Z",
        "size": 1032
      }
    },
    {
      "pageContent": "The private keys here are for demonstration purposes only.\n    Normally, they should be kept separately by each user and stored in a safe place,\n    or generated from a password (see the derivePrivateKey2() method in the Crypto API)\n*/\n\nval bridgeUrl = \"YOUR_BRIDGE_URL\"\nval solutionId = \"YOUR_SOLUTION_ID\"\nval contextId = \"YOUR_CONTEXT_ID\"\n\nval user1Id = \"USER_ID_1\"\nval user1PublicKey = \"PUBLIC_KEY_1\"\nval user1PrivateKey = \"PRIVATE_KEY_1\"\n\nval user2Id = \"USER_ID_2\"\nval user2PublicKey = \"PUBLIC_KEY_2\"\n```\n</Tab>\n</Tabs>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/java/getting-started.mdx",
        "type": "mdx",
        "chunkIndex": 4,
        "lastModified": "2025-06-05T19:33:57.891Z",
        "size": 523
      }
    },
    {
      "pageContent": "## Connecting to PrivMX Bridge\n\nTo use any of the library's elements, you must first connect to PrivMX Bridge.\nUse the API keys mentioned [earlier](#initial-requirements):\n\n<Tabs groupId=\"variant\" items={[\"Java\",\"Kotlin\"]}>\n<Tab >\n```java\nString pathToCerts = \"PATH_TO_CERTS\"; // Path to .pem ssl certificate to connect with Privmx Bridge\nSet<Modules> initModules = Set.of(\n        Modules.THREAD, // initializes ThreadApi to working with Threads\n        Modules.STORE, // initializes StoreApi to working with Stores\n        Modules.INBOX // initializes InboxApi to working with Inboxes\n); // set of modules to activate in new connection\n\nPrivmxEndpointContainer endpointContainer = new PrivmxEndpointContainer();\nendpointContainer.setCertsPath(pathToCerts);\n\nPrivmxEndpoint endpointSession = endpointContainer.connect(\n        initModules,\n        user1PrivateKey,\n        solutionId,\n        bridgeUrl\n);\n```\n</Tab>\n<Tab >",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/java/getting-started.mdx",
        "type": "mdx",
        "chunkIndex": 5,
        "headers": [
          "Connecting to PrivMX Bridge"
        ],
        "title": "Connecting to PrivMX Bridge",
        "codeBlocks": [
          "```java\nString pathToCerts = \"PATH_TO_CERTS\"; // Path to .pem ssl certificate to connect with Privmx Bridge\nSet<Modules> initModules = Set.of(\n        Modules.THREAD, // initializes ThreadApi to working with Threads\n        Modules.STORE, // initializes StoreApi to working with Stores\n        Modules.INBOX // initializes InboxApi to working with Inboxes\n); // set of modules to activate in new connection\n\nPrivmxEndpointContainer endpointContainer = new PrivmxEndpointContainer();\nendpointContainer.setCertsPath(pathToCerts);\n\nPrivmxEndpoint endpointSession = endpointContainer.connect(\n        initModules,\n        user1PrivateKey,\n        solutionId,\n        bridgeUrl\n);\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.891Z",
        "size": 924
      }
    },
    {
      "pageContent": "PrivmxEndpoint endpointSession = endpointContainer.connect(\n        initModules,\n        user1PrivateKey,\n        solutionId,\n        bridgeUrl\n);\n```\n</Tab>\n<Tab >\n\n``` kotlin\nval pathToCerts = \"PATH_TO_CERTS\" // Path to .pem ssl certificate to connect with Privmx Bridge\nval initModules = setOf(\n    Modules.THREAD, // initializes ThreadApi to working with Threads\n    Modules.STORE, // initializes StoreApi to working with Stores\n    Modules.INBOX // initializes InboxApi to working with Inboxes\n) // set of modules to activate in new connection\n\nval endpointContainer = PrivmxEndpointContainer().also {\n    it.setCertsPath(pathToCerts)\n}\n\nval endpointSession = endpointContainer.connect(\n    initModules,\n    user1PrivateKey,\n    solutionId,\n    bridgeUrl\n)\n```\n</Tab>\n</Tabs>\n\nThe active connection is kept by [`container`](../reference/privmx-endpoint-java-extra/core/privmx-endpoint-container) and can be accessed using [`container.getEndpoint(Long)`](../reference/privmx-endpoint-java-extra/core/privmx-endpoint-container#getendpoint) method.\n``` kotlin\nendpointContainer.getEndpoint(endpointSession.connection.connectionId)\n```",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/java/getting-started.mdx",
        "type": "mdx",
        "chunkIndex": 6,
        "codeBlocks": [
          "```\n</Tab>\n<Tab >\n\n```",
          "```\n</Tab>\n</Tabs>\n\nThe active connection is kept by [`container`](../reference/privmx-endpoint-java-extra/core/privmx-endpoint-container) and can be accessed using [`container.getEndpoint(Long)`](../reference/privmx-endpoint-java-extra/core/privmx-endpoint-container#getendpoint) method.\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.891Z",
        "size": 1136
      }
    },
    {
      "pageContent": "## Disconnecting from PrivMX Bridge\n\n<Tabs groupId=\"variant\" items={[\"By Connection ID\",\"All Connections\"]}>\n<Tab >\n```kotlin\nendpointContainer.disconnect(endpointSession.connection.connectionId)\n```\n</Tab>\n<Tab>\n\n``` kotlin\ncontainer.disconnectAll()\n```\n</Tab>\n</Tabs>\n\n## Closing `PrivmxEndpointContainer`\nWhen you finish working with the `container`, close it to end all connections, close the event loop, and release the resources being used.\nYou can also use a `try-with-resources` block in Java or `use` function in Kotlin.\n``` kotlin\ncontainer.close()\n```\n\n## Next Steps\n\nWith everything ready to go, now it's time to start using all of the platform's capabilities. \n\nLearn how to use:\n\n-   [**Threads**](../start/threads/overview) - for exchanging encrypted messages;\n-   [**Stores**](../start/stores/overview) - for saving and sharing encrypted files;\n-   [**Inboxes**](../start/inboxes/overview) - for one way communication with external users.",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/java/getting-started.mdx",
        "type": "mdx",
        "chunkIndex": 7,
        "headers": [
          "Disconnecting from PrivMX Bridge",
          "Closing `PrivmxEndpointContainer`",
          "Next Steps"
        ],
        "title": "Disconnecting from PrivMX Bridge",
        "codeBlocks": [
          "```kotlin\nendpointContainer.disconnect(endpointSession.connection.connectionId)\n```",
          "``` kotlin\ncontainer.disconnectAll()\n```",
          "``` kotlin\ncontainer.close()\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.891Z",
        "size": 954
      }
    },
    {
      "pageContent": "---\ntitle: Handling Events\n---\n\n\n\nHow to subscribe to events, assuming you have already started listening.\n\n## Connection\n\n```kotlin\nval callbacksId = \"CALLBACKS_ID\"\n\nendpointSession.registerCallback(\n    callbacksId,\n    EventType.ConnectedEvent\n){\n    // some actions when lib was connected\n}\n\nendpointSession.registerCallback(\n    callbacksId,\n    EventType.DisconnectedEvent\n){\n    // some actions when lib was disconnected\n}\n```",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/java/handling-events.mdx",
        "type": "mdx",
        "chunkIndex": 0,
        "headers": [
          "Connection"
        ],
        "title": "Connection",
        "codeBlocks": [
          "```kotlin\nval callbacksId = \"CALLBACKS_ID\"\n\nendpointSession.registerCallback(\n    callbacksId,\n    EventType.ConnectedEvent\n){\n    // some actions when lib was connected\n}\n\nendpointSession.registerCallback(\n    callbacksId,\n    EventType.DisconnectedEvent\n){\n    // some actions when lib was disconnected\n}\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.892Z",
        "size": 433
      }
    },
    {
      "pageContent": "## Threads\n\n<Tabs items={[\"Threads\",\"Messages\"]}>\n<Tab value=\"Threads\">\n```kotlin\nval callbacksId = \"CALLBACKS_ID\"\n\nendpointSession.registerCallback(\n    callbacksId,\n    EventType.ThreadCreatedEvent\n){ newThreadData ->\n    // some actions when new thread created\n}\n\nendpointSession.registerCallback(\n    callbacksId,\n    EventType.ThreadUpdatedEvent\n){ threadUpdateData ->\n    // some actions when thread updated\n}\n\nendpointSession.registerCallback(\n    callbacksId,\n    EventType.ThreadStatsChangedEvent\n){ threadStatsUpdateData ->\n    // some actions when thread stats changed\n}\n\nendpointSession.registerCallback(\n    callbacksId,\n    EventType.ThreadDeletedEvent\n){ deletedThreadData ->\n    // some actions when thread deleted\n}\n```\n</Tab>\n\n<Tab value=\"Messages\">\n```kotlin\nval callbacksId = \"CALLBACKS_ID\"\nval threadID = \"THREAD_ID\"\n\nendpointSession.registerCallback(\n    callbacksId,\n    EventType.ThreadNewMessageEvent(threadID)\n){ newMessageData ->\n    // some actions on new message\n}\n\nendpointSession.registerCallback(\n    callbacksId,\n    EventType.ThreadMessageUpdatedEvent(threadID)\n){ updatedMessageData ->\n    // some actions when message updated\n}",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/java/handling-events.mdx",
        "type": "mdx",
        "chunkIndex": 1,
        "headers": [
          "Threads"
        ],
        "title": "Threads",
        "codeBlocks": [
          "```kotlin\nval callbacksId = \"CALLBACKS_ID\"\n\nendpointSession.registerCallback(\n    callbacksId,\n    EventType.ThreadCreatedEvent\n){ newThreadData ->\n    // some actions when new thread created\n}\n\nendpointSession.registerCallback(\n    callbacksId,\n    EventType.ThreadUpdatedEvent\n){ threadUpdateData ->\n    // some actions when thread updated\n}\n\nendpointSession.registerCallback(\n    callbacksId,\n    EventType.ThreadStatsChangedEvent\n){ threadStatsUpdateData ->\n    // some actions when thread stats changed\n}\n\nendpointSession.registerCallback(\n    callbacksId,\n    EventType.ThreadDeletedEvent\n){ deletedThreadData ->\n    // some actions when thread deleted\n}\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.892Z",
        "size": 1163
      }
    },
    {
      "pageContent": "endpointSession.registerCallback(\n    callbacksId,\n    EventType.ThreadMessageUpdatedEvent(threadID)\n){ updatedMessageData ->\n    // some actions when message updated\n}\n\nendpointSession.registerCallback(\n    callbacksId,\n    EventType.ThreadMessageDeletedEvent(threadID)\n){ deletedMessageData ->\n    // some actions when message deleted\n}\n```\n</Tab>\n\n</Tabs>\n\n[Read more](../start/threads/listening-for-changes) about Thread events.",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/java/handling-events.mdx",
        "type": "mdx",
        "chunkIndex": 2,
        "lastModified": "2025-06-05T19:33:57.892Z",
        "size": 432
      }
    },
    {
      "pageContent": "## Stores\n\n<Tabs items={[\"Stores\",\"Files\"]}>\n\n<Tab value='Stores'>\n```kotlin\nval callbacksId = \"CALLBACKS_ID\"\n\nendpointSession.registerCallback(\n    callbacksId,\n    EventType.StoreCreatedEvent\n){ newStoreData ->\n    // some actions when new store created\n}\n\nendpointSession.registerCallback(\n    callbacksId,\n    EventType.StoreUpdatedEvent\n){ storeUpdateData ->\n    // some actions when store updated\n}\n\nendpointSession.registerCallback(\n    callbacksId,\n    EventType.StoreStatsChangedEvent\n){ storeStatsUpdateData ->\n    // some actions when store stats changed\n}\n\nendpointSession.registerCallback(\n    callbacksId,\n    EventType.StoreDeletedEvent\n){ deletedStoreData ->\n    // some actions when store deleted\n}\n```\n</Tab>\n\n<Tab value=\"Files\">\n```kotlin\nval callbacksId = \"CALLBACKS_ID\"\nval storeID = \"STORE_ID\"\n\nendpointSession.registerCallback(\n    callbacksId,\n    EventType.StoreFileCreatedEvent(storeID)\n){ newFileData ->\n    // some actions on new file\n}\n\nendpointSession.registerCallback(\n    callbacksId,\n    EventType.StoreFileUpdatedEvent(storeID)\n){ updatedFileData ->\n    // some actions when file updated\n}",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/java/handling-events.mdx",
        "type": "mdx",
        "chunkIndex": 3,
        "headers": [
          "Stores"
        ],
        "title": "Stores",
        "codeBlocks": [
          "```kotlin\nval callbacksId = \"CALLBACKS_ID\"\n\nendpointSession.registerCallback(\n    callbacksId,\n    EventType.StoreCreatedEvent\n){ newStoreData ->\n    // some actions when new store created\n}\n\nendpointSession.registerCallback(\n    callbacksId,\n    EventType.StoreUpdatedEvent\n){ storeUpdateData ->\n    // some actions when store updated\n}\n\nendpointSession.registerCallback(\n    callbacksId,\n    EventType.StoreStatsChangedEvent\n){ storeStatsUpdateData ->\n    // some actions when store stats changed\n}\n\nendpointSession.registerCallback(\n    callbacksId,\n    EventType.StoreDeletedEvent\n){ deletedStoreData ->\n    // some actions when store deleted\n}\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.892Z",
        "size": 1123
      }
    },
    {
      "pageContent": "endpointSession.registerCallback(\n    callbacksId,\n    EventType.StoreFileUpdatedEvent(storeID)\n){ updatedFileData ->\n    // some actions when file updated\n}\n\nendpointSession.registerCallback(\n    callbacksId,\n    EventType.StoreFileDeletedEvent(storeID)\n){ deletedFileData ->\n    // some actions when file deleted\n}\n```\n</Tab>\n\n</Tabs>\n\n[Read more](../start/stores/instant-updating) about Store events.",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/java/handling-events.mdx",
        "type": "mdx",
        "chunkIndex": 4,
        "lastModified": "2025-06-05T19:33:57.892Z",
        "size": 403
      }
    },
    {
      "pageContent": "## Inboxes\n\n<Tabs items={[\"Inboxes\",\"Inbox Entries\"]}>\n\n<Tab value=\"Inboxes\">\n```kotlin\nval callbacksId = \"CALLBACKS_ID\"\n\nendpointSession.registerCallback(\n    callbacksId,\n    EventType.InboxCreatedEvent\n){ newInboxData ->\n    // some actions when new inbox created\n}\n\nendpointSession.registerCallback(\n    callbacksId,\n    EventType.InboxUpdatedEvent\n){ inboxUpdateData ->\n    // some actions when inbox updated\n}\n\nendpointSession.registerCallback(\n    callbacksId,\n    EventType.InboxDeletedEvent\n){ deletedInboxData ->\n    // some actions when inbox deleted\n}\n```\n</Tab>\n\n<Tab value='Inbox Entries'>\n```kotlin\nval callbacksId = \"CALLBACKS_ID\"\nval inboxID = \"INBOX_ID\"\n\nendpointSession.registerCallback(\n    callbacksId,\n    EventType.InboxEntryCreatedEvent(inboxID)\n){ newEntryData ->\n    // some actions on new entry\n}\n\nendpointSession.registerCallback(\n    callbacksId,\n    EventType.InboxEntryDeletedEvent(inboxID)\n){ deletedEntryData ->\n    // some actions when entry deleted\n}\n```\n</Tab>\n</Tabs>\n\n[Read more](../start/inboxes/inbox-updates) about Inbox events.",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/java/handling-events.mdx",
        "type": "mdx",
        "chunkIndex": 5,
        "headers": [
          "Inboxes"
        ],
        "title": "Inboxes",
        "codeBlocks": [
          "```kotlin\nval callbacksId = \"CALLBACKS_ID\"\n\nendpointSession.registerCallback(\n    callbacksId,\n    EventType.InboxCreatedEvent\n){ newInboxData ->\n    // some actions when new inbox created\n}\n\nendpointSession.registerCallback(\n    callbacksId,\n    EventType.InboxUpdatedEvent\n){ inboxUpdateData ->\n    // some actions when inbox updated\n}\n\nendpointSession.registerCallback(\n    callbacksId,\n    EventType.InboxDeletedEvent\n){ deletedInboxData ->\n    // some actions when inbox deleted\n}\n```",
          "```kotlin\nval callbacksId = \"CALLBACKS_ID\"\nval inboxID = \"INBOX_ID\"\n\nendpointSession.registerCallback(\n    callbacksId,\n    EventType.InboxEntryCreatedEvent(inboxID)\n){ newEntryData ->\n    // some actions on new entry\n}\n\nendpointSession.registerCallback(\n    callbacksId,\n    EventType.InboxEntryDeletedEvent(inboxID)\n){ deletedEntryData ->\n    // some actions when entry deleted\n}\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.892Z",
        "size": 1069
      }
    },
    {
      "pageContent": "---\ntitle: Overview\n---\n\n\n\nInboxes are a secure way for assigned members to receive encrypted inbound traffic from public sources.\n\n:::info\n\nBefore working with Inboxes, follow our [Getting Started Guide](./introduction). It will show you how to set up your project to work with PrivMX Bridge.\n\nThe sample code on this page is based on the **[initial assumptions](./introduction#initial-assumptions)**.\n\n:::\n\n:::info\n\nInbox `publicMeta` and `privateMeta` fields support any kind of data formats encoded to byte arrays.\nExamples in this section use `kotlinx-serialization-json-jvm` dependency for Kotlin and `com.google.code.gson:gson` for Java to serialize object to JSON format.\n\n:::\n\n## What is an Inbox?\n\nInbox is a container, which is designed to be accessed only by the assigned users. It is managed similarly as Threads and Stores.\nHowever, writing to an Inbox is possible with public API, which doesn't require writer registration and access specification.",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/java/inboxes.mdx",
        "type": "mdx",
        "chunkIndex": 0,
        "headers": [
          "What is an Inbox?"
        ],
        "title": "What is an Inbox?",
        "lastModified": "2025-06-05T19:33:57.892Z",
        "size": 963
      }
    },
    {
      "pageContent": "## Working with Inboxes\n\nTo access Threads methods, get the field `inboxApi` from active connection. Connection should be initialized with `Modules.INBOX` and passed to [`PrivmxEndpoint()`](../reference/privmx-endpoint-java-extra/core/privmx-endpoint#privmxendpoint-1).\n\n```kotlin\nval inboxApi = endpointSession.inboxApi\n```",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/java/inboxes.mdx",
        "type": "mdx",
        "chunkIndex": 1,
        "headers": [
          "Working with Inboxes"
        ],
        "title": "Working with Inboxes",
        "codeBlocks": [
          "```kotlin\nval inboxApi = endpointSession.inboxApi\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.892Z",
        "size": 324
      }
    },
    {
      "pageContent": "## Creating Inboxes\n\n<Tabs groupId=\"variant\" items={[\"Basic\",\"With Config\",\"With a Name\",\"With publicMeta\"]}>\n<Tab value=\"Basic\">\nCreating a basic, unnamed Inbox, which can act as an encrypted data container:\n```kotlin\nval users : List<UserWithPubKey> = listOf(\n    UserWithPubKey(user1Id, user1PublicKey),\n    UserWithPubKey(user2Id, user2PublicKey)\n)\nval managers : List<UserWithPubKey> = listOf(\n    UserWithPubKey(user1Id, user1PublicKey)\n)\nval publicMeta = ByteArray(0)\nval privateMeta = ByteArray(0)\n\nval inboxId = inboxApi.createInbox(\n    contextId,\n    users,\n    managers,\n    publicMeta,\n    privateMeta\n)\n```\n</Tab>\n\n<Tab value=\"With Config\">\nFirst, you need to specify constraints for inbound traffic size limits:\n```kotlin\nval filesConfig = FilesConfig(\n    0L, //minCount\n    10L, //maxCount\n    500L, //maxFileSize\n    2000L //maxWholeUploadSize\n)\n```\nCreating new Inbox:\n```kotlin\nval users : List<UserWithPubKey> = listOf(\n    UserWithPubKey(user1Id, user1PublicKey),\n    UserWithPubKey(user2Id, user2PublicKey)\n)\nval managers : List<UserWithPubKey> = listOf(\n    UserWithPubKey(user1Id, user1PublicKey)\n)\nval publicMeta = ByteArray(0)\nval privateMeta = ByteArray(0)",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/java/inboxes.mdx",
        "type": "mdx",
        "chunkIndex": 2,
        "headers": [
          "Creating Inboxes"
        ],
        "title": "Creating Inboxes",
        "codeBlocks": [
          "```kotlin\nval users : List<UserWithPubKey> = listOf(\n    UserWithPubKey(user1Id, user1PublicKey),\n    UserWithPubKey(user2Id, user2PublicKey)\n)\nval managers : List<UserWithPubKey> = listOf(\n    UserWithPubKey(user1Id, user1PublicKey)\n)\nval publicMeta = ByteArray(0)\nval privateMeta = ByteArray(0)\n\nval inboxId = inboxApi.createInbox(\n    contextId,\n    users,\n    managers,\n    publicMeta,\n    privateMeta\n)\n```",
          "```kotlin\nval filesConfig = FilesConfig(\n    0L, //minCount\n    10L, //maxCount\n    500L, //maxFileSize\n    2000L //maxWholeUploadSize\n)\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.892Z",
        "size": 1184
      }
    },
    {
      "pageContent": "val inboxId = inboxApi.createInbox(\n    contextId,\n    users,\n    managers,\n    publicMeta,\n    privateMeta,\n    filesConfig\n)\n```\n</Tab>\n\n<Tab value=\"With a Name\">\nYou can assign any data to private and public meta fields (e.g. the Inbox's name), as long as it is serialized to byte array:\n```kotlin\nval users : List<UserWithPubKey> = listOf(\n    UserWithPubKey(user1Id, user1PublicKey),\n    UserWithPubKey(user2Id, user2PublicKey)\n)\nval managers : List<UserWithPubKey> = listOf(\n    UserWithPubKey(user1Id, user1PublicKey)\n)\nval publicMeta = ByteArray(0)\nval inboxNameAsPrivateMeta = \"New inbox\"\n\nval inboxId = inboxApi.createInbox(\n    contextId,\n    users,\n    managers,\n    publicMeta,\n    inboxNameAsPrivateMeta.encodeToByteArray()\n)\n```\n</Tab>\n<Tab value=\"With publicMeta\">\nYou can implement a tag system, which allows you to create Inboxes with arbitrary tags. Putting them inside `publicMeta` gives your own server the ability to access it using Bridge REST API.\n\nDefine Inbox public meta structure:\n```kotlin\n@Serializable\ndata class InboxPublicMeta(val tags: List<String>)",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/java/inboxes.mdx",
        "type": "mdx",
        "chunkIndex": 3,
        "codeBlocks": [
          "```\n</Tab>\n\n<Tab value=\"With a Name\">\nYou can assign any data to private and public meta fields (e.g. the Inbox's name), as long as it is serialized to byte array:\n```",
          "```\n</Tab>\n<Tab value=\"With publicMeta\">\nYou can implement a tag system, which allows you to create Inboxes with arbitrary tags. Putting them inside `publicMeta` gives your own server the ability to access it using Bridge REST API.\n\nDefine Inbox public meta structure:\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.892Z",
        "size": 1083
      }
    },
    {
      "pageContent": "```\n\nPrepare and create Inbox:\n```kotlin\nval users : List<UserWithPubKey> = listOf(\n    UserWithPubKey(user1Id, user1PublicKey),\n    UserWithPubKey(user2Id, user2PublicKey)\n)\nval managers : List<UserWithPubKey> = listOf(\n    UserWithPubKey(user1Id, user1PublicKey)\n)\nval publicMeta = InboxPublicMeta(\n    listOf(\"TAG1\", \"TAG2\", \"TAG3\")\n)\nval inboxNameAsPrivateMeta = \"New inbox\"\n\nval inboxID = inboxApi.createInbox(\n    contextId,\n    users,\n    managers,\n    Json.encodeToString(publicMeta).encodeToByteArray(),\n    inboxNameAsPrivateMeta.encodeToByteArray()\n)\n```\n</Tab>\n</Tabs>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/java/inboxes.mdx",
        "type": "mdx",
        "chunkIndex": 4,
        "codeBlocks": [
          "```\n\nPrepare and create Inbox:\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.892Z",
        "size": 580
      }
    },
    {
      "pageContent": "## Getting Inboxes\n\nDefine Inbox item class with decoded `publicMeta` and `privateMeta`:\n```kotlin\ndata class InboxItem(\n    val inbox: Inbox,\n    val decodedPrivateMeta: String,\n    val decodedPublicMeta: InboxPublicMeta\n)",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/java/inboxes.mdx",
        "type": "mdx",
        "chunkIndex": 5,
        "headers": [
          "Getting Inboxes"
        ],
        "title": "Getting Inboxes",
        "lastModified": "2025-06-05T19:33:57.892Z",
        "size": 223
      }
    },
    {
      "pageContent": "```\n\n<Tabs groupId=\"variant\" items={[\"Most Recent\",\"Oldest\",\"By inboxId\"]}>\n<Tab value=\"Most Recent\">\nFetching the most recent Inboxes in given Context:\n```kotlin\nval startIndex = 0L\nval pageSize = 100L\n\nval inboxesPagingList = inboxApi.listInboxes(\n    contextId,\n    startIndex,\n    pageSize,\n    SortOrder.DESC\n)\n\nval inboxes = inboxesPagingList.readItems.map {\n    InboxItem(\n        it,\n        it.privateMeta.decodeToString(),\n        Json.decodeFromString(it.publicMeta.decodeToString())\n    )\n}\n```\n</Tab>\n\n<Tab value=\"Oldest\">\nFetching the oldest Inboxes (by creation date) in given Context:\n```kotlin\nval startIndex = 0L\nval pageSize = 100L\n\nval inboxesPagingList = inboxApi.listInboxes(\n    contextId,\n    startIndex,\n    pageSize,\n    SortOrder.ASC\n)\n\nval inboxes = inboxesPagingList.readItems.map {\n    InboxItem(\n        it,\n        it.privateMeta.decodeToString(),\n        Json.decodeFromString(it.publicMeta.decodeToString())\n    )\n}\n```\n</Tab>\n<Tab value=\"By inboxID\">\nYou can get info about an Inbox using its `inboxId`:\n```kotlin\nval inboxID = \"INBOX_ID\"",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/java/inboxes.mdx",
        "type": "mdx",
        "chunkIndex": 6,
        "codeBlocks": [
          "```\n\n<Tabs groupId=\"variant\" items={[\"Most Recent\",\"Oldest\",\"By inboxId\"]}>\n<Tab value=\"Most Recent\">\nFetching the most recent Inboxes in given Context:\n```",
          "```\n</Tab>\n\n<Tab value=\"Oldest\">\nFetching the oldest Inboxes (by creation date) in given Context:\n```",
          "```\n</Tab>\n<Tab value=\"By inboxID\">\nYou can get info about an Inbox using its `inboxId`:\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.892Z",
        "size": 1073
      }
    },
    {
      "pageContent": "val inboxItem = inboxApi.getInbox(inboxID).let {\n    InboxItem(\n        it,\n        it.privateMeta.decodeToString(),\n        Json.decodeFromString(it.publicMeta.decodeToString())\n    )\n}\n```\n</Tab>\n</Tabs>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/java/inboxes.mdx",
        "type": "mdx",
        "chunkIndex": 7,
        "lastModified": "2025-06-05T19:33:57.892Z",
        "size": 205
      }
    },
    {
      "pageContent": "## Getting Public View\n\nUsers with public connection (created by [`Connection.platformConnectPublic`](../reference/privmx-endpoint-java/core/connection#platformconnectpublic))\nhave access to the Public View which shares not encrypted fields of the Inbox, such as `publicMeta`.\n\n```kotlin\nval inboxID = \"INBOX_ID\"\nval inboxPublicView = inboxApi.getInboxPublicView(inboxID)\nval inboxPublicMeta: InboxPublicMeta = Json.decodeFromString(\n    inboxPublicView.publicMeta.decodeToString()\n)\n```",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/java/inboxes.mdx",
        "type": "mdx",
        "chunkIndex": 8,
        "headers": [
          "Getting Public View"
        ],
        "title": "Getting Public View",
        "codeBlocks": [
          "```kotlin\nval inboxID = \"INBOX_ID\"\nval inboxPublicView = inboxApi.getInboxPublicView(inboxID)\nval inboxPublicMeta: InboxPublicMeta = Json.decodeFromString(\n    inboxPublicView.publicMeta.decodeToString()\n)\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.892Z",
        "size": 487
      }
    },
    {
      "pageContent": "## Managing Inboxes\n\n<Tabs groupId=\"variant\" items={[\"Renaming Inbox\",\"Removing User\",\"Deleting Inbox\"]}>\n<Tab value=\"Renaming Inbox\">\nTo update an Inbox you must always provide its current version, as well as:\n- list of users\n- list of managers\n- new private and public meta (even if it didn't change)\n- Inbox's current version\n- Inbox FilesConfig\n- `true` if update action should be forced\n\n```kotlin\nval inboxID = \"INBOX_ID\"\nval inbox: Inbox = inboxApi.getInbox(inboxID)\nval users = inbox\n    .users\n    .map { userId ->\n        //Your application must provide a way,\n        //to get user's public key from their userId.\n        UserWithPubKey(\n            userId,\n            \"USER_PUBLIC_KEY\"\n        )\n    }\nval managers = inbox\n    .managers\n    .map { userId ->\n        //Your application must provide a way,\n        //to get user's public key from their userId.\n        UserWithPubKey(\n            userId,\n            \"USER_PUBLIC_KEY\"\n        )\n    }\nval newInboxNameAsPrivateMeta = \"New inbox name\"",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/java/inboxes.mdx",
        "type": "mdx",
        "chunkIndex": 9,
        "headers": [
          "Managing Inboxes"
        ],
        "title": "Managing Inboxes",
        "lastModified": "2025-06-05T19:33:57.892Z",
        "size": 1010
      }
    },
    {
      "pageContent": "inboxApi.updateInbox(\n    inboxID,\n    users,\n    managers,\n    inbox.publicMeta,\n    newInboxNameAsPrivateMeta.encodeToByteArray(),\n    inbox.filesConfig,\n    inbox.version,\n    false\n)\n```\n</Tab>\n\n<Tab value=\"Removing User\">\nTo remove a user from an Inbox you must provide:\n- list of all the users, without the user you want to remove\n- list of managers\n- new private and public meta (even if it didn't change)\n- Inbox's current version\n- Inbox FilesConfig\n- `true` if update action should be forced\n\n```kotlin\nval inboxID = \"INBOX_ID\"\nval inbox: Inbox = inboxApi.getInbox(inboxID)\nval userToRemove = \"USERID_TO_REMOVE\"\nval newUsers = inbox\n    .users\n    .filter {\n        it != userToRemove\n    }.map { userId ->\n        //Your application must provide a way,\n        //to get user's public key from their userId.\n        UserWithPubKey(\n            userId,\n            \"USER_PUBLIC_KEY\"\n        )\n    }\nval managers = inbox\n    .managers\n    .map { userId ->\n        //Your application must provide a way,\n        //to get user's public key from their userId.\n        UserWithPubKey(\n            userId,\n            \"USER_PUBLIC_KEY\"\n        )\n    }",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/java/inboxes.mdx",
        "type": "mdx",
        "chunkIndex": 10,
        "codeBlocks": [
          "```\n</Tab>\n\n<Tab value=\"Removing User\">\nTo remove a user from an Inbox you must provide:\n- list of all the users, without the user you want to remove\n- list of managers\n- new private and public meta (even if it didn't change)\n- Inbox's current version\n- Inbox FilesConfig\n- `true` if update action should be forced\n\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.892Z",
        "size": 1154
      }
    },
    {
      "pageContent": "inboxApi.updateInbox(\n    inboxID,\n    newUsers,\n    managers,\n    inbox.publicMeta,\n    inbox.privateMeta,\n    inbox.filesConfig,\n    inbox.version,\n    false\n)\n```\n</Tab>\n\n<Tab value=\"Deleting Inbox\">\nThe snippet below deletes Inbox and all its data. This action is irreversible.\n```kotlin\nval inboxID = \"INBOX_ID\"\ninboxApi.deleteInbox(inboxID)\n```\n</Tab>\n\n</Tabs>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/java/inboxes.mdx",
        "type": "mdx",
        "chunkIndex": 11,
        "codeBlocks": [
          "```\n</Tab>\n\n<Tab value=\"Deleting Inbox\">\nThe snippet below deletes Inbox and all its data. This action is irreversible.\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.892Z",
        "size": 366
      }
    },
    {
      "pageContent": "---\ntitle: Overview\ndescription: This part of the documentation describes our solutions to simplify working with Privmx Endpoint C++ library inside Java Virtual Machines.\n---",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/java/introduction.mdx",
        "type": "mdx",
        "chunkIndex": 0,
        "lastModified": "2025-06-05T19:33:57.892Z",
        "size": 174
      }
    },
    {
      "pageContent": "## Libraries\n\n### Privmx Endpoint Java Extra\n\nPrivMX Endpoint Java Extra is the basic **recommended library** for using the platform in most cases.\nIt contains all the logic that makes using our libraries simple and secure.\nIt can be used on Java Virtual Machines (JVM).\n\nThis library implements:\n\n- Enums and static fields to reduce errors while using the methods.\n- [`PrivmxEndpoint`](../reference/privmx-endpoint-java-extra/core/privmx-endpoint) for managing connection and registering callbacks on any events.\n- [`PrivmxEndpointContainer`](../reference/privmx-endpoint-java-extra/core/privmx-endpoint-container) for managing global session with implemented event loop.\n- Classes to simplify reading/writing to files using byte arrays and InputStream/OutputStream.\n\n[Go to Reference](../reference/privmx-endpoint-java-extra/core/basic-privmx-endpoint) for a detailed description of each class\nor see the source code on [GitHub](https://github.com/simplito/privmx-endpoint-java/tree/main/privmx-endpoint-extra).",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/java/introduction.mdx",
        "type": "mdx",
        "chunkIndex": 1,
        "headers": [
          "Libraries",
          "Privmx Endpoint Java Extra"
        ],
        "title": "Libraries",
        "lastModified": "2025-06-05T19:33:57.892Z",
        "size": 1013
      }
    },
    {
      "pageContent": "### Privmx Endpoint Java Android\n\nPrivMX Endpoint Java Android is an extension of `Privmx Endpoint Java Extra` with logic specifically for **Android**.\n\nThis library implements:\n\n- [`PrivmxEndpointService`](../reference/privmx-endpoint-java-android/core/privmx-endpoint-service) - an Android Service that manages PrivMX Endpoint Java Extra library and handles app lifecycle changes.\n- [`PrivmxEndpointBaseActivity`](../reference/privmx-endpoint-java-android/core/privmx-endpoint-base-activity) - Android Activity that configures and binds to [`PrivmxEndpointService`](../reference/privmx-endpoint-java-android/core/privmx-endpoint-service).\n\n[Go to Reference](../reference/privmx-endpoint-java-android/core/privmx-endpoint-base-activity) for a detailed description of each class\nor see the source code on [GitHub](https://github.com/simplito/privmx-endpoint-java/tree/main/privmx-endpoint-android).",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/java/introduction.mdx",
        "type": "mdx",
        "chunkIndex": 2,
        "headers": [
          "Privmx Endpoint Java Android"
        ],
        "title": "Privmx Endpoint Java Android",
        "lastModified": "2025-06-05T19:33:57.893Z",
        "size": 898
      }
    },
    {
      "pageContent": "### Privmx Endpoint Java\n\nPrivMX Endpoint Java is the minimal wrapper library, crucial for the platform's functioning. It declares native functions in Java using JNI.\nSince it's the most minimal library available, it gives you the most freedom with adjusting the platform to your requirements.\nIt can be used on Java Virtual Machines (JVM).\n\nThis library implements models, exception catching, and the following modules:\n- `CryptoApi` - Cryptographic methods used to encrypt/decrypt and sign your data or generate keys to work with Privmx Bridge.\n- `Connection` - Methods for managing connection with Privmx Bridge.\n- `ThreadApi` - Methods for managing Threads and sending/reading messages.\n- `StoreApi` - Methods for managing Stores and sending/reading files.\n- `InboxApi` - Methods for managing Inboxes and entries.\n\n[Go to Reference](../reference/privmx-endpoint-java/core/backend-requester) for a detailed description of each class\nor see the source code on [GitHub](https://github.com/simplito/privmx-endpoint-java/tree/main/privmx-endpoint).",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/java/introduction.mdx",
        "type": "mdx",
        "chunkIndex": 3,
        "headers": [
          "Privmx Endpoint Java"
        ],
        "title": "Privmx Endpoint Java",
        "lastModified": "2025-06-05T19:33:57.893Z",
        "size": 1047
      }
    },
    {
      "pageContent": "## Gradle Plugins\n\n### Privmx Endpoint Install Native\n\nPrivmx Endpoint Install Native is a gradle plugin that automates the process of downloading and installing native libraries into your project.\n\n[Read more about the plugin.](./plugin-configuration)",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/java/introduction.mdx",
        "type": "mdx",
        "chunkIndex": 4,
        "headers": [
          "Gradle Plugins",
          "Privmx Endpoint Install Native"
        ],
        "title": "Gradle Plugins",
        "lastModified": "2025-06-05T19:33:57.893Z",
        "size": 252
      }
    },
    {
      "pageContent": "---\ntitle: Messages\n---\n\n\n\nSending messages in Threads.\n\n:::info\n\nThe sample code on this page is based on the **[initial assumptions](./introduction#initial-assumptions)**.\n\n:::\n\n:::info\n\nMessage `data`, `publicMeta` and `privateMeta` fields support any kind of data formats encoded to byte arrays. Examples in this section use `kotlinx-serialization-json-jvm` dependency for Kotlin and `com.google.code.gson:gson` for Java to serialize object to JSON format.\n\n:::\n\n## Messages inside Threads\nMessages inside Threads are sent in binary format. Before sending a message, you need to decide on the message format and choose the appropriate data serialization method.\n\nFor more information about the Threads architecture and best practices for sending messages, visit the [Threads Documentation](../start/threads/messages).",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/java/messages.mdx",
        "type": "mdx",
        "chunkIndex": 0,
        "headers": [
          "Messages inside Threads"
        ],
        "title": "Messages inside Threads",
        "lastModified": "2025-06-05T19:33:57.893Z",
        "size": 821
      }
    },
    {
      "pageContent": "## Sending Messages\n\n<Tabs groupId=\"variant\" items={[\"Plain Text\", \"With Public Meta\",\"\"]}>\n<Tab value=\"Plain Text\">\nExample of sending a message in Plain Text:\n```kotlin\nval threadID = \"THREAD_ID\"\nval message = \"Message text\"\nval publicMeta = ByteArray(0)\nval privateMeta = ByteArray(0)\n\nval messageID = threadApi.sendMessage(\n    threadID,\n    publicMeta,\n    privateMeta,\n    message.encodeToByteArray()\n)\n```\n</Tab>\n<Tab value='With Public Meta'>\nThe snippet below shows how to set up a feature allowing users to respond to messages.\n\nDefine message public meta structure:\n```kotlin\n@Serializable\ndata class MessagePublicMeta(\n    val responseTo: String\n)\n```\nPrepare and send the message:\n\n```kotlin\nval threadID = \"THREAD_ID\"\nval message = \"Message text\"\nval publicMeta = MessagePublicMeta(responseTo = \"MESSAGE_ID_TO_RESPOND\")\nval privateMeta = ByteArray(0)\n\nval messageID = threadApi.sendMessage(\n    threadID,\n    Json.encodeToString(publicMeta).encodeToByteArray(),\n    privateMeta,\n    message.encodeToByteArray()\n)\n```\n</Tab>\n</Tabs>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/java/messages.mdx",
        "type": "mdx",
        "chunkIndex": 1,
        "headers": [
          "Sending Messages"
        ],
        "title": "Sending Messages",
        "codeBlocks": [
          "```kotlin\nval threadID = \"THREAD_ID\"\nval message = \"Message text\"\nval publicMeta = ByteArray(0)\nval privateMeta = ByteArray(0)\n\nval messageID = threadApi.sendMessage(\n    threadID,\n    publicMeta,\n    privateMeta,\n    message.encodeToByteArray()\n)\n```",
          "```kotlin\n@Serializable\ndata class MessagePublicMeta(\n    val responseTo: String\n)\n```",
          "```kotlin\nval threadID = \"THREAD_ID\"\nval message = \"Message text\"\nval publicMeta = MessagePublicMeta(responseTo = \"MESSAGE_ID_TO_RESPOND\")\nval privateMeta = ByteArray(0)\n\nval messageID = threadApi.sendMessage(\n    threadID,\n    Json.encodeToString(publicMeta).encodeToByteArray(),\n    privateMeta,\n    message.encodeToByteArray()\n)\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.893Z",
        "size": 1045
      }
    },
    {
      "pageContent": "## Getting Messages\n\nDefine message item class with decoded `data` and `publicMeta`:\n\n```kotlin\ndata class MessageItem(\n    val message: Message,\n    val decodedData: String,\n    val decodedPublicMeta: MessagePublicMeta\n)",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/java/messages.mdx",
        "type": "mdx",
        "chunkIndex": 2,
        "headers": [
          "Getting Messages"
        ],
        "title": "Getting Messages",
        "lastModified": "2025-06-05T19:33:57.893Z",
        "size": 221
      }
    },
    {
      "pageContent": "```\n\n<Tabs groupId=\"variant\" items={[\"Most Recent\",\"Oldest\",\"By Message ID\"]}>\n<Tab value=\"Most Recent\">\nFetching the most recent messages in given Thread:\n\n```kotlin\nval threadId = \"THREAD_ID\"\nval startIndex = 0L\nval pageSize = 100L\n\nval messagesPagingList = threadApi.listMessages(\n    threadId,\n    startIndex,\n    pageSize,\n    SortOrder.DESC\n)\n\nval messages = messagesPagingList.readItems.map {\n    MessageItem(\n        it,\n        it.data.decodeToString(),\n        Json.decodeFromString(it.publicMeta.decodeToString())\n    )\n}\n```\n</Tab>\n\n<Tab value=\"Oldest\">\nFetching the oldest messages (by creation date) in given Thread:\n\n```kotlin\nval threadId = \"THREAD_ID\"\nval startIndex = 0L\nval pageSize = 100L\n\nval messagesPagingList = threadApi.listMessages(\n    threadId,\n    startIndex,\n    pageSize,\n    SortOrder.ASC\n)\n\nval messages = messagesPagingList.readItems.map {\n    MessageItem(\n        it,\n        it.data.decodeToString(),\n        Json.decodeFromString(it.publicMeta.decodeToString())\n    )\n}\n```\n</Tab>\n<Tab value=\"By Message ID\">\nYou can get info about a Message using its `messageId`:\n\n```kotlin\nval messageId = \"MESSAGE_ID\"",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/java/messages.mdx",
        "type": "mdx",
        "chunkIndex": 3,
        "codeBlocks": [
          "```\n\n<Tabs groupId=\"variant\" items={[\"Most Recent\",\"Oldest\",\"By Message ID\"]}>\n<Tab value=\"Most Recent\">\nFetching the most recent messages in given Thread:\n\n```",
          "```\n</Tab>\n\n<Tab value=\"Oldest\">\nFetching the oldest messages (by creation date) in given Thread:\n\n```",
          "```\n</Tab>\n<Tab value=\"By Message ID\">\nYou can get info about a Message using its `messageId`:\n\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.893Z",
        "size": 1141
      }
    },
    {
      "pageContent": "```kotlin\nval messageId = \"MESSAGE_ID\"\n\nval messageItem = threadApi.getMessage(messageId).let {\n    MessageItem(\n        it,\n        it.data.decodeToString(),\n        Json.decodeFromString(it.publicMeta.decodeToString())\n    )\n}\n```\n</Tab>\n</Tabs>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/java/messages.mdx",
        "type": "mdx",
        "chunkIndex": 4,
        "codeBlocks": [
          "```kotlin\nval messageId = \"MESSAGE_ID\"\n\nval messageItem = threadApi.getMessage(messageId).let {\n    MessageItem(\n        it,\n        it.data.decodeToString(),\n        Json.decodeFromString(it.publicMeta.decodeToString())\n    )\n}\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.893Z",
        "size": 247
      }
    },
    {
      "pageContent": "## Managing Messages\n\n<Tabs groupId=\"variant\" items={[\"Updating Message\",\"Deleting Message\"]}>\n<Tab value=\"Updating Message\">\nExample of updating the message content:\n\n```kotlin\nval messageID = \"MESSAGE_ID\"\nval message: Message = threadApi.getMessage(messageID)\nval newMessage = \"New message\"\n\nthreadApi.updateMessage(\n    messageID,\n    message.publicMeta,\n    message.privateMeta,\n    newMessage.encodeToByteArray()\n)\n```\n</Tab>\n\n<Tab value=\"Deleting Message\">\nThe snippet below deletes Message and all its data. This action is irreversible.\n```kotlin\nval messageID = \"MESSAGE_ID\"\nthreadApi.deleteMessage(messageID)\n```\n</Tab>\n\n</Tabs>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/java/messages.mdx",
        "type": "mdx",
        "chunkIndex": 5,
        "headers": [
          "Managing Messages"
        ],
        "title": "Managing Messages",
        "codeBlocks": [
          "```kotlin\nval messageID = \"MESSAGE_ID\"\nval message: Message = threadApi.getMessage(messageID)\nval newMessage = \"New message\"\n\nthreadApi.updateMessage(\n    messageID,\n    message.publicMeta,\n    message.privateMeta,\n    newMessage.encodeToByteArray()\n)\n```",
          "```kotlin\nval messageID = \"MESSAGE_ID\"\nthreadApi.deleteMessage(messageID)\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.893Z",
        "size": 637
      }
    },
    {
      "pageContent": "---\ntitle: Plugin Configuration\n---\n\nThe `com.simplito.privmx-endpoint-install-native` Gradle plugin automates the process of downloading\nand installing shared libraries from [GitHub releases](https://github.com/simplito/privmx-endpoint-java/releases) assets\ninto the module directory with version specified in `privmxEndpointInstallJni` task configuration.\nThe downloaded libraries are installed in the `src/main/jniLibs` directory of your module.\nThe source code of this plugin is available on [GitHub](https://github.com/simplito/privmx-endpoint-java-tools).\n\n## Options\n\n### `version` (required)\nThe version of the native shared libraries to download.\n\n`public String version`\n\n\n### `platforms` (optional)\nA list of platforms (as a pair of operating system and architecture) for which to download the native shared library.\nThe default is the building platform.\n\n`public List<PrivmxEndpointPlatform> platforms`",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/java/plugin-configuration.mdx",
        "type": "mdx",
        "chunkIndex": 0,
        "headers": [
          "Options",
          "`version` (required)",
          "`platforms` (optional)"
        ],
        "title": "Options",
        "lastModified": "2025-06-05T19:33:57.893Z",
        "size": 914
      }
    },
    {
      "pageContent": "## Usage\n\n<div className={'fd-steps'}>\n<div className={'fd-step'}>\n\n Add `mavenCentral()` repository to your `settings.gradle`:\n\n```groovy\npluginManagement {\n    repositories{\n        mavenCentral()\n    }\n}\n```\n\n</div>\n\n    <div className={'fd-step'}>\n Add plugin in `build.gradle`:\n\n```groovy\nplugins {\n    id \"com.simplito.privmx-endpoint-install-native\" version \"$pluginVersion\"\n}\n```\n    </div>\n        <div className={'fd-step'}>\n Configure plugin in `build.gradle`:\n\n```groovy\nprivmxEndpointInstallJni{\n    version = $nativeLibVersion // Set the version of library to download, it should\n                                // match the privmx-endpoint-java dependency version\n\n    // Set project supported platforms to download native libraries for them.\n    platforms = [\n            SupportedPlatforms.Darwin.arm64.platform,\n            *SupportedPlatforms.Android.values().platform\n    ]\n}\n```\n    </div>\n</div>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/java/plugin-configuration.mdx",
        "type": "mdx",
        "chunkIndex": 1,
        "headers": [
          "Usage"
        ],
        "title": "Usage",
        "codeBlocks": [
          "```groovy\npluginManagement {\n    repositories{\n        mavenCentral()\n    }\n}\n```",
          "```groovy\nplugins {\n    id \"com.simplito.privmx-endpoint-install-native\" version \"$pluginVersion\"\n}\n```",
          "```groovy\nprivmxEndpointInstallJni{\n    version = $nativeLibVersion // Set the version of library to download, it should\n                                // match the privmx-endpoint-java dependency version\n\n    // Set project supported platforms to download native libraries for them.\n    platforms = [\n            SupportedPlatforms.Darwin.arm64.platform,\n            *SupportedPlatforms.Android.values().platform\n    ]\n}\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.893Z",
        "size": 917
      }
    },
    {
      "pageContent": "---\ntitle: Policy Builders\n---\n\n\n\nPrivMX Endpoint has configurable policies that determine who can perform specified actions in Containers and Items. To learn more about them, see the [Policies documentation](../start/concepts/policies).\n\nPrivMX Endpoint Java Extra library provides classes that provide static fields of available policy values in `ItemPolicyValues`, `ContainerPolicyValues` and `SpecialPolicyValue`,\nas well as `ItemPolicyBuilder` and `ContainerPolicyBuilder` classes for configuring the respective policies.\n\n## Combining Policy Values\n\nSome policy values like `ContainerPolicyComplexValue` or `ItemPolicyComplexValue` can be combined\nwith the same type of policy value using `.AND()` or `.OR()` methods.",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/java/policy-builders.mdx",
        "type": "mdx",
        "chunkIndex": 0,
        "headers": [
          "Combining Policy Values"
        ],
        "title": "Combining Policy Values",
        "lastModified": "2025-06-05T19:33:57.894Z",
        "size": 723
      }
    },
    {
      "pageContent": "## Configuring a Container Policy\n\nBuilder will create an empty policy, if it's not configured yet, which is equivalent to setting `inherit` in all fields. To configure it, call the methods responsible for setting particular policies.\nThose calls can be chained together, since each of the methods setting a policy value returns the reference to the builder.\nThe `ContainerPolicyBuilder` can build both `ContainerPolicy` and `ContainerPolicyWithoutItem` by calling `.build()` and `.buildWithoutItem()` respectively.\n\nTo build the `ItemPolicy`, use `ItemPolicyBuilder` which works in the same way as `ContainerPolicyBuilder`:\n\n<Tabs items={[\"ItemPolicy\",\"ContainerPolicyWithoutItem\",\"ContainerPolicy\"]}>\n\n<Tab>\n    ```kotlin \n    val itemPolicy: ItemPolicy = ItemPolicyBuilder()\n    .setUpdate(\n        ItemPolicyValues.ITEM_OWNER\n            .AND(ItemPolicyValues.MANAGER)\n            .OR(ItemPolicyValues.USER)\n    )\n    .setListMy(ContainerPolicyValues.USER)\n    .build()\n    ```\n</Tab>\n\n<Tab>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/java/policy-builders.mdx",
        "type": "mdx",
        "chunkIndex": 1,
        "headers": [
          "Configuring a Container Policy"
        ],
        "title": "Configuring a Container Policy",
        "codeBlocks": [
          "```kotlin \n    val itemPolicy: ItemPolicy = ItemPolicyBuilder()\n    .setUpdate(\n        ItemPolicyValues.ITEM_OWNER\n            .AND(ItemPolicyValues.MANAGER)\n            .OR(ItemPolicyValues.USER)\n    )\n    .setListMy(ContainerPolicyValues.USER)\n    .build()\n    ```"
        ],
        "lastModified": "2025-06-05T19:33:57.894Z",
        "size": 995
      }
    },
    {
      "pageContent": "<Tab>\n\n    ```kotlin\n    val containerPolicyWithoutItem: ContainerPolicyWithoutItem = ContainerPolicyBuilder()\n    .setGet(\n        ContainerPolicyValues.ALL\n    ).setUpdatePolicy(\n        ContainerPolicyValues.OWNER\n        .AND(ContainerPolicyValues.MANAGER) \n    ).buildWithoutItem()",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/java/policy-builders.mdx",
        "type": "mdx",
        "chunkIndex": 2,
        "lastModified": "2025-06-05T19:33:57.894Z",
        "size": 286
      }
    },
    {
      "pageContent": "```\n\n</Tab>\n\n<Tab>\n```kotlin\nval containerPolicy: ContainerPolicy = ContainerPolicyBuilder()\n    .setGet(ContainerPolicyValues.ALL)\n    .setItem(\n        ItemPolicyBuilder()\n            .setUpdate(\n                ItemPolicyValues.ITEM_OWNER\n                    .AND(ItemPolicyValues.MANAGER)\n                    .OR(ItemPolicyValues.USER)\n            )\n            .setListMy(ContainerPolicyValues.USER)\n            .build()\n    )\n    .build()\n```\n</Tab>\n</Tabs>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/java/policy-builders.mdx",
        "type": "mdx",
        "chunkIndex": 3,
        "codeBlocks": [
          "```\n\n</Tab>\n\n<Tab>\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.894Z",
        "size": 463
      }
    },
    {
      "pageContent": "---\ntitle: Stores\n---\n\n\nStores provide encrypted block storage, enabling simple file uploading and downloading.\n\n:::info\n\nBefore working with Stores, follow our [Getting Started Guide](./introduction). It will show you how to set up your project to work with PrivMX Bridge.\n\nThe sample code on this page is based on the **[initial assumptions](./introduction#initial-assumptions)**.\n\n:::\n\n:::info\n\nStore `publicMeta` and `privateMeta` fields support any kind of data formats encoded to byte arrays. Examples in this section use `kotlinx-serialization-json-jvm` dependency for Kotlin and `com.google.code.gson:gson` for Java to serialize object to JSON format.\n\n:::\n\n## Working with Stores\n\nTo access Store methods, get the field `storeApi` from active connection. Connection should be initialized with `Modules.STORE` passed to [`PrivmxEndpoint()`](../reference/privmx-endpoint-java-extra/core/privmx-endpoint#privmxendpoint-1).\n\n```kotlin\nval storeApi = endpointSession.storeApi\n```",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/java/stores.mdx",
        "type": "mdx",
        "chunkIndex": 0,
        "headers": [
          "Working with Stores"
        ],
        "title": "Working with Stores",
        "codeBlocks": [
          "```kotlin\nval storeApi = endpointSession.storeApi\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.895Z",
        "size": 983
      }
    },
    {
      "pageContent": "## Creating Stores\n\n<Tabs groupId=\"variant\" items={[\"Basic\",\"With a Name\",\"With publicMeta\"]}>\n<Tab value=\"basic\" label=\"Basic\">\nCreating a basic, unnamed Store, which can act as an encrypted data container:\n```kotlin\nval users : List<UserWithPubKey> = listOf(\n    UserWithPubKey(user1Id, user1PublicKey),\n    UserWithPubKey(user2Id, user2PublicKey)\n)\nval managers : List<UserWithPubKey> = listOf(\n    UserWithPubKey(user1Id, user1PublicKey)\n)\nval publicMeta = ByteArray(0)\nval privateMeta = ByteArray(0)\n\nval storeId = storeApi.createStore(\n    contextId,\n    users,\n    managers,\n    publicMeta,\n    privateMeta\n)\n```\n</Tab>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/java/stores.mdx",
        "type": "mdx",
        "chunkIndex": 1,
        "headers": [
          "Creating Stores"
        ],
        "title": "Creating Stores",
        "codeBlocks": [
          "```kotlin\nval users : List<UserWithPubKey> = listOf(\n    UserWithPubKey(user1Id, user1PublicKey),\n    UserWithPubKey(user2Id, user2PublicKey)\n)\nval managers : List<UserWithPubKey> = listOf(\n    UserWithPubKey(user1Id, user1PublicKey)\n)\nval publicMeta = ByteArray(0)\nval privateMeta = ByteArray(0)\n\nval storeId = storeApi.createStore(\n    contextId,\n    users,\n    managers,\n    publicMeta,\n    privateMeta\n)\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.895Z",
        "size": 626
      }
    },
    {
      "pageContent": "val storeId = storeApi.createStore(\n    contextId,\n    users,\n    managers,\n    publicMeta,\n    privateMeta\n)\n```\n</Tab>\n\n<Tab value=\"With a Name\">\nYou can assign any data to private and public meta fields (e.g. the Store's name), as long as they are serialized to byte array:\n```kotlin\nval users : List<UserWithPubKey> = listOf(\n    UserWithPubKey(user1Id, user1PublicKey),\n    UserWithPubKey(user2Id, user2PublicKey)\n)\nval managers : List<UserWithPubKey> = listOf(\n    UserWithPubKey(user1Id, user1PublicKey)\n)\nval publicMeta = ByteArray(0)\nval storeNameAsPrivateMeta = \"New store\"\nval storeId = storeApi.createStore(\n    contextId,\n    users,\n    managers,\n    publicMeta,\n    storeNameAsPrivateMeta.encodeToByteArray()\n)\n```\n</Tab>\n<Tab value=\"With publicMeta\">\nYou can implement a tag system which allows you to create Stores with arbitrary tags. Putting them inside `publicMeta` gives your own server the ability to access it using Bridge REST API:\n\nDefine Store public meta structure:\n```kotlin\n@Serializable\ndata class StorePublicMeta(val tags: List<String>)",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/java/stores.mdx",
        "type": "mdx",
        "chunkIndex": 2,
        "codeBlocks": [
          "```\n</Tab>\n\n<Tab value=\"With a Name\">\nYou can assign any data to private and public meta fields (e.g. the Store's name), as long as they are serialized to byte array:\n```",
          "```\n</Tab>\n<Tab value=\"With publicMeta\">\nYou can implement a tag system which allows you to create Stores with arbitrary tags. Putting them inside `publicMeta` gives your own server the ability to access it using Bridge REST API:\n\nDefine Store public meta structure:\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.895Z",
        "size": 1066
      }
    },
    {
      "pageContent": "```\n\nPrepare and create Store:\n```kotlin\nval users : List<UserWithPubKey> = listOf(\n    UserWithPubKey(user1Id, user1PublicKey),\n    UserWithPubKey(user2Id, user2PublicKey)\n)\nval managers : List<UserWithPubKey> = listOf(\n    UserWithPubKey(user1Id, user1PublicKey)\n)\nval publicMeta = StorePublicMeta(\n    listOf(\"TAG1\", \"TAG2\", \"TAG3\")\n)\nval storeNameAsPrivateMeta = \"New store\"\n\nval storeID = storeApi.createStore(\n    contextId,\n    users,\n    managers,\n    Json.encodeToString(publicMeta).encodeToByteArray(),\n    storeNameAsPrivateMeta.encodeToByteArray()\n)\n```\n</Tab>\n</Tabs>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/java/stores.mdx",
        "type": "mdx",
        "chunkIndex": 3,
        "codeBlocks": [
          "```\n\nPrepare and create Store:\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.895Z",
        "size": 580
      }
    },
    {
      "pageContent": "## Getting Stores\n\nDefine Store item class with decoded `publicMeta` and `privateMeta`:\n```kotlin\ndata class StoreItem(\n    val store: Store,\n    val decodedPrivateMeta: String,\n    val decodedPublicMeta: StorePublicMeta\n)",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/java/stores.mdx",
        "type": "mdx",
        "chunkIndex": 4,
        "headers": [
          "Getting Stores"
        ],
        "title": "Getting Stores",
        "lastModified": "2025-06-05T19:33:57.895Z",
        "size": 222
      }
    },
    {
      "pageContent": "```\n\n<Tabs groupId=\"variant\" items={[\"Most Recent\",\"Oldest\",\"By Store ID\"]}>\n<Tab value=\"Most Recent\">\nFetching the most recent Stores in given Context:\n```kotlin\nval startIndex = 0L\nval pageSize = 100L\n\nval storesPagingList = storeApi.listStores(\n    contextId,\n    startIndex,\n    pageSize,\n    SortOrder.DESC\n)\n\nval stores = storesPagingList.readItems.map {\n    StoreItem(\n        it,\n        it.privateMeta.decodeToString(),\n        Json.decodeFromString(it.publicMeta.decodeToString())\n    )\n}\n```\n</Tab>\n\n<Tab value=\"Oldest\">\nFetching the oldest Stores (by creation date) in given Context:\n```kotlin\nval startIndex = 0L\nval pageSize = 100L\n\nval storesPagingList = storeApi.listStores(\n    contextId,\n    startIndex,\n    pageSize,\n    SortOrder.ASC\n)\n\nval stores = storesPagingList.readItems.map {\n    StoreItem(\n        it,\n        it.privateMeta.decodeToString(),\n        Json.decodeFromString(it.publicMeta.decodeToString())\n    )\n}\n```\n</Tab>\n<Tab value=\"By Store ID\">\nYou can get info about a Store using its `storeId`:\n```kotlin\nval storeId = \"STORE_ID\"",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/java/stores.mdx",
        "type": "mdx",
        "chunkIndex": 5,
        "codeBlocks": [
          "```\n\n<Tabs groupId=\"variant\" items={[\"Most Recent\",\"Oldest\",\"By Store ID\"]}>\n<Tab value=\"Most Recent\">\nFetching the most recent Stores in given Context:\n```",
          "```\n</Tab>\n\n<Tab value=\"Oldest\">\nFetching the oldest Stores (by creation date) in given Context:\n```",
          "```\n</Tab>\n<Tab value=\"By Store ID\">\nYou can get info about a Store using its `storeId`:\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.895Z",
        "size": 1064
      }
    },
    {
      "pageContent": "val storeItem = storeApi.getStore(storeId).let {\n    StoreItem(\n        it,\n        it.privateMeta.decodeToString(),\n        Json.decodeFromString(it.publicMeta.decodeToString())\n    )\n}\n```\n</Tab>\n</Tabs>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/java/stores.mdx",
        "type": "mdx",
        "chunkIndex": 6,
        "lastModified": "2025-06-05T19:33:57.895Z",
        "size": 205
      }
    },
    {
      "pageContent": "## Managing Stores\n\n<Tabs groupId=\"variant\" items={[\"Renaming Store\",\"Removing User\",\"Deleting Store\"]}>\n<Tab value=\"Renaming Store\">\nTo update a Store you must always provide its current version, as well as:\n- list of users\n- list of managers\n- new private and public meta (even if it didn't change)\n- Store's current version\n- `true` if update action should be forced\n\n```kotlin\nval storeID = \"STORE_ID\"\nval store: Store = storeApi.getStore(storeID)\nval users = store\n    .users\n    .map { userId ->\n        //Your application must provide a way,\n        //to get user's public key from their userId.\n        UserWithPubKey(\n            userId,\n            \"USER_PUBLIC_KEY\"\n        )\n    }\nval managers = store\n    .managers\n    .map { userId ->\n        //Your application must provide a way,\n        //to get user's public key from their userId.\n        UserWithPubKey(\n            userId,\n            \"USER_PUBLIC_KEY\"\n        )\n    }\nval newStoreNameAsPrivateMeta = \"New store name\"\n\nstoreApi.updateStore(\n    storeID,\n    users,\n    managers,\n    store.publicMeta,\n    newStoreNameAsPrivateMeta.encodeToByteArray(),\n    store.version,\n    false\n)\n```\n</Tab>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/java/stores.mdx",
        "type": "mdx",
        "chunkIndex": 7,
        "headers": [
          "Managing Stores"
        ],
        "title": "Managing Stores",
        "codeBlocks": [
          "```kotlin\nval storeID = \"STORE_ID\"\nval store: Store = storeApi.getStore(storeID)\nval users = store\n    .users\n    .map { userId ->\n        //Your application must provide a way,\n        //to get user's public key from their userId.\n        UserWithPubKey(\n            userId,\n            \"USER_PUBLIC_KEY\"\n        )\n    }\nval managers = store\n    .managers\n    .map { userId ->\n        //Your application must provide a way,\n        //to get user's public key from their userId.\n        UserWithPubKey(\n            userId,\n            \"USER_PUBLIC_KEY\"\n        )\n    }\nval newStoreNameAsPrivateMeta = \"New store name\"\n\nstoreApi.updateStore(\n    storeID,\n    users,\n    managers,\n    store.publicMeta,\n    newStoreNameAsPrivateMeta.encodeToByteArray(),\n    store.version,\n    false\n)\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.895Z",
        "size": 1164
      }
    },
    {
      "pageContent": "storeApi.updateStore(\n    storeID,\n    users,\n    managers,\n    store.publicMeta,\n    newStoreNameAsPrivateMeta.encodeToByteArray(),\n    store.version,\n    false\n)\n```\n</Tab>\n\n<Tab value=\"Removing User\">\nTo remove a user from a Store you must provide:\n- list of all the users, without the user you want to remove\n- list of managers\n- new private and public meta (even if it didn't change)\n- Store's current version\n- `true` if update action should be forced\n\n```kotlin\nval storeID = \"STORE_ID\"\nval store: Store = storeApi.getStore(storeID)\nval userToRemove = \"USERID_TO_REMOVE\"\nval newUsers = store\n    .users\n    .filter {\n        it != userToRemove\n    }.map { userId ->\n        //Your application must provide a way,\n        //to get user's public key from their userId.\n        UserWithPubKey(\n            userId,\n            \"USER_PUBLIC_KEY\"\n        )\n    }\nval managers = store\n    .managers\n    .map { userId ->\n        //Your application must provide a way,\n        //to get user's public key from their userId.\n        UserWithPubKey(\n            userId,\n            \"USER_PUBLIC_KEY\"\n        )\n    }",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/java/stores.mdx",
        "type": "mdx",
        "chunkIndex": 8,
        "codeBlocks": [
          "```\n</Tab>\n\n<Tab value=\"Removing User\">\nTo remove a user from a Store you must provide:\n- list of all the users, without the user you want to remove\n- list of managers\n- new private and public meta (even if it didn't change)\n- Store's current version\n- `true` if update action should be forced\n\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.895Z",
        "size": 1110
      }
    },
    {
      "pageContent": "storeApi.updateStore(\n    storeID,\n    newUsers,\n    managers,\n    store.publicMeta,\n    store.privateMeta,\n    store.version,\n    false\n)\n```\n</Tab>\n\n<Tab value=\"Deleting Store\">\nThe snippet below deletes Store and all its data. This action is irreversible.\n```kotlin\nval storeID = \"STORE_ID\"\nstoreApi.deleteStore(storeID)\n```\n</Tab>\n\n</Tabs>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/java/stores.mdx",
        "type": "mdx",
        "chunkIndex": 9,
        "codeBlocks": [
          "```\n</Tab>\n\n<Tab value=\"Deleting Store\">\nThe snippet below deletes Store and all its data. This action is irreversible.\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.895Z",
        "size": 343
      }
    },
    {
      "pageContent": "---\ntitle: Threads\n---\n\n\n\nThreads are a secure way for assigned members to exchange encrypted messages.\n\n:::info\n\nBefore working with Threads, follow our [Getting Started Guide](./introduction). It will show you how to set up your project to work with PrivMX Bridge.\n\nThe sample code on this page is based on the **[initial assumptions](./introduction#initial-assumptions)**.\n\n:::\n\n\n:::info\n\nThread `publicMeta` and `privateMeta` fields support any kind of data formats encoded to byte arrays. \nExamples in this section use `kotlinx-serialization-json-jvm` dependency for Kotlin and `com.google.code.gson:gson` for Java to serialize object to JSON format.\n\n:::\n\n## Working with Threads\n\nTo access Threads methods, get the field `threadApi` from active connection. Connection should be initialized with `Modules.THREAD` passed to [`PrivmxEndpoint()`](../reference/privmx-endpoint-java-extra/core/privmx-endpoint#privmxendpoint-1).\n\n```kotlin\nval threadApi: ThreadApi = endpointSession.threadApi\n```",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/java/threads.mdx",
        "type": "mdx",
        "chunkIndex": 0,
        "headers": [
          "Working with Threads"
        ],
        "title": "Working with Threads",
        "codeBlocks": [
          "```kotlin\nval threadApi: ThreadApi = endpointSession.threadApi\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.895Z",
        "size": 997
      }
    },
    {
      "pageContent": "## Creating Threads\n\n<Tabs groupId=\"variant\" items={[\"Basic\",\"With a Name\",\"With publicMeta\"]}>\n<Tab value=\"basic\" label=\"Basic\">\nCreating a basic, unnamed Thread, which can act as an encrypted data container.\n```kotlin\nval users : List<UserWithPubKey> = listOf(\n    UserWithPubKey(user1Id, user1PublicKey),\n    UserWithPubKey(user2Id, user2PublicKey)\n)\nval managers : List<UserWithPubKey> = listOf(\n    UserWithPubKey(user1Id, user1PublicKey)\n)\nval publicMeta = ByteArray(0)\nval privateMeta = ByteArray(0)\n\nval threadId = threadApi.createThread(\n    contextId,\n    users,\n    managers,\n    publicMeta,\n    privateMeta\n)\n```\n</Tab>\n\n<Tab value=\"With a Name\">\nYou can assign any data to private and public meta fields (e.g. the Thread's name), as long as they are serialized to byte array.\n```kotlin\nval users : List<UserWithPubKey> = listOf(\n    UserWithPubKey(user1Id, user1PublicKey),\n    UserWithPubKey(user2Id, user2PublicKey)\n)\nval managers : List<UserWithPubKey> = listOf(\n    UserWithPubKey(user1Id, user1PublicKey)\n)\nval threadNameAsPrivateMeta = \"New thread\"\nval publicMeta = ByteArray(0)",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/java/threads.mdx",
        "type": "mdx",
        "chunkIndex": 1,
        "headers": [
          "Creating Threads"
        ],
        "title": "Creating Threads",
        "codeBlocks": [
          "```kotlin\nval users : List<UserWithPubKey> = listOf(\n    UserWithPubKey(user1Id, user1PublicKey),\n    UserWithPubKey(user2Id, user2PublicKey)\n)\nval managers : List<UserWithPubKey> = listOf(\n    UserWithPubKey(user1Id, user1PublicKey)\n)\nval publicMeta = ByteArray(0)\nval privateMeta = ByteArray(0)\n\nval threadId = threadApi.createThread(\n    contextId,\n    users,\n    managers,\n    publicMeta,\n    privateMeta\n)\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.895Z",
        "size": 1097
      }
    },
    {
      "pageContent": "val threadId = threadApi.createThread(\n    contextId,\n    users,\n    managers,\n    publicMeta,\n    threadNameAsPrivateMeta.encodeToByteArray()\n)\n```\n</Tab>\n<Tab value=\"With publicMeta\">\nYou can implement a tag system which allows you to create Threads with arbitrary tags. Putting them inside `publicMeta` gives your own server ability to access it using Bridge REST API.\n\nDefine Thread public meta structure:\n```kotlin\n@Serializable\ndata class ThreadPublicMeta(val tags: List<String>)",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/java/threads.mdx",
        "type": "mdx",
        "chunkIndex": 2,
        "codeBlocks": [
          "```\n</Tab>\n<Tab value=\"With publicMeta\">\nYou can implement a tag system which allows you to create Threads with arbitrary tags. Putting them inside `publicMeta` gives your own server ability to access it using Bridge REST API.\n\nDefine Thread public meta structure:\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.895Z",
        "size": 485
      }
    },
    {
      "pageContent": "```\n\nPrepare and create Thread:\n```kotlin\nval users: List<UserWithPubKey> = listOf(\n    UserWithPubKey(user1Id, user1PublicKey),\n    UserWithPubKey(user2Id, user2PublicKey)\n)\nval managers: List<UserWithPubKey> = listOf(\n    UserWithPubKey(user1Id, user1PublicKey)\n)\nval threadNameAsPrivateMeta = \"New thread\"\nval publicMeta = ThreadPublicMeta(\n    listOf(\"TAG1\", \"TAG2\", \"TAG3\")\n)\n\nval threadId = threadApi.createThread(\n    contextId,\n    users,\n    managers,\n    Json.encodeToString(publicMeta).encodeToByteArray(),\n    threadNameAsPrivateMeta.encodeToByteArray()\n)\n```\n</Tab>\n</Tabs>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/java/threads.mdx",
        "type": "mdx",
        "chunkIndex": 3,
        "codeBlocks": [
          "```\n\nPrepare and create Thread:\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.895Z",
        "size": 586
      }
    },
    {
      "pageContent": "## Getting Threads\n\nDefine Thread item class with decoded `publicMeta` and `privateMeta`:\n```kotlin\ndata class ThreadItem(\n    val thread: com.simplito.java.privmx_endpoint.model.Thread,\n    val decodedPrivateMeta: String,\n    val decodedPublicMeta: ThreadPublicMeta\n)",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/java/threads.mdx",
        "type": "mdx",
        "chunkIndex": 4,
        "headers": [
          "Getting Threads"
        ],
        "title": "Getting Threads",
        "lastModified": "2025-06-05T19:33:57.895Z",
        "size": 268
      }
    },
    {
      "pageContent": "```\n\n<Tabs groupId=\"variant\" items={[\"Most Recent\",\"Oldest\",\"By `threadID`\"]}>\n<Tab  label=\"Most Recent\">\nFetching the most recent Threads in given Context:\n```kotlin\nval startIndex = 0L\nval pageSize = 100L\n\nval threadsPagingList = threadApi.listThreads(\n    contextId,\n    startIndex,\n    pageSize,\n    SortOrder.DESC\n)\nval threads = threadsPagingList.readItems.map {\n    ThreadItem(\n        it,\n        it.privateMeta.decodeToString(),\n        Json.decodeFromString(it.publicMeta.decodeToString())\n    )\n}\n```\n</Tab>\n\n<Tab value=\"oldest\" label=\"Oldest\">\nFetching the oldest Threads (by creation date) in given Context:\n```kotlin\nval startIndex = 0L\nval pageSize = 100L",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/java/threads.mdx",
        "type": "mdx",
        "chunkIndex": 5,
        "codeBlocks": [
          "```\n\n<Tabs groupId=\"variant\" items={[\"Most Recent\",\"Oldest\",\"By `threadID`\"]}>\n<Tab  label=\"Most Recent\">\nFetching the most recent Threads in given Context:\n```",
          "```\n</Tab>\n\n<Tab value=\"oldest\" label=\"Oldest\">\nFetching the oldest Threads (by creation date) in given Context:\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.895Z",
        "size": 670
      }
    },
    {
      "pageContent": "<Tab value=\"oldest\" label=\"Oldest\">\nFetching the oldest Threads (by creation date) in given Context:\n```kotlin\nval startIndex = 0L\nval pageSize = 100L\n\nval threadsPagingList = threadApi.listThreads(\n    contextId,\n    startIndex,\n    pageSize,\n    SortOrder.ASC\n)\nval threads = threadsPagingList.readItems.map {\n    ThreadItem(\n        it,\n        it.privateMeta.decodeToString(),\n        Json.decodeFromString(it.publicMeta.decodeToString())\n    )\n}\n```\n</Tab>\n<Tab value=\"By `threadId`\">\nYou can get info about a Thread using its `threadId`:\n```kotlin\nval threadId = \"THREAD_ID\"\nval threadItem = threadApi.getThread(threadId).let {\n    ThreadItem(\n        it,\n        it.privateMeta.decodeToString(),\n        Json.decodeFromString(it.publicMeta.decodeToString())\n    )\n}\n```\n</Tab>\n</Tabs>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/java/threads.mdx",
        "type": "mdx",
        "chunkIndex": 6,
        "codeBlocks": [
          "```kotlin\nval startIndex = 0L\nval pageSize = 100L\n\nval threadsPagingList = threadApi.listThreads(\n    contextId,\n    startIndex,\n    pageSize,\n    SortOrder.ASC\n)\nval threads = threadsPagingList.readItems.map {\n    ThreadItem(\n        it,\n        it.privateMeta.decodeToString(),\n        Json.decodeFromString(it.publicMeta.decodeToString())\n    )\n}\n```",
          "```kotlin\nval threadId = \"THREAD_ID\"\nval threadItem = threadApi.getThread(threadId).let {\n    ThreadItem(\n        it,\n        it.privateMeta.decodeToString(),\n        Json.decodeFromString(it.publicMeta.decodeToString())\n    )\n}\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.895Z",
        "size": 791
      }
    },
    {
      "pageContent": "## Managing Threads\n\n<Tabs groupId=\"variant\" items={[\"Renaming Thread\",\"Removing User\",\"Deleting Thread\"]}>\n<Tab value=\"Renaming Thread\">\nTo update a Thread you must always provide its current version, as well as:\n- list of users\n- list of managers\n- new private and public meta (even if it didn't change)\n- Thread's current version\n- `true` if update action should be forced\n\n```kotlin\nval threadID = \"THREAD_ID\"\nval thread: Thread = threadApi.getThread(threadID)\nval users = thread\n    .users\n    .map { userId ->\n        //Your application must provide a way,\n        //to get user's public key from their userId.\n        UserWithPubKey(\n            userId,\n            \"USER_PUBLIC_KEY\"\n        )\n    }\nval managers = thread\n    .managers\n    .map { userId ->\n        //Your application must provide a way,\n        //to get user's public key from their userId.\n        UserWithPubKey(\n            userId,\n            \"USER_PUBLIC_KEY\"\n        )\n    }\nval newThreadNameAsPrivateMeta = \"New thread name\"\n\nthreadApi.updateThread(\n    thread.threadId,\n    users,\n    managers,\n    thread.publicMeta,\n    newThreadNameAsPrivateMeta.encodeToByteArray(),\n    thread.version,\n    false\n)\n```\n</Tab>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/java/threads.mdx",
        "type": "mdx",
        "chunkIndex": 7,
        "headers": [
          "Managing Threads"
        ],
        "title": "Managing Threads",
        "codeBlocks": [
          "```kotlin\nval threadID = \"THREAD_ID\"\nval thread: Thread = threadApi.getThread(threadID)\nval users = thread\n    .users\n    .map { userId ->\n        //Your application must provide a way,\n        //to get user's public key from their userId.\n        UserWithPubKey(\n            userId,\n            \"USER_PUBLIC_KEY\"\n        )\n    }\nval managers = thread\n    .managers\n    .map { userId ->\n        //Your application must provide a way,\n        //to get user's public key from their userId.\n        UserWithPubKey(\n            userId,\n            \"USER_PUBLIC_KEY\"\n        )\n    }\nval newThreadNameAsPrivateMeta = \"New thread name\"\n\nthreadApi.updateThread(\n    thread.threadId,\n    users,\n    managers,\n    thread.publicMeta,\n    newThreadNameAsPrivateMeta.encodeToByteArray(),\n    thread.version,\n    false\n)\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.895Z",
        "size": 1194
      }
    },
    {
      "pageContent": "threadApi.updateThread(\n    thread.threadId,\n    users,\n    managers,\n    thread.publicMeta,\n    newThreadNameAsPrivateMeta.encodeToByteArray(),\n    thread.version,\n    false\n)\n```\n</Tab>\n\n<Tab value=\"Removing User\">\nTo remove a user from a Thread you must provide:\n- list of all the users, without the user you want to remove\n- list of managers\n- new private and public meta (even if it didn't change)\n- Thread's current version\n- `true` if update action should be forced\n\n```kotlin\nval threadID = \"THREAD_ID\"\nval thread: Thread = threadApi.getThread(threadID)\nval userToRemove = \"USER_ID_TO_REMOVE\"\nval newUsers = thread\n    .users\n    .filter {\n        it != userToRemove\n    }.map { userId ->\n        //Your application must provide a way,\n        //to get user's public key from their userId.\n        UserWithPubKey(\n            userId,\n            \"USER_PUBLIC_KEY\"\n        )\n    }\nval managers = thread\n    .managers\n    .map { userId ->\n        //Your application must provide a way,\n        //to get user's public key from their userId.\n        UserWithPubKey(\n            userId,\n            \"USER_PUBLIC_KEY\"\n        )\n    }",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/java/threads.mdx",
        "type": "mdx",
        "chunkIndex": 8,
        "codeBlocks": [
          "```\n</Tab>\n\n<Tab value=\"Removing User\">\nTo remove a user from a Thread you must provide:\n- list of all the users, without the user you want to remove\n- list of managers\n- new private and public meta (even if it didn't change)\n- Thread's current version\n- `true` if update action should be forced\n\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.895Z",
        "size": 1135
      }
    },
    {
      "pageContent": "threadApi.updateThread(\n    thread.threadId,\n    newUsers,\n    managers,\n    thread.publicMeta,\n    thread.privateMeta,\n    thread.version,\n    false\n)\n```\n</Tab>\n\n<Tab value=\"Deleting Thread\">\nThe snippet below deletes Thread and all its data. This action is irreversible.\n```kotlin\nval threadId = \"THREAD_ID\"\nthreadApi.deleteThread(threadId)\n```\n</Tab>\n\n</Tabs>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/java/threads.mdx",
        "type": "mdx",
        "chunkIndex": 9,
        "codeBlocks": [
          "```\n</Tab>\n\n<Tab value=\"Deleting Thread\">\nThe snippet below deletes Thread and all its data. This action is irreversible.\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.895Z",
        "size": 363
      }
    },
    {
      "pageContent": "---\ntitle: Getting Started\n---\n\n## Initial Requirements\n\nTo start developing using PrivMX Endpoint C# you need a [PrivMX Bridge](../start/quick-start) instance.\n\nTo connect it to your environment, you need:\n  - `Bridge URL` - URL address of the instance of your PrivMX Bridge\n  - `Solution ID` - ID of the Solution provided by PrivMX Bridge during its initialization process\n  - `User Private Key` - the private key from the user's public-private key pair\n\nYou also need to use your own application server to manage users (and their keys) and Contexts.\n\n## Setup a Project\n\nAdd a reference to the PrivMX Endpoint package in your existing or a new project. See [Installation](./installation) for available options and detailed steps.",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/csharp/getting-started.mdx",
        "type": "mdx",
        "chunkIndex": 0,
        "headers": [
          "Initial Requirements",
          "Setup a Project"
        ],
        "title": "Initial Requirements",
        "lastModified": "2025-06-05T19:33:57.896Z",
        "size": 732
      }
    },
    {
      "pageContent": "## Setup a Project\n\nAdd a reference to the PrivMX Endpoint package in your existing or a new project. See [Installation](./installation) for available options and detailed steps.\n\n## Initial Assumptions\n\nThe initial assumptions for all the code examples below are as follows:\n\n```csharp\nconst string bridgeUrl = \"BRIDGE_URL\";\nconst string solutionId = \"SOLUTION_ID\";\nconst string contextId = \"CONTEXT_ID\";\n\nconst string userId = \"USER_ID\";\nconst string userPrivKey = \"USER_PRIVATE_KEY\";\nconst string userPubKey = \"USER_PUBLIC_KEY\";\n```\n\nAll the values above like `BRIDGE_URL`, `SOLUTION_ID`, `CONTEXT_ID`\nshould be replaced by the ones corresponding to your Bridge Server instance.\n\nThe private keys should be kept separately by each user and stored in a safe place,\nor generated from a password.\nFor more information on how to obtain keys, see\n[generatePrivateKey()](../reference/privmx-endpoint-csharp/crypto/crypto-api#generateprivatekey)\nand\n[derivePrivateKey2()](../reference/privmx-endpoint-csharp/crypto/crypto-api#deriveprivatekey2)\nmethods in the Crypto API.",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/csharp/getting-started.mdx",
        "type": "mdx",
        "chunkIndex": 1,
        "headers": [
          "Setup a Project",
          "Initial Assumptions"
        ],
        "title": "Setup a Project",
        "codeBlocks": [
          "```csharp\nconst string bridgeUrl = \"BRIDGE_URL\";\nconst string solutionId = \"SOLUTION_ID\";\nconst string contextId = \"CONTEXT_ID\";\n\nconst string userId = \"USER_ID\";\nconst string userPrivKey = \"USER_PRIVATE_KEY\";\nconst string userPubKey = \"USER_PUBLIC_KEY\";\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.896Z",
        "size": 1067
      }
    },
    {
      "pageContent": "## Connecting to PrivMX Bridge\n\nTo connect to PrivMX, you must provide users's private key, solution ID and bridge URL.\nThe user's private key do not left out of the library. It is required to using asymetric encryption and singing.\n\n<Tabs groupId=\"variant\" items={[\"PrivMX Endpoint C#\",\"PrivMX Endpoint C# Extra\"]}>\n<Tab>\n```csharp\nConnection connection = \n    Connection.Connect(userPrivKey, solutionId, bridgeUrl);\n```\n</Tab>\n<Tab>\n```csharp\nConnectionSession session = \n    await ConnectionSession.Create(userPrivKey, userPubKey, solutionId, bridgeUrl);\n```\n</Tab>\n</Tabs>\n\n## Disconnecting from PrivMX Bridge\n\n<Tabs groupId=\"variant\" items={[\"PrivMX Endpoint C#\",\"PrivMX Endpoint C# Extra\"]}>\n<Tab>\n```csharp\nconnection.Disconnect();\n```\n</Tab>\n<Tab>\n```csharp\nawait session.DisposeAsync();\n```\n</Tab>\n</Tabs>",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/csharp/getting-started.mdx",
        "type": "mdx",
        "chunkIndex": 2,
        "headers": [
          "Connecting to PrivMX Bridge",
          "Disconnecting from PrivMX Bridge"
        ],
        "title": "Connecting to PrivMX Bridge",
        "codeBlocks": [
          "```csharp\nConnection connection = \n    Connection.Connect(userPrivKey, solutionId, bridgeUrl);\n```",
          "```csharp\nConnectionSession session = \n    await ConnectionSession.Create(userPrivKey, userPubKey, solutionId, bridgeUrl);\n```",
          "```csharp\nconnection.Disconnect();\n```",
          "```csharp\nawait session.DisposeAsync();\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.896Z",
        "size": 814
      }
    },
    {
      "pageContent": "## Next Steps\n\nWith everything ready to go, now it's time to start using all of the platform's capabilities.\n\nLearn how to use:\n\n-   [**Threads**](../start/threads/overview) - for exchanging encrypted messages;\n-   [**Stores**](../start/stores/overview) - for saving and sharing encrypted files;\n-   [**Inboxes**](../start/inboxes/overview) - for one way communication with external users.",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/csharp/getting-started.mdx",
        "type": "mdx",
        "chunkIndex": 3,
        "headers": [
          "Next Steps"
        ],
        "title": "Next Steps",
        "lastModified": "2025-06-05T19:33:57.896Z",
        "size": 389
      }
    },
    {
      "pageContent": "---\ntitle: Installation\n---\n\nPrivMX Endpoint libraries are available on NuGet.org as following NuGet packages:\n\n- PrivMX Endpoint C# - `PrivMX.Endpoint` package,\n- PrivMX Endpoint C# Extra - `PrivMX.Endpoint.Extra` package.\n\nPackages contain all the necessary assets and helpers to get started with PrivMX.\nTo compare both libraries and get details, see [Overview](./introduction).\n\n## Installation with the dotnet CLI\n\nThe .NET SDK is required, which provides the `dotnet` command-line tool.\n\nTo install the PrivMX Endpoint C# package, use the following command in your project:\n    ```powershell\n    dotnet add package PrivMX.Endpoint\n    ```\n  or to install the PrivMX Endpoint C# Extra package, use the following command:\n    ```powershell\n    dotnet add package PrivMX.Endpoint.Extra\n    ```",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/csharp/installation.mdx",
        "type": "mdx",
        "chunkIndex": 0,
        "headers": [
          "Installation with the dotnet CLI"
        ],
        "title": "Installation with the dotnet CLI",
        "codeBlocks": [
          "```powershell\n    dotnet add package PrivMX.Endpoint\n    ```",
          "```powershell\n    dotnet add package PrivMX.Endpoint.Extra\n    ```"
        ],
        "lastModified": "2025-06-05T19:33:57.896Z",
        "size": 796
      }
    },
    {
      "pageContent": "## Installation in Visual Studio\n\nTo install PrivMX Endpoint packages in Visual Studio, you can use the NuGet Package Manager or the Package Manager Console.\n\n### NuGet Package Manager\n\nTo use the NuGet Package Manager to install PrivMX Endpoint C# or PrivMX Endpoint C# Extra packages in Visual Studio, follow steps:\n\n1. From Visual Studio, select *Project > Manage NuGet Packages*.\n\n2. From the Browse tab, search for `PrivMX.Endpoint` or `PrivMX.Endpoint.Extra`, select your target in the list, and click Install.",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/csharp/installation.mdx",
        "type": "mdx",
        "chunkIndex": 1,
        "headers": [
          "Installation in Visual Studio",
          "NuGet Package Manager"
        ],
        "title": "Installation in Visual Studio",
        "lastModified": "2025-06-05T19:33:57.896Z",
        "size": 516
      }
    },
    {
      "pageContent": "### Package Manager Console\n\nAlternatively, to use the Package Manager Console in Visual Studio to install PrivMX Endpoint C# or PrivMX Endpoint C# Extra packages, follow these steps:\n\n1. From Visual Studio, select *Tools > NuGet Package Manager > Package Manager Console*.\n\n2. After the Package Manager Console pane opens, select the project in drop-down list in which you want to install the package.\n\n3. At the console prompt, to install the PrivMX Endpoint C# package, use the following command:\n    ```powershell\n    Install-Package PrivMX.Endpoint\n    ```\n    or to install the PrivMX Endpoint C# Extra package, use the following command:\n\n    ```powershell\n    Install-Package PrivMX.Endpoint.Extra\n    ```",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/csharp/installation.mdx",
        "type": "mdx",
        "chunkIndex": 2,
        "headers": [
          "Package Manager Console"
        ],
        "title": "Package Manager Console",
        "codeBlocks": [
          "```powershell\n    Install-Package PrivMX.Endpoint\n    ```",
          "```powershell\n    Install-Package PrivMX.Endpoint.Extra\n    ```"
        ],
        "lastModified": "2025-06-05T19:33:57.896Z",
        "size": 713
      }
    },
    {
      "pageContent": "---\ntitle: Overview\n---\n\nThis part of the documentation describes our solutions to simplify working with PrivMX Endpoint library on the .NET platform.\n\n## Requirements\n\nPrivMX Endpoint for C# are .NET Standard 2.1 libraries, which can be running using .NET Runtime, Mono or Unity.\n\nSupported runtimes are:\n    - Windows: `win-x64`\n    - Linux: `linux-x64`\n    - macOS: `osx-arm64`\n\nAdditionally, in progress and available soon:\n    - iOS: `ios-arm64`\n    - Android: `android-arm64`, `android-arm`",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/csharp/introduction.mdx",
        "type": "mdx",
        "chunkIndex": 0,
        "headers": [
          "Requirements"
        ],
        "title": "Requirements",
        "lastModified": "2025-06-05T19:33:57.896Z",
        "size": 496
      }
    },
    {
      "pageContent": "## Libraries\n\n### PrivMX Endpoint C#\n\nPrivMX Endpoint C# is the minimal native library wrapper. It declares import functions using Platform Invoke\n(P/Invoke) and maps data between native objects and C# objects.\n\nFor detailed descriptions of each class, see [API Reference](../reference/privmx-endpoint-csharp/core/backend-requester)\nor the source code on [GitHub](https://github.com/simplito/privmx-endpoint-csharp).\n\n### PrivMX Endpoint C# Extra\n\nPrivMX Endpoint C# Extra provides additional functionality for PrivMX Endpoint C#.\nIt adds asynchronous methods, additional abstraction of event dispatching, reading and writing files.\nThis package is the recommended for using PrivMX in most cases.\n\nFor detailed descriptions of each class, see [API Reference](../reference/privmx-endpoint-csharp-extra/core/async-connection)\nor the source code on [GitHub](https://github.com/simplito/privmx-endpoint-csharp-extra).",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/csharp/introduction.mdx",
        "type": "mdx",
        "chunkIndex": 1,
        "headers": [
          "Libraries",
          "PrivMX Endpoint C#",
          "PrivMX Endpoint C# Extra"
        ],
        "title": "Libraries",
        "lastModified": "2025-06-05T19:33:57.896Z",
        "size": 913
      }
    },
    {
      "pageContent": "---\ntitle: Context Users\ndescription: Get information about users from a Context.\n---\n\nThe method `getContextUsers(...)` from the Connection API lets you retrieve a list of users from a given Context. \nAdditionally, it returns the user's activity status.\n\n:::info\n\nSample code on this page is based on the **[initial assumptions](./first-app#initial-assumptions)**.\n\n:::",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/cpp/context-users.mdx",
        "type": "mdx",
        "chunkIndex": 0,
        "lastModified": "2025-06-05T19:33:57.897Z",
        "size": 370
      }
    },
    {
      "pageContent": "### Retrieving Users from a Context\n\n```cpp\n// ...\n\n#include <privmx/endpoint/core/Connection.hpp>\n\n// ...\n\n// initialize Endpoint connection\nauto connection {core::Connection::connect(USER1_PRIVATE_KEY, SOLUTION_ID, BRIDGE_URL)};\n\n// Get users of the Context\nauto contextUsers {connection.getContextUsers(CONTEXT_ID)};\nfor (auto ctxUser: contextUsers) {\n    std::cout << \"UserId: \" << ctxUser.user.userId << \" / UserPubKey: \" << ctxUser.user.pubKey << std::endl;\n    std::cout << \"isActive: \" << ctxUser.isActive << std::endl; \n}\n\n\n```\n\nThe results of the example above will look similar to those below:\n\n```\nUserId: user1 / UserPubKey: 51WPnnGwztNPWUDEbhncYDxZCZWAFS4M9Yqv94N2335nL92fEn\nisActive: 1\nUserId: user2 / UserPubKey: 83NSj4JTAXTPLrTKf7kXwT2XPxAE3ATudFb7vrWmhizKStkU48\nisActive: 0\nUserId: user3 / UserPubKey: 7qaaU47RdiTFqQZtRWcyHRgSBVbxBxeS9USyhStXqN14Pc4xxt\nisActive: 0\n```\n\nA full code example can be found on [Simplito's GitHub](https://github.com/simplito/privmx-endpoint/tree/main/examples).",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/cpp/context-users.mdx",
        "type": "mdx",
        "chunkIndex": 1,
        "headers": [
          "Retrieving Users from a Context"
        ],
        "title": "Retrieving Users from a Context",
        "codeBlocks": [
          "```cpp\n// ...\n\n#include <privmx/endpoint/core/Connection.hpp>\n\n// ...\n\n// initialize Endpoint connection\nauto connection {core::Connection::connect(USER1_PRIVATE_KEY, SOLUTION_ID, BRIDGE_URL)};\n\n// Get users of the Context\nauto contextUsers {connection.getContextUsers(CONTEXT_ID)};\nfor (auto ctxUser: contextUsers) {\n    std::cout << \"UserId: \" << ctxUser.user.userId << \" / UserPubKey: \" << ctxUser.user.pubKey << std::endl;\n    std::cout << \"isActive: \" << ctxUser.isActive << std::endl; \n}\n\n\n```",
          "```\nUserId: user1 / UserPubKey: 51WPnnGwztNPWUDEbhncYDxZCZWAFS4M9Yqv94N2335nL92fEn\nisActive: 1\nUserId: user2 / UserPubKey: 83NSj4JTAXTPLrTKf7kXwT2XPxAE3ATudFb7vrWmhizKStkU48\nisActive: 0\nUserId: user3 / UserPubKey: 7qaaU47RdiTFqQZtRWcyHRgSBVbxBxeS9USyhStXqN14Pc4xxt\nisActive: 0\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.897Z",
        "size": 1008
      }
    },
    {
      "pageContent": "---\ntitle: Custom Events\ndescription: Custom events allow emitting and receiving data of any shape in a secure, end-to-end encrypted way.\n---\n\nCustom events allow you to send information to specific groups of users. The data will not be stored anywhere. \nFor an event to reach the recipient, the recipient must be subscribed to the channel on which you are emitting the event at that moment.\n\n:::info\n\nBefore working with Custom Events, follow our [Getting Started Guide](./introduction). It will show you how to set up your project to work with PrivMX Bridge.\n\nSample code on this page is based on the **[initial assumptions](./first-app#initial-assumptions)**.\n\n:::",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/cpp/custom-events.mdx",
        "type": "mdx",
        "chunkIndex": 0,
        "lastModified": "2025-06-05T19:33:57.897Z",
        "size": 667
      }
    },
    {
      "pageContent": "## Working with Custom Events\n\n### Key Considerations\n\nPlease note the following:\n\n- Events will only trigger for active connections.\n- Events are not captured unless explicitly listened for.\n- A single instance of the `eventQueue` is shared across all connections.",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/cpp/custom-events.mdx",
        "type": "mdx",
        "chunkIndex": 1,
        "headers": [
          "Working with Custom Events",
          "Key Considerations"
        ],
        "title": "Working with Custom Events",
        "lastModified": "2025-06-05T19:33:57.897Z",
        "size": 265
      }
    },
    {
      "pageContent": "### Emitting and Handling Custom Events\nBelow there is simple code example of how to emit an Event with the custom payload and then how to handle it when it arrives to the recipients.\n\n```cpp\n// ...\n\n#include <privmx/endpoint/core/Connection.hpp>\n#include <privmx/endpoint/event/EventApi.hpp>\n#include <privmx/endpoint/core/Buffer.hpp>\n#include <privmx/endpoint/core/EventQueue.hpp>\n#include <privmx/endpoint/event/Events.hpp>\n\n// ...\n\ncore::EventQueue eventQueue {core::EventQueue::getInstance()};\n\n// Start the EventQueue reading loop\nstd::thread t([&](){\n    while(true) {\n        core::EventHolder event = eventQueue.waitEvent();\n        if (event::Events::isContextCustomEvent(event)) {\n            auto customEvent = event::Events::extractContextCustomEvent(event);\n            std::cout << \"Received event:\" << std::endl;\n            std::cout << \"contextId: \" << customEvent.data.contextId << std::endl;\n            std::cout << \"sender: \" << customEvent.data.userId << std::endl;\n            std::cout << \"payload: \" << customEvent.data.payload.stdString() << std::endl;\n        }\n        std::this_thread::sleep_for(std::chrono::milliseconds(5));\n    }\n});",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/cpp/custom-events.mdx",
        "type": "mdx",
        "chunkIndex": 2,
        "headers": [
          "Emitting and Handling Custom Events"
        ],
        "title": "Emitting and Handling Custom Events",
        "lastModified": "2025-06-05T19:33:57.897Z",
        "size": 1166
      }
    },
    {
      "pageContent": "// initialize Endpoint connection and the Event API\nauto connection {core::Connection::connect(USER1_PRIVATE_KEY, SOLUTION_ID, BRIDGE_URL)};\nauto eventApi {event::EventApi::create(connection)};\n\n// Subscribe for the Thread's events\neventApi.subscribeForCustomEvents(CONTEXT_ID, \"myChannel\");\n\n// sending event to myself\nstd::vector<core::UserWithPubKey> recipients {\n    {.userId = USER1_ID, .pubKey = USER1_PUBLIC_KEY}\n};\n\n// Emit event\neventApi.emitEvent(\n    CONTEXT_ID, \n    recipients, \n    \"myChannel\", \n    core::Buffer::from(\"some data\")\n);\n\nt.join();",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/cpp/custom-events.mdx",
        "type": "mdx",
        "chunkIndex": 3,
        "lastModified": "2025-06-05T19:33:57.897Z",
        "size": 559
      }
    },
    {
      "pageContent": "```\n\nA full code example can be found on [Simplito's GitHub](https://github.com/simplito/privmx-endpoint/tree/main/examples).",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/cpp/custom-events.mdx",
        "type": "mdx",
        "chunkIndex": 4,
        "lastModified": "2025-06-05T19:33:57.897Z",
        "size": 125
      }
    },
    {
      "pageContent": "---\ntitle: Custom Fields and Queries\ndescription: Using custom fields and querying them in Thread and Store containers.  \n---\n\nCustom fields and querying them is a functionality that works with Threads and Stores containers.\n\nIt allows you to define new fields by placing them in the `publicMeta` of a container or an object within a given container, \nand then querying the PrivMX Endpoint Client (using existing listing methods) for elements containing these previously defined fields.\n\n:::info\n\nSample code on this page is based on the **[initial assumptions](./first-app#initial-assumptions)**.\n\n:::",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/cpp/custom-fields-and-queries.mdx",
        "type": "mdx",
        "chunkIndex": 0,
        "lastModified": "2025-06-05T19:33:57.898Z",
        "size": 602
      }
    },
    {
      "pageContent": "## Working with Custom Fields and Queries\n\nBelow there is a simple code example of how to add a **custom field** to a batch of Threads, and then search for them using **custom query**.\n\n\n### Initial Setup\n\nLet's add some required includes and initialize the PrivMX Endpoint Client with the Thread API:\n```cpp\n// ...\n\n#include <privmx/endpoint/core/Connection.hpp>\n#include <privmx/endpoint/thread/ThreadApi.hpp>\n#include <privmx/endpoint/core/Buffer.hpp>\n\n// ...\n\n// initialize Endpoint connection and Threads API\nauto connection {core::Connection::connect(USER1_PRIVATE_KEY, SOLUTION_ID, BRIDGE_URL)};\nauto threadApi {thread::ThreadApi::create(connection)};\n\nstd::vector<core::UserWithPubKey> threadUsers {\n    {.userId = USER1_ID, .pubKey = USER1_PUBLIC_KEY}\n};\n```\n\n### Defining a Sample Custom Field\n```cpp\n// ...\n\nstd::string threadCustomField = R\"(\n    {\n        \"threadType\": \"special\"\n    }\n)\";\n\n// ...\n```",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/cpp/custom-fields-and-queries.mdx",
        "type": "mdx",
        "chunkIndex": 1,
        "headers": [
          "Working with Custom Fields and Queries",
          "Initial Setup",
          "Defining a Sample Custom Field"
        ],
        "title": "Working with Custom Fields and Queries",
        "codeBlocks": [
          "```cpp\n// ...\n\n#include <privmx/endpoint/core/Connection.hpp>\n#include <privmx/endpoint/thread/ThreadApi.hpp>\n#include <privmx/endpoint/core/Buffer.hpp>\n\n// ...\n\n// initialize Endpoint connection and Threads API\nauto connection {core::Connection::connect(USER1_PRIVATE_KEY, SOLUTION_ID, BRIDGE_URL)};\nauto threadApi {thread::ThreadApi::create(connection)};\n\nstd::vector<core::UserWithPubKey> threadUsers {\n    {.userId = USER1_ID, .pubKey = USER1_PUBLIC_KEY}\n};\n```",
          "```cpp\n// ...\n\nstd::string threadCustomField = R\"(\n    {\n        \"threadType\": \"special\"\n    }\n)\";\n\n// ...\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.898Z",
        "size": 914
      }
    },
    {
      "pageContent": "### Defining a Sample Custom Field\n```cpp\n// ...\n\nstd::string threadCustomField = R\"(\n    {\n        \"threadType\": \"special\"\n    }\n)\";\n\n// ...\n```\n\n### Creating Threads\n\nThe following code will create a total of 6 new Threads. 3 of them will contain a Custom Field.\n\n```cpp\n// ...\n\n// Creating some ordinary Threads\nfor (int i = 0; i < 3; ++i) {\n    threadApi.createThread(\n        CONTEXT_ID, \n        threadUsers, threadUsers, \n        core::Buffer::from(\"\"),\n        core::Buffer::from(\"Ordinary thread\")\n    );\n}\n\n// Creating some Threads with the custom field\nfor (int i = 0; i < 3; ++i) {\n    threadApi.createThread(\n        CONTEXT_ID, \n        threadUsers, threadUsers, \n        core::Buffer::from(threadCustomField),\n        core::Buffer::from(\"Thread with the custom field\")\n    );\n}\n\n// ...\n```",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/cpp/custom-fields-and-queries.mdx",
        "type": "mdx",
        "chunkIndex": 2,
        "headers": [
          "Defining a Sample Custom Field",
          "Creating Threads"
        ],
        "title": "Defining a Sample Custom Field",
        "codeBlocks": [
          "```cpp\n// ...\n\nstd::string threadCustomField = R\"(\n    {\n        \"threadType\": \"special\"\n    }\n)\";\n\n// ...\n```",
          "```cpp\n// ...\n\n// Creating some ordinary Threads\nfor (int i = 0; i < 3; ++i) {\n    threadApi.createThread(\n        CONTEXT_ID, \n        threadUsers, threadUsers, \n        core::Buffer::from(\"\"),\n        core::Buffer::from(\"Ordinary thread\")\n    );\n}\n\n// Creating some Threads with the custom field\nfor (int i = 0; i < 3; ++i) {\n    threadApi.createThread(\n        CONTEXT_ID, \n        threadUsers, threadUsers, \n        core::Buffer::from(threadCustomField),\n        core::Buffer::from(\"Thread with the custom field\")\n    );\n}\n\n// ...\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.898Z",
        "size": 804
      }
    },
    {
      "pageContent": "### Listing Threads\nThe next piece of code will demonstrate how you can filter the results of the `listThreads(...)` method using built-in it Custom Queries functionality\nto get the Threads containing the previously defined Custom Field.\n\n```cpp\n// ...\n\n// Quering over Threads\ncore::PagingQuery defaultListQuery = {.skip = 0, .limit = 10, .sortOrder = \"desc\"};\nauto threadsList1 {threadApi.listThreads(CONTEXT_ID, defaultListQuery)};\n\ncore::PagingQuery customQuery = {.skip = 0, .limit = 10, .sortOrder = \"desc\", .queryAsJson = threadCustomField};\nauto threadsList2 {threadApi.listThreads(CONTEXT_ID, customQuery)};\n\nstd::cout << \"The list of all Threads:\" << std::endl;\nfor (auto t: threadsList1.readItems) {\n    std::cout << \"ThreadId: \" << t.threadId << \" / privateMeta: \" << t.privateMeta.stdString() << std::endl;\n}\n\nstd::cout << \"The list of Threads with the custom field:\" << std::endl;\nfor (auto t: threadsList2.readItems) {\n    std::cout << \"ThreadId: \" << t.threadId << \" / privateMeta: \" << t.privateMeta.stdString() << std::endl;\n}\n\n// ...",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/cpp/custom-fields-and-queries.mdx",
        "type": "mdx",
        "chunkIndex": 3,
        "headers": [
          "Listing Threads"
        ],
        "title": "Listing Threads",
        "lastModified": "2025-06-05T19:33:57.898Z",
        "size": 1052
      }
    },
    {
      "pageContent": "```\n\nThe results of the example above will look similar to those below:\n\n```\nThe list of all Threads:\nThreadId: 6809fb0b57a381d1a23f10ec / privateMeta: Thread with the custom field\nThreadId: 6809fb0b57a381d1a23f10eb / privateMeta: Thread with the custom field\nThreadId: 6809fb0b57a381d1a23f10ea / privateMeta: Thread with the custom field\nThreadId: 6809fb0b57a381d1a23f10e9 / privateMeta: Ordinary thread\nThreadId: 6809fb0b57a381d1a23f10e8 / privateMeta: Ordinary thread\nThreadId: 6809fb0b57a381d1a23f10e7 / privateMeta: Ordinary thread\n\nThe list of Threads with the custom field:\nThreadId: 6809fb0b57a381d1a23f10ec / privateMeta: Thread with the custom field\nThreadId: 6809fb0b57a381d1a23f10eb / privateMeta: Thread with the custom field\nThreadId: 6809fb0b57a381d1a23f10ea / privateMeta: Thread with the custom field\n```\n\nA full code example can be found on [Simplito's GitHub](https://github.com/simplito/privmx-endpoint/tree/main/examples).",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/cpp/custom-fields-and-queries.mdx",
        "type": "mdx",
        "chunkIndex": 4,
        "codeBlocks": [
          "```\n\nThe results of the example above will look similar to those below:\n\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.898Z",
        "size": 943
      }
    },
    {
      "pageContent": "---\ntitle: Entries\n---\n\nAll the data sent by someone to an Inbox is called an Entry.\nIn Threads and Stores, a user must be assigned to the container to send data. In Inboxes, however, \nanyone who has Inbox ID can send a reply (assuming they have the Bridge URL and Solution ID).\n\n:::info\n\nSample code on this page is based on the same **[assumptions](./first-app#initial-assumptions)**.\n\n:::",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/cpp/entries.mdx",
        "type": "mdx",
        "chunkIndex": 0,
        "lastModified": "2025-06-05T19:33:57.898Z",
        "size": 391
      }
    },
    {
      "pageContent": "## Public Access to an Inbox\n\nPrivMX Endpoint client provides different ways to connect to a Bridge instance.\n\nWhen using \"public\" connection (`connectPublic(...)`) you don't have to pass a private key. A random private key will be generated for each connection.\n**The public connection provides only the methods related to sending Inbox entries and retrieving public metadata** related to the Inbox.\n\n\n### Connect to the Public Inbox API\n```cpp\n// ...\n\nauto publicConnection {core::Connection::connectPublic(SOLUTION_ID, BRIDGE_URL)};\nauto threadPubApi {thread::ThreadApi::create(publicConnection)};\nauto storePubApi {store::StoreApi::create(publicConnection)};\nauto inboxPubApi {inbox::InboxApi::create(publicConnection, threadPubApi, storePubApi)};\n\n// ...\n```\n\n### Reading Inbox Public View\n`getInboxPublicView(...)` gets all the data stored inside the Inbox' publicMeta.\n\n```cpp\n// ...\n\nauto publicView {inboxPubApi.getInboxPublicView(inboxId)};\nstd::cout << \"Public view: \" << publicView.publicMeta.stdString() << std::endl;\n\n// ...\n```",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/cpp/entries.mdx",
        "type": "mdx",
        "chunkIndex": 1,
        "headers": [
          "Public Access to an Inbox",
          "Connect to the Public Inbox API",
          "Reading Inbox Public View"
        ],
        "title": "Public Access to an Inbox",
        "codeBlocks": [
          "```cpp\n// ...\n\nauto publicConnection {core::Connection::connectPublic(SOLUTION_ID, BRIDGE_URL)};\nauto threadPubApi {thread::ThreadApi::create(publicConnection)};\nauto storePubApi {store::StoreApi::create(publicConnection)};\nauto inboxPubApi {inbox::InboxApi::create(publicConnection, threadPubApi, storePubApi)};\n\n// ...\n```",
          "```cpp\n// ...\n\nauto publicView {inboxPubApi.getInboxPublicView(inboxId)};\nstd::cout << \"Public view: \" << publicView.publicMeta.stdString() << std::endl;\n\n// ...\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.898Z",
        "size": 1042
      }
    },
    {
      "pageContent": "## Submitting Entries\n### Adding a Simple Entry (without Files)\n```cpp\n// ...\n\t\nauto entryHandle {inboxPubApi.prepareEntry(inboxId, core::Buffer::from(\"sample data\"))};\ninboxPubApi.sendEntry(entryHandle);\n\n// ...\n```\n\n### Adding an Entry with Files\n```cpp\n// ...\n\nstd::vector<int64_t>files{};\nauto sampleData {core::Buffer::from(\"some file sample data\")};\nauto fileHandle {inboxPubApi.createFileHandle(core::Buffer::from(\"\"), core::Buffer::from(\"\"), sampleData.size())};\t\nfiles.push_back(fileHandle);\n\nauto entryHandle2 {inboxPubApi.prepareEntry(inboxId, core::Buffer::from(\"sample data\"), files)};\ninboxPubApi.writeToFile(entryHandle2, fileHandle, sampleData);\ninboxPubApi.sendEntry(entryHandle2);\n\n// ...\n```",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/cpp/entries.mdx",
        "type": "mdx",
        "chunkIndex": 2,
        "headers": [
          "Submitting Entries",
          "Adding a Simple Entry (without Files)",
          "Adding an Entry with Files"
        ],
        "title": "Submitting Entries",
        "codeBlocks": [
          "```cpp\n// ...\n\t\nauto entryHandle {inboxPubApi.prepareEntry(inboxId, core::Buffer::from(\"sample data\"))};\ninboxPubApi.sendEntry(entryHandle);\n\n// ...\n```",
          "```cpp\n// ...\n\nstd::vector<int64_t>files{};\nauto sampleData {core::Buffer::from(\"some file sample data\")};\nauto fileHandle {inboxPubApi.createFileHandle(core::Buffer::from(\"\"), core::Buffer::from(\"\"), sampleData.size())};\t\nfiles.push_back(fileHandle);\n\nauto entryHandle2 {inboxPubApi.prepareEntry(inboxId, core::Buffer::from(\"sample data\"), files)};\ninboxPubApi.writeToFile(entryHandle2, fileHandle, sampleData);\ninboxPubApi.sendEntry(entryHandle2);\n\n// ...\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.898Z",
        "size": 710
      }
    },
    {
      "pageContent": "## Fetching Entries\n\nFetching Entries requires a secure private connection.\n```cpp\n// ...\n\nauto connection {core::Connection::connect(USER1_PRIVATE_KEY, SOLUTION_ID, BRIDGE_URL)};\nauto threadApi {thread::ThreadApi::create(connection)};\nauto storeApi {store::StoreApi::create(connection)};\nauto inboxApi {inbox::InboxApi::create(connection, threadApi, storeApi)};\n\n// ...\n```\n\n### Reading Simple Text Entries\n```cpp\n// ...\n\t\nauto entriesList {inboxApi.listEntries(inboxId, defaultListQuery)};\nfor (auto entry: entriesList.readItems) {\n    std::cout << \"EntryId: \" << entry.entryId << \" / data: \" << entry.data.stdString() << std::endl;\n}\n\n// ...\n```\n\n### Reading Entries Containing Files\n```cpp\n// ...\n\t\nauto entriesList {inboxApi.listEntries(inboxId, defaultListQuery)};\nfor (auto entry: entriesList.readItems) {\n    std::cout << \"EntryId: \" << entry.entryId << \" / data: \" << entry.data.stdString() << std::endl;\n\n    for (auto file: entry.files) {\n        auto fh {inboxApi.openFile(file.info.fileId)};\n        auto data {inboxApi.readFromFile(fh, file.size)};\n        std::cout << \"File data: \" << data.stdString() << std::endl;\n    }\n}\n\n// ...\n```",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/cpp/entries.mdx",
        "type": "mdx",
        "chunkIndex": 3,
        "headers": [
          "Fetching Entries",
          "Reading Simple Text Entries",
          "Reading Entries Containing Files"
        ],
        "title": "Fetching Entries",
        "codeBlocks": [
          "```cpp\n// ...\n\nauto connection {core::Connection::connect(USER1_PRIVATE_KEY, SOLUTION_ID, BRIDGE_URL)};\nauto threadApi {thread::ThreadApi::create(connection)};\nauto storeApi {store::StoreApi::create(connection)};\nauto inboxApi {inbox::InboxApi::create(connection, threadApi, storeApi)};\n\n// ...\n```",
          "```cpp\n// ...\n\t\nauto entriesList {inboxApi.listEntries(inboxId, defaultListQuery)};\nfor (auto entry: entriesList.readItems) {\n    std::cout << \"EntryId: \" << entry.entryId << \" / data: \" << entry.data.stdString() << std::endl;\n}\n\n// ...\n```",
          "```cpp\n// ...\n\t\nauto entriesList {inboxApi.listEntries(inboxId, defaultListQuery)};\nfor (auto entry: entriesList.readItems) {\n    std::cout << \"EntryId: \" << entry.entryId << \" / data: \" << entry.data.stdString() << std::endl;\n\n    for (auto file: entry.files) {\n        auto fh {inboxApi.openFile(file.info.fileId)};\n        auto data {inboxApi.readFromFile(fh, file.size)};\n        std::cout << \"File data: \" << data.stdString() << std::endl;\n    }\n}\n\n// ...\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.898Z",
        "size": 1151
      }
    },
    {
      "pageContent": "---\ntitle: Handling Events\ndescription: Events allow your application to respond to changes in user context instantly. These events are automatically captured when relevant changes occur. You can subscribe to them by registering event listeners.\n---",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/cpp/events.mdx",
        "type": "mdx",
        "chunkIndex": 0,
        "lastModified": "2025-06-05T19:33:57.898Z",
        "size": 249
      }
    },
    {
      "pageContent": "## The EventQueue And Handling Events\n\n:::info\n\nSample code on this page is based on the same **[initial assumptions](./first-app#initial-assumptions)**.\n\n:::\n### Key Considerations\n\nPlease note the following:\n\n- Events will only trigger for active connections.\n- Events are not captured unless explicitly listened for.\n- A single instance of the `eventQueue` is shared across all connections.",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/cpp/events.mdx",
        "type": "mdx",
        "chunkIndex": 1,
        "headers": [
          "The EventQueue And Handling Events",
          "Key Considerations"
        ],
        "title": "The EventQueue And Handling Events",
        "lastModified": "2025-06-05T19:33:57.898Z",
        "size": 393
      }
    },
    {
      "pageContent": "### Handling The Incoming Event\nBelow there is simple code example of how to handle an event coming after new message has been sent to the Thread.\n\n\n```cpp\n// ...\n\n#include <privmx/endpoint/core/Connection.hpp>\n#include <privmx/endpoint/thread/ThreadApi.hpp>\n#include <privmx/endpoint/core/Buffer.hpp>\n#include <privmx/endpoint/core/EventQueue.hpp>\n#include <privmx/endpoint/thread/Events.hpp>\n\n// ...\ncore::EventQueue eventQueue {core::EventQueue::getInstance()};\n\n// Start the EventQueue reading loop\nstd::thread t([&](){\n    while(true) {\n        core::EventHolder event = eventQueue.waitEvent();\n        if (thread::Events::isThreadNewMessageEvent(event)) {\n            auto msgEvent = thread::Events::extractThreadNewMessageEvent(event);\n            auto message = msgEvent.data;\n            std::cout << \"Message: \" << message.data.stdString() << std::endl;\n            std::cout << \"Author: \" << message.info.author << std::endl;\n        }\n        std::this_thread::sleep_for(std::chrono::milliseconds(5));\n    }\n});\n\n// ...",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/cpp/events.mdx",
        "type": "mdx",
        "chunkIndex": 2,
        "headers": [
          "Handling The Incoming Event"
        ],
        "title": "Handling The Incoming Event",
        "lastModified": "2025-06-05T19:33:57.898Z",
        "size": 1031
      }
    },
    {
      "pageContent": "// ...\n\n// initialize the connection to the Bridge and the Threads API\nauto connection {core::Connection::connect(USER1_PRIVATE_KEY, SOLUTION_ID, BRIDGE_URL)};\nauto threadApi {thread::ThreadApi::create(connection)};\ncore::PagingQuery defaultListQuery = {.skip = 0, .limit = 100, .sortOrder = \"desc\"};\n\n// Get a Thread to work with\nauto currentThread {threadApi.listThreads(CONTEXT_ID, defaultListQuery).readItems[0]};\n\n// Subscribe for the Thread's events\nthreadApi.subscribeForMessageEvents(currentThread.threadId);\n\n// Send a sample message\nthreadApi.sendMessage(currentThread.threadId, core::Buffer::from(\"\"), core::Buffer::from(\"\"), core::Buffer::from(\"some message\"));\n\nt.join();\n```\nAs soon as the new message arrives to the Thread - the `ThreadNewMessageEvent` will be emitted and handled by the `EventQueue`.",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/cpp/events.mdx",
        "type": "mdx",
        "chunkIndex": 3,
        "lastModified": "2025-06-05T19:33:57.898Z",
        "size": 816
      }
    },
    {
      "pageContent": "---\ntitle: Files\ndescription: Uploading and managing files.\n---\n\n\n:::info\n\nSample code on this page is based on the **[initial assumptions](./first-app#initial-assumptions)**.\n\n:::",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/cpp/files.mdx",
        "type": "mdx",
        "chunkIndex": 0,
        "lastModified": "2025-06-05T19:33:57.899Z",
        "size": 180
      }
    },
    {
      "pageContent": "## Managing Files\n\n### Uploading a File\nTo place a file in the Store, you need to create a file handle using the `createFile(...)` function. The function accepts a `StoreId`, \npublic and private metadata, and the total size of the file that will be uploaded.\n\nThen you need to call `writeToFile(...)` providing the created file handle and a portion of data to write. For small files, you can write the entire file with one request. For large files, it's more optimal to write them piece by piece, loading them in portions, for example from the disk, and then calling `writeToFile(...)` on each piece.\nTo complete the entire file upload process - call `closeFile(...)` with the file handle as a parameter.\n\n```cpp\n// ...\n\nauto sampleData {core::Buffer::from(\"some sample data\")};\nauto fh {storeApi.createFile(STORE_ID, core::Buffer::from(\"\"), core::Buffer::from(\"\"), sampleData.size())};\t\nstoreApi.writeToFile(fh, sampleData);\nstoreApi.closeFile(fh);\n\n// ...\n```",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/cpp/files.mdx",
        "type": "mdx",
        "chunkIndex": 1,
        "headers": [
          "Managing Files",
          "Uploading a File"
        ],
        "title": "Managing Files",
        "codeBlocks": [
          "```cpp\n// ...\n\nauto sampleData {core::Buffer::from(\"some sample data\")};\nauto fh {storeApi.createFile(STORE_ID, core::Buffer::from(\"\"), core::Buffer::from(\"\"), sampleData.size())};\t\nstoreApi.writeToFile(fh, sampleData);\nstoreApi.closeFile(fh);\n\n// ...\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.899Z",
        "size": 961
      }
    },
    {
      "pageContent": "### Listing Files\n\nTo retrieve the contents of the Store, you can call the `listFiles(...)` function to get a list of files from the specified Store.\n\n```cpp\n// ...\nauto filesList {storeApi.listFiles(STORE_ID, defaultListQuery)};\nfor (auto file: filesList.readItems) {\n    std::cout << \"FileId: \" << file.info.fileId << \" / Size: \" << file.size << std::endl;\n}\n// ...\n```\n\nAs a result you will receive an object:\n```cpp\n// filesList:\n{\n    readItems: [<fileObject1>, <fileObject2>,..., <fileObjectN>],\n    totalAvailable: <number_of_all_files_in_the_Store>\n}\n```\nA detailed description of the `File` object fields can be found in [API Reference](../reference/endpoint/store/types#file).",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/cpp/files.mdx",
        "type": "mdx",
        "chunkIndex": 2,
        "headers": [
          "Listing Files"
        ],
        "title": "Listing Files",
        "codeBlocks": [
          "```cpp\n// ...\nauto filesList {storeApi.listFiles(STORE_ID, defaultListQuery)};\nfor (auto file: filesList.readItems) {\n    std::cout << \"FileId: \" << file.info.fileId << \" / Size: \" << file.size << std::endl;\n}\n// ...\n```",
          "```cpp\n// filesList:\n{\n    readItems: [<fileObject1>, <fileObject2>,..., <fileObjectN>],\n    totalAvailable: <number_of_all_files_in_the_Store>\n}\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.899Z",
        "size": 686
      }
    },
    {
      "pageContent": "### Reading a File\nTo read a file, you can do it with a single request or - which is usually a better solution for large files - by reading it piece by piece.\nYou must start by opening the file for reading using the `openFile(fileId)` function. As a result, you'll receive a file handle that \nyou then use when calling `readFromFile(...)` to read portions of data from the file. At the same time, you have the ability to move through \nthe file and indicate from which position you want to read it using the `seekInFile(...)` function.\n```cpp\n// ...\nauto lastFile {filesList.readItems[0]};\n\n// Reading file\nauto readHandle {storeApi.openFile(lastFile.info.fileId)};\ncore::Buffer read {storeApi.readFromFile(readHandle, lastFile.size)};\nstd::cout << read.stdString() << std::endl;\n// ...\n```",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/cpp/files.mdx",
        "type": "mdx",
        "chunkIndex": 3,
        "headers": [
          "Reading a File"
        ],
        "title": "Reading a File",
        "codeBlocks": [
          "```cpp\n// ...\nauto lastFile {filesList.readItems[0]};\n\n// Reading file\nauto readHandle {storeApi.openFile(lastFile.info.fileId)};\ncore::Buffer read {storeApi.readFromFile(readHandle, lastFile.size)};\nstd::cout << read.stdString() << std::endl;\n// ...\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.899Z",
        "size": 789
      }
    },
    {
      "pageContent": "## Modifying Files\n\nFile modification can be considered in two categories:\n\n1. Modifying file information.\n2. Modifying data in the file.\n\nTo update information about a file, you need to use the `updateFileMeta(...)`.\n\n```cpp\n// ...\nstoreApi.updateFileMeta(\n    lastFile.info.fileId, \n    core::Buffer::from(\"new public meta\"), \n    lastFile.privateMeta\n);\n// ...\n```\nTo update the data of the particular file you have to use `updateFile(...)` method.\nThis method can also be used to modify metadata (just like `updateFileMeta(...)`), but additionally it creates a file handle allowing for writing data to the file.\n\n```cpp\n// ...\nauto fileNewData {core::Buffer::from(\"some new data\")};\n\nauto updateHandle {storeApi.updateFile(\n    lastFile.info.fileId,\n    lastFile.publicMeta,\n    lastFile.privateMeta,\n    fileNewData.size()\n)};\t\nstoreApi.writeToFile(updateHandle, fileNewData);\nstoreApi.closeFile(updateHandle);\n// ...\n```",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/cpp/files.mdx",
        "type": "mdx",
        "chunkIndex": 4,
        "headers": [
          "Modifying Files"
        ],
        "title": "Modifying Files",
        "codeBlocks": [
          "```cpp\n// ...\nstoreApi.updateFileMeta(\n    lastFile.info.fileId, \n    core::Buffer::from(\"new public meta\"), \n    lastFile.privateMeta\n);\n// ...\n```",
          "```cpp\n// ...\nauto fileNewData {core::Buffer::from(\"some new data\")};\n\nauto updateHandle {storeApi.updateFile(\n    lastFile.info.fileId,\n    lastFile.publicMeta,\n    lastFile.privateMeta,\n    fileNewData.size()\n)};\t\nstoreApi.writeToFile(updateHandle, fileNewData);\nstoreApi.closeFile(updateHandle);\n// ...\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.899Z",
        "size": 926
      }
    },
    {
      "pageContent": "---\ntitle: First app\n---\n\nA step-by-step tutorial that will guide you through creating your first app using PrivMX Endpoint C++ client with PrivMX Bridge.\n\n### PrivMX Bridge\nTo proceed with this tutorial, you should already have your PrivMX Bridge Server up and running. If you don't, you can find step-by-step instructions on [quick start](../start/quick-start) page.",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/cpp/first-app.mdx",
        "type": "mdx",
        "chunkIndex": 0,
        "headers": [
          "PrivMX Bridge"
        ],
        "title": "PrivMX Bridge",
        "lastModified": "2025-06-05T19:33:57.899Z",
        "size": 368
      }
    },
    {
      "pageContent": "## Initial Assumptions\n\nAll the values below like `BRIDGE_URL`, `SOLUTION_ID`, `CONTEXT_ID`\nshould be replaced by the ones corresponding to your PrivMX Bridge instance.\n\nThe private keys here are for demonstration purposes only.\nNormally, they should be kept separately by each user and stored in a safe place,\nor generated from a password (see the `derivePrivateKey()` method in the Crypto API)\n\nThe initial assumptions for all the code examples below are as follows:\n```cpp\nauto BRIDGE_URL {\"http://localhost:9111\"};\nauto SOLUTION_ID {\"YOUR_SOLUTION_ID\"};\nauto CONTEXT_ID {\"YOUR_CONTEXT_ID\"};\n\nauto USER1_ID {\"user_1\"};\nauto USER1_PUBLIC_KEY {\"PUBLIC_KEY_1\"};\nauto USER1_PRIVATE_KEY {\"PRIVATE_KEY_1\"};\n\nauto USER2_ID {\"user_2\"};\nauto USER2_PUBLIC_KEY {\"PUBLIC_KEY_2\"};\n\nauto USER3_ID {\"user_3\"};\nauto USER3_PUBLIC_KEY {\"PUBLIC_KEY_3\"};\n```",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/cpp/first-app.mdx",
        "type": "mdx",
        "chunkIndex": 1,
        "headers": [
          "Initial Assumptions"
        ],
        "title": "Initial Assumptions",
        "codeBlocks": [
          "```cpp\nauto BRIDGE_URL {\"http://localhost:9111\"};\nauto SOLUTION_ID {\"YOUR_SOLUTION_ID\"};\nauto CONTEXT_ID {\"YOUR_CONTEXT_ID\"};\n\nauto USER1_ID {\"user_1\"};\nauto USER1_PUBLIC_KEY {\"PUBLIC_KEY_1\"};\nauto USER1_PRIVATE_KEY {\"PRIVATE_KEY_1\"};\n\nauto USER2_ID {\"user_2\"};\nauto USER2_PUBLIC_KEY {\"PUBLIC_KEY_2\"};\n\nauto USER3_ID {\"user_3\"};\nauto USER3_PUBLIC_KEY {\"PUBLIC_KEY_3\"};\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.899Z",
        "size": 841
      }
    },
    {
      "pageContent": "### Create First Client App\nFirst, you have to create a Conan config file in the root dir of your project:\n\n**`conanfile.txt`**\n```\n[requires]\nprivmx-endpoint/2.3.3\n\n[generators]\nCMakeDeps\nCMakeToolchain\n\n[layout]\ncmake_layout\n```\n\n\nNext, add the PrivMX Endpoint library dependency to your CMakeLists.txt:\n\n**`CMakeLists.txt`**\n```cmake\ncmake_minimum_required(VERSION 3.15)\nproject(test_program)\nset(CMAKE_CXX_STANDARD 17)\n\nfind_package(privmxendpoint REQUIRED)\n\nadd_executable(${PROJECT_NAME} ${CMAKE_CURRENT_SOURCE_DIR}/main.cpp)\ntarget_link_libraries(test_program PUBLIC \n\t\tprivmxendpoint::privmxendpointcore \n\t\tprivmxendpoint::crypto\n)",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/cpp/first-app.mdx",
        "type": "mdx",
        "chunkIndex": 2,
        "headers": [
          "Create First Client App"
        ],
        "title": "Create First Client App",
        "codeBlocks": [
          "```\n[requires]\nprivmx-endpoint/2.3.3\n\n[generators]\nCMakeDeps\nCMakeToolchain\n\n[layout]\ncmake_layout\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.899Z",
        "size": 639
      }
    },
    {
      "pageContent": "```\n\nNow that you have configured the foundation of the application project, you can perform a simple operation using the PriVMX Endpoint library's Crypto API.\nLet's generate a pair of keys for the user.\n\n**`main.cpp`**\n```cpp\n#include <optional>\n#include <iostream>\n#include <privmx/endpoint/crypto/CryptoApi.hpp>\n\nusing namespace privmx::endpoint::crypto;\nint main() {\n   auto cryptoApi {CryptoApi::create()};\n\tauto priv {cryptoApi.generatePrivateKey({})};\n\tauto pub {cryptoApi.derivePublicKey(priv)};\n\tstd::cout << \"Generated private key: \" << priv << std::endl\n\t\t      << \"Generated public key: \" << pub << std::endl;\n\treturn 0;\n}\n```",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/cpp/first-app.mdx",
        "type": "mdx",
        "chunkIndex": 3,
        "codeBlocks": [
          "```\n\nNow that you have configured the foundation of the application project, you can perform a simple operation using the PriVMX Endpoint library's Crypto API.\nLet's generate a pair of keys for the user.\n\n**`main.cpp`**\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.899Z",
        "size": 638
      }
    },
    {
      "pageContent": "### Build Project\n\n```bash\nconan install . --output-folder=build --build=missing\ncd build\ncmake .. -G \"Unix Makefiles\" -DCMAKE_TOOLCHAIN_FILE=build/Release/generators/conan_toolchain.cmake \\\n        -DCMAKE_POLICY_DEFAULT_CMP0091=NEW -DCMAKE_BUILD_TYPE=Release\ncmake --build .\n```\n\n### Run Project\n\n```bash\nsource build/Release/generators/conanrun.sh\n./test_program\n```",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/cpp/first-app.mdx",
        "type": "mdx",
        "chunkIndex": 4,
        "headers": [
          "Build Project",
          "Run Project"
        ],
        "title": "Build Project",
        "codeBlocks": [
          "```bash\nconan install . --output-folder=build --build=missing\ncd build\ncmake .. -G \"Unix Makefiles\" -DCMAKE_TOOLCHAIN_FILE=build/Release/generators/conan_toolchain.cmake \\\n        -DCMAKE_POLICY_DEFAULT_CMP0091=NEW -DCMAKE_BUILD_TYPE=Release\ncmake --build .\n```",
          "```bash\nsource build/Release/generators/conanrun.sh\n./test_program\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.899Z",
        "size": 369
      }
    },
    {
      "pageContent": "---\ntitle: Overview\ndescription: Inboxes are a way for users to send encrypted data to your app.\n---\n\n\n\nThe advantage of Inboxes is that they don't require the user to be registered in order to send encrypted data.\nThis opens up various possibilities in environments where you need to gather sensitive information from unregistered users (e.g. on your website).\n\nTo learn more about Inboxes, their structure, how they are encrypted, and what are their use cases - read [Inbox Docs](../start/inboxes/overview).\n\n:::info\n\nBefore working with Inboxes, follow our [Getting Started Guide](./introduction). It will show you how to set up your project to work with PrivMX Bridge.\n\nSample code on this page is based on the **[initial assumptions](./first-app#initial-assumptions)**.\n\n:::",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/cpp/inboxes.mdx",
        "type": "mdx",
        "chunkIndex": 0,
        "lastModified": "2025-06-05T19:33:57.899Z",
        "size": 779
      }
    },
    {
      "pageContent": "## Working with Inboxes\n\nLet's start with the includes required to use the Inbox API:\n```cpp\n#include <privmx/endpoint/core/Connection.hpp>\n#include <privmx/endpoint/thread/ThreadApi.hpp>\n#include <privmx/endpoint/store/StoreApi.hpp>\n#include <privmx/endpoint/inbox/InboxApi.hpp>\n#include <privmx/endpoint/core/Buffer.hpp>\n```\n\nInboxes can be used in two different contexts/modes:\n1. in the management context - through a logged-in user, such as when we want to create or modify the Inbox,\n2. in the context of sending the Entries to the Inbox - from the public access level.",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/cpp/inboxes.mdx",
        "type": "mdx",
        "chunkIndex": 1,
        "headers": [
          "Working with Inboxes"
        ],
        "title": "Working with Inboxes",
        "codeBlocks": [
          "```cpp\n#include <privmx/endpoint/core/Connection.hpp>\n#include <privmx/endpoint/thread/ThreadApi.hpp>\n#include <privmx/endpoint/store/StoreApi.hpp>\n#include <privmx/endpoint/inbox/InboxApi.hpp>\n#include <privmx/endpoint/core/Buffer.hpp>\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.899Z",
        "size": 575
      }
    },
    {
      "pageContent": "## Working as a Logged-in User\n\nTo start using Inboxes you need to create the instances of the dependent modules: `ThreadApi` and `StoreApi`:\n```cpp\n// ...\n\nauto connection {core::Connection::connect(USER1_PRIVATE_KEY, SOLUTION_ID, BRIDGE_URL)};\nauto threadApi {thread::ThreadApi::create(connection)};\nauto storeApi {store::StoreApi::create(connection)};\nauto inboxApi {inbox::InboxApi::create(connection, threadApi, storeApi)};\n\n// ...\n```",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/cpp/inboxes.mdx",
        "type": "mdx",
        "chunkIndex": 2,
        "headers": [
          "Working as a Logged-in User"
        ],
        "title": "Working as a Logged-in User",
        "codeBlocks": [
          "```cpp\n// ...\n\nauto connection {core::Connection::connect(USER1_PRIVATE_KEY, SOLUTION_ID, BRIDGE_URL)};\nauto threadApi {thread::ThreadApi::create(connection)};\nauto storeApi {store::StoreApi::create(connection)};\nauto inboxApi {inbox::InboxApi::create(connection, threadApi, storeApi)};\n\n// ...\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.899Z",
        "size": 440
      }
    },
    {
      "pageContent": "### Creating an Inbox\n\n\nIn Inboxes, `publicMeta` is exposed as the `InboxPublicView`.\n\nIn short: this is a place where you can store any data that needs to be publicly accessible using `getInboxPublicView(...)`.\nNote that users don't have to be added to the Inbox to have access to this method - they only need Inbox' ID.\n\nPutting data inside `publicMeta` also gives your own server the ability to access it using [PrivMX Bridge API](https://bridge.privmx.dev/).\n\n```cpp\n// ...\n\nstd::vector<core::UserWithPubKey> managers {\n    {.userId = USER1_ID, .pubKey = USER1_PUBLIC_KEY}\n};\n\nstd::vector<core::UserWithPubKey> users {\n    {.userId = USER1_ID, .pubKey = USER1_PUBLIC_KEY},\n    {.userId = USER2_ID, .pubKey = USER2_PUBLIC_KEY}\n};\n\nstd::string privateMeta = R\"({\"name\": \"Album\"})\";\nstd::string publicMeta = R\"(\n    {\n        \"formScheme\": [\n            {\"question\":\"Your name\"},\n            {\"question\":\"E-mail\"}\n        ]\n    }\n)\";\n\n\n// create a new Inbox with access for USER_1 as manager and USER_2 as regular user\nauto inboxId {inboxApi.createInbox(\n    CONTEXT_ID, \n    users, managers, \n    core::Buffer::from(publicMeta), \n    core::Buffer::from(privateMeta),\n    std::nullopt\n)};",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/cpp/inboxes.mdx",
        "type": "mdx",
        "chunkIndex": 3,
        "headers": [
          "Creating an Inbox"
        ],
        "title": "Creating an Inbox",
        "lastModified": "2025-06-05T19:33:57.899Z",
        "size": 1189
      }
    },
    {
      "pageContent": "// auto inboxId {\"68078618c34be32ff95cfd01\"};\nstd::cout << \"InboxId: \" << inboxId << std::endl;\n\n// ...\n```",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/cpp/inboxes.mdx",
        "type": "mdx",
        "chunkIndex": 4,
        "lastModified": "2025-06-05T19:33:57.899Z",
        "size": 107
      }
    },
    {
      "pageContent": "## Fetching Inboxes\n\nGetting a list of Inboxes available for the user in the given Context:\n\n```cpp\n// ...\nauto inboxesList {inboxApi.listInboxes(CONTEXT_ID, defaultListQuery)};\nfor (auto inbox: inboxesList.readItems) {\n    std::cout << \"InboxId: \" << inbox.inboxId << std::endl;\n}\n// ...\n```",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/cpp/inboxes.mdx",
        "type": "mdx",
        "chunkIndex": 5,
        "headers": [
          "Fetching Inboxes"
        ],
        "title": "Fetching Inboxes",
        "codeBlocks": [
          "```cpp\n// ...\nauto inboxesList {inboxApi.listInboxes(CONTEXT_ID, defaultListQuery)};\nfor (auto inbox: inboxesList.readItems) {\n    std::cout << \"InboxId: \" << inbox.inboxId << std::endl;\n}\n// ...\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.899Z",
        "size": 292
      }
    },
    {
      "pageContent": "## Modifying Inboxes\n\n### How Updates Work\nTo update an Inbox you must always provide a full list of parameters.\n\nThe `updateInbox(...)` method needs all the parameters as in the `createInbox(...)` method and a few more. If you want to update\none of the parameters – provide it in a new modified form. If, on the other hand, you want to leave\nthe parameter unchanged – provide it as it was before.\n\n```cpp\n// ...\n\nauto currentInbox {inboxApi.getInbox(inboxId, defaultListQuery)};\n\nstd::vector<core::UserWithPubKey> managers {\n    {.userId = USER1_ID, .pubKey = USER1_PUBLIC_KEY}\n};\n\nstd::vector<core::UserWithPubKey> users {\n    {.userId = USER1_ID, .pubKey = USER1_PUBLIC_KEY}\n};\n\n// update an Inbox with access for USER_1 as the only user.\nauto inboxId {inboxApi.updateInbox(\n    inboxId, \n    users, managers, \n    currentInbox.publicMeta, \n    currentInbox.privateMeta,\n    currentInbox.filesConfig,\n    currentInbox.version, // <- pass the version of the Inbox you will perform the update on\n    false, // <- force update (without checking version)\n    false // <- force to regenerate a key for the Inbox\n)};\n\n// ...\n```",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/cpp/inboxes.mdx",
        "type": "mdx",
        "chunkIndex": 6,
        "headers": [
          "Modifying Inboxes",
          "How Updates Work"
        ],
        "title": "Modifying Inboxes",
        "codeBlocks": [
          "```cpp\n// ...\n\nauto currentInbox {inboxApi.getInbox(inboxId, defaultListQuery)};\n\nstd::vector<core::UserWithPubKey> managers {\n    {.userId = USER1_ID, .pubKey = USER1_PUBLIC_KEY}\n};\n\nstd::vector<core::UserWithPubKey> users {\n    {.userId = USER1_ID, .pubKey = USER1_PUBLIC_KEY}\n};\n\n// update an Inbox with access for USER_1 as the only user.\nauto inboxId {inboxApi.updateInbox(\n    inboxId, \n    users, managers, \n    currentInbox.publicMeta, \n    currentInbox.privateMeta,\n    currentInbox.filesConfig,\n    currentInbox.version, // <- pass the version of the Inbox you will perform the update on\n    false, // <- force update (without checking version)\n    false // <- force to regenerate a key for the Inbox\n)};\n\n// ...\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.899Z",
        "size": 1125
      }
    },
    {
      "pageContent": "---\ntitle: Getting Started \n---\n\n## Initial Requirements\n\nTo start developing end-to-end encrypted applications using PrivMX Endpoint you need a **PrivMX Bridge** instance, you can find quick start guide [here](../start/quick-start).\n\nTo connect it to your environment, you need:\n  - `Bridge URL` - URL address of the instance of your PrivMX Bridge\n  - `Solution ID` - ID of the Solution provided by PrivMX Bridge during its initialization process\n  - `User Private Key` - the private key from the user's public-private key pair\n\nYou also need to use your own application server to manage users (and their keys) and Contexts.\n\n## Using Public and Private Keys\nYou need a private key to connect PrivMX Endpoint to your Bridge. **Private key will never leave PrivMX Endpoint**.\n- PrivMX Endpoint uses the user's private key to encrypt, decrypt and verify data on the client side only.\n- PrivMX Bridge stores only the public part, i.e., the user's public key and user's ID.",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/cpp/introduction.mdx",
        "type": "mdx",
        "chunkIndex": 0,
        "headers": [
          "Initial Requirements",
          "Using Public and Private Keys"
        ],
        "title": "Initial Requirements",
        "lastModified": "2025-06-05T19:33:57.900Z",
        "size": 970
      }
    },
    {
      "pageContent": "## Setting up PrivMX Endpoint Client\n\n### Install and Configure Conan\nTo use PrivMX Endpoint you need to add it to your project using Conan Repository Manager. \n[How to install Conan](https://docs.conan.io/2/installation.html).\n\n#### Setup Conan with our Repository\n```bash\nconan profile detect --force\nconan remote add privmx https://libs.simplito.com/artifactory/api/conan/privmx\n```\n## Next Steps\n\nWith everything ready to go, now it's time to start using all the capabilities of PrivMX Endpoint and PrivMX Bridge.\n\nLearn how to use:\n\n-   [**Threads**](../start/threads/overview) - for exchanging encrypted messages.\n-   [**Stores**](../start/stores/overview) - for saving and sharing encrypted files.\n-   [**Inboxes**](../start/inboxes/overview) - for one way communication with external users.",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/cpp/introduction.mdx",
        "type": "mdx",
        "chunkIndex": 1,
        "headers": [
          "Setting up PrivMX Endpoint Client",
          "Install and Configure Conan",
          "Setup Conan with our Repository",
          "Next Steps"
        ],
        "title": "Setting up PrivMX Endpoint Client",
        "codeBlocks": [
          "```bash\nconan profile detect --force\nconan remote add privmx https://libs.simplito.com/artifactory/api/conan/privmx\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.900Z",
        "size": 798
      }
    },
    {
      "pageContent": "---\ntitle: Messages\ndescription: Sending messages in Threads.\n---\n\n\n:::info\n\nSample code on this page is based on the **[initial assumptions](./first-app#initial-assumptions)**.\n\n:::\n\n## Messages Inside Threads\n\nMessages inside Threads are sent in binary format. Before sending a message, you need to decide on the message format.\n\nFor more information about the Threads architecture and best practices for sending messages, visit the\n[Threads Documentation](../start/threads/overview).\n\n## Sending Messages\n\nSending a simple message to the given Thread:\n\n```cpp\n// ...\n\n// send messages to the Thread represented by its threadId\nthreadApi.sendMessage(\n    threadId, \n    core::Buffer::from(\"some public meta-data\"), \n    core::Buffer::from(\"some private meta-data\"), \n    core::Buffer::from(\"serialized message data\")\n);\n\n// ...\n```",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/cpp/messages.mdx",
        "type": "mdx",
        "chunkIndex": 0,
        "headers": [
          "Messages Inside Threads",
          "Sending Messages"
        ],
        "title": "Messages Inside Threads",
        "codeBlocks": [
          "```cpp\n// ...\n\n// send messages to the Thread represented by its threadId\nthreadApi.sendMessage(\n    threadId, \n    core::Buffer::from(\"some public meta-data\"), \n    core::Buffer::from(\"some private meta-data\"), \n    core::Buffer::from(\"serialized message data\")\n);\n\n// ...\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.900Z",
        "size": 833
      }
    },
    {
      "pageContent": "## Get the Thread's Messages\n\nTo get a list of messages inside a Thread, use `getMessages` method. Because data inside messages is in `core::Buffer`\nyou have to deserialize it to human-readable string.\n**PrivMX Endpoint library takes care of encrypting your data before sending it to PrivMX Bridge.**\n\nReading the messages of the Thread (limited to the 100 newest entries as described by the `defaultListQuery` object):\n\n```cpp\n// ...\n\nauto messages = threadApi.listMessages(threadId, defaultListQuery);\nfor (auto msg: messages.readItems) {\n    std::cout << \"message: \" << msg.data.stdString()\n        << \" / public meta: \" << msg.publicMeta.stdString() \n        << \" / private meta: \" << msg.privateMeta.stdString() \n        << std::endl;\n}\n\n// ...\n```",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/cpp/messages.mdx",
        "type": "mdx",
        "chunkIndex": 1,
        "headers": [
          "Get the Thread's Messages"
        ],
        "title": "Get the Thread's Messages",
        "codeBlocks": [
          "```cpp\n// ...\n\nauto messages = threadApi.listMessages(threadId, defaultListQuery);\nfor (auto msg: messages.readItems) {\n    std::cout << \"message: \" << msg.data.stdString()\n        << \" / public meta: \" << msg.publicMeta.stdString() \n        << \" / private meta: \" << msg.privateMeta.stdString() \n        << std::endl;\n}\n\n// ...\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.900Z",
        "size": 753
      }
    },
    {
      "pageContent": "---\ntitle: Overview\ndescription: Stores provide encrypted block storage, enabling simple file uploading and downloading.\n---\n\n\n\n:::info\n\nBefore working with Stores, follow our [Getting Started Guide](./introduction). It will show you how to set up your project to work with PrivMX Bridge.\n\nSample code on this page is based on the **[initial assumptions](./first-app#initial-assumptions)**.\n\n:::",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/cpp/stores.mdx",
        "type": "mdx",
        "chunkIndex": 0,
        "lastModified": "2025-06-05T19:33:57.900Z",
        "size": 395
      }
    },
    {
      "pageContent": "## Working with Stores\n\nWhen working with Stores, you will use the following:\n- `StoreApi` - provides methods used to manage Stores in given Context\n\n\nLet's modify the program from the [First App](./first-app) chapter to connect to the Bridge server, create a Store, and put the first file in it.\n\n**`CMakeLists.txt`**\n```cmake\n...\ntarget_link_libraries(test_program PUBLIC \n\t\tprivmxendpoint::privmxendpointcore\n        privmxendpoint::privmxendpointstore\n\t\tprivmxendpoint::crypto\n)\n```\n\n**`main.cpp`**\n```cpp\n// setup some defaults\ncore::PagingQuery defaultListQuery = {.skip = 0, .limit = 100, .sortOrder = \"desc\"};\n\n// initialize Endpoint connection and Stores API\nauto connection {core::Connection::connect(USER1_PRIVATE_KEY, SOLUTION_ID, BRIDGE_URL)};\nauto storeApi {store::StoreApi::create(connection)};\n\n// ...\n```",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/cpp/stores.mdx",
        "type": "mdx",
        "chunkIndex": 1,
        "headers": [
          "Working with Stores"
        ],
        "title": "Working with Stores",
        "codeBlocks": [
          "```cmake\n...\ntarget_link_libraries(test_program PUBLIC \n\t\tprivmxendpoint::privmxendpointcore\n        privmxendpoint::privmxendpointstore\n\t\tprivmxendpoint::crypto\n)\n```",
          "```cpp\n// setup some defaults\ncore::PagingQuery defaultListQuery = {.skip = 0, .limit = 100, .sortOrder = \"desc\"};\n\n// initialize Endpoint connection and Stores API\nauto connection {core::Connection::connect(USER1_PRIVATE_KEY, SOLUTION_ID, BRIDGE_URL)};\nauto storeApi {store::StoreApi::create(connection)};\n\n// ...\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.900Z",
        "size": 821
      }
    },
    {
      "pageContent": "## Creating Stores\nCreating a basic, unnamed Store, which can act as an encrypted data container:\n\n```cpp\n// ...\n\nstd::vector<core::UserWithPubKey> managers {\n    {.userId = USER1_ID, .pubKey = USER1_PUBLIC_KEY}\n};\n\nstd::vector<core::UserWithPubKey> users {\n    {.userId = USER1_ID, .pubKey = USER1_PUBLIC_KEY},\n    {.userId = USER2_ID, .pubKey = USER2_PUBLIC_KEY}\n};\n\n// create a new Store with access for USER_1 as manager and USER_2 as regular user\nauto storeId {storeApi.createStore(\n    CONTEXT_ID, \n    users, managers, \n    core::Buffer::from(\"some Store's public meta-data\"), \n    core::Buffer::from(\"some Store's private meta-data\")\n)};\n\n// ...\n```\nHint: You can assign any data to private and public meta fields (e.g. the Store's name), as long as it is serialized and can be given as the `core::Buffer`.",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/cpp/stores.mdx",
        "type": "mdx",
        "chunkIndex": 2,
        "headers": [
          "Creating Stores"
        ],
        "title": "Creating Stores",
        "codeBlocks": [
          "```cpp\n// ...\n\nstd::vector<core::UserWithPubKey> managers {\n    {.userId = USER1_ID, .pubKey = USER1_PUBLIC_KEY}\n};\n\nstd::vector<core::UserWithPubKey> users {\n    {.userId = USER1_ID, .pubKey = USER1_PUBLIC_KEY},\n    {.userId = USER2_ID, .pubKey = USER2_PUBLIC_KEY}\n};\n\n// create a new Store with access for USER_1 as manager and USER_2 as regular user\nauto storeId {storeApi.createStore(\n    CONTEXT_ID, \n    users, managers, \n    core::Buffer::from(\"some Store's public meta-data\"), \n    core::Buffer::from(\"some Store's private meta-data\")\n)};\n\n// ...\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.900Z",
        "size": 814
      }
    },
    {
      "pageContent": "## Fetching Stores\n\nGetting a list of Stores available for the user in the given Context:\n\n```cpp\n// ...\n\nauto storesList = storeApi.listStores(CONTEXT_ID, defaultListQuery);\n\n// ...\n```\n\nAs a result you will receive an object:\n```cpp\n// storesList:\n{\n    readItems: [<storeObject1>, <storeObject2>,..., <storeObjectN>],\n    totalAvailable: <number_of_all_stores>\n}\n```\n\nGetting a single Store:\n\n```cpp\n// ...\n\nauto store = storeApi.getStore(storeId, defaultListQuery);\n\n// ...\n```\nA detailed description of the `Store` object fields can be found in [API Reference](../reference/endpoint/store/types#store).",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/cpp/stores.mdx",
        "type": "mdx",
        "chunkIndex": 3,
        "headers": [
          "Fetching Stores"
        ],
        "title": "Fetching Stores",
        "codeBlocks": [
          "```cpp\n// ...\n\nauto storesList = storeApi.listStores(CONTEXT_ID, defaultListQuery);\n\n// ...\n```",
          "```cpp\n// storesList:\n{\n    readItems: [<storeObject1>, <storeObject2>,..., <storeObjectN>],\n    totalAvailable: <number_of_all_stores>\n}\n```",
          "```cpp\n// ...\n\nauto store = storeApi.getStore(storeId, defaultListQuery);\n\n// ...\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.900Z",
        "size": 607
      }
    },
    {
      "pageContent": "## Modifying Stores\n\n\n### How Updates Work\nTo update a Store, you must always provide a full list of parameters.\n\nThe `updateStore(...)` method needs all the parameters as in the `createStore(...)` method and a few more. If you want to update\none of the parameters – provide it in a new modified form. If, on the other hand, you want to leave\nthe parameter unchanged – provide it as it was before.\n\n```cpp\n// ...\nauto currentStore {storeApi.getStore(storeId)};\n\nstd::vector<core::UserWithPubKey> managers {\n    {.userId = USER1_ID, .pubKey = USER1_PUBLIC_KEY}\n};\n\nstd::vector<core::UserWithPubKey> users {\n    {.userId = USER1_ID, .pubKey = USER1_PUBLIC_KEY}\n};\n\n// update a new Store with access for USER_1 as the only user.\nstoreApi.updateStore(\n    storeId, \n    users, managers, \n    currentStore.publicMeta, \n    currentStore.privateMeta,\n    currentStore.version, // <- pass the version of the Store you will perform the update on\n    false, // <- force update (without checking version)\n    false // <- force to regenerate a key for the Store\n);\n\n// ...\n```",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/cpp/stores.mdx",
        "type": "mdx",
        "chunkIndex": 4,
        "headers": [
          "Modifying Stores",
          "How Updates Work"
        ],
        "title": "Modifying Stores",
        "codeBlocks": [
          "```cpp\n// ...\nauto currentStore {storeApi.getStore(storeId)};\n\nstd::vector<core::UserWithPubKey> managers {\n    {.userId = USER1_ID, .pubKey = USER1_PUBLIC_KEY}\n};\n\nstd::vector<core::UserWithPubKey> users {\n    {.userId = USER1_ID, .pubKey = USER1_PUBLIC_KEY}\n};\n\n// update a new Store with access for USER_1 as the only user.\nstoreApi.updateStore(\n    storeId, \n    users, managers, \n    currentStore.publicMeta, \n    currentStore.privateMeta,\n    currentStore.version, // <- pass the version of the Store you will perform the update on\n    false, // <- force update (without checking version)\n    false // <- force to regenerate a key for the Store\n);\n\n// ...\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.900Z",
        "size": 1064
      }
    },
    {
      "pageContent": "---\ntitle: Overview\ndescription: Threads are a secure way for assigned members to exchange encrypted messages.\n---\n\n\n\n:::info\n\nBefore working with Threads, follow our [Getting Started Guide](./introduction). It will show you how to set up your project to work with PrivMX Bridge.\nSample code on this page is based on the **[initial assumptions](./first-app#initial-assumptions)**.\n\n:::",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/cpp/threads.mdx",
        "type": "mdx",
        "chunkIndex": 0,
        "lastModified": "2025-06-05T19:33:57.901Z",
        "size": 385
      }
    },
    {
      "pageContent": "## Working with Threads\n\nWhen working with Threads, you will use the following:\n- `ThreadApi` - provides methods used to manage Threads in given Context\n\n\nLet's modify the program from the [First App](./first-app) chapter to connect to the Bridge server, create a Thread, and send the first message in it.\n\n**`CMakeLists.txt`**\n```cmake\n...\ntarget_link_libraries(test_program PUBLIC \n\t\tprivmxendpoint::privmxendpointcore\n        privmxendpoint::privmxendpointthread\n\t\tprivmxendpoint::crypto\n)\n```\n\n**`main.cpp`**\n\n```cpp\n// setup some defaults\ncore::PagingQuery defaultListQuery = {.skip = 0, .limit = 100, .sortOrder = \"desc\"};\n\n// initialize Endpoint connection and Threads API\nauto connection {core::Connection::connect(USER1_PRIVATE_KEY, SOLUTION_ID, BRIDGE_URL)};\nauto threadApi {thread::ThreadApi::create(connection)};\n\n// ...\n```",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/cpp/threads.mdx",
        "type": "mdx",
        "chunkIndex": 1,
        "headers": [
          "Working with Threads"
        ],
        "title": "Working with Threads",
        "codeBlocks": [
          "```cmake\n...\ntarget_link_libraries(test_program PUBLIC \n\t\tprivmxendpoint::privmxendpointcore\n        privmxendpoint::privmxendpointthread\n\t\tprivmxendpoint::crypto\n)\n```",
          "```cpp\n// setup some defaults\ncore::PagingQuery defaultListQuery = {.skip = 0, .limit = 100, .sortOrder = \"desc\"};\n\n// initialize Endpoint connection and Threads API\nauto connection {core::Connection::connect(USER1_PRIVATE_KEY, SOLUTION_ID, BRIDGE_URL)};\nauto threadApi {thread::ThreadApi::create(connection)};\n\n// ...\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.901Z",
        "size": 836
      }
    },
    {
      "pageContent": "## Creating Threads\nCreating a basic, unnamed Thread, which can act as an encrypted data container:\n\n```cpp\n// ...\n\nstd::vector<core::UserWithPubKey> managers {\n    {.userId = USER1_ID, .pubKey = USER1_PUBLIC_KEY}\n};\n\nstd::vector<core::UserWithPubKey> users {\n    {.userId = USER1_ID, .pubKey = USER1_PUBLIC_KEY},\n    {.userId = USER2_ID, .pubKey = USER2_PUBLIC_KEY}\n};\n\n// create a new Thread with access for USER_1 as manager and USER_2 as regular user\nauto threadId {threadApi.createThread(\n    CONTEXT_ID, \n    users, managers, \n    core::Buffer::from(\"some thread's public meta-data\"), \n    core::Buffer::from(\"some thread's private meta-data\")\n)};\n\n// ...\n```\nHint: You can assign any data to private and public meta fields (e.g. the Thread's name), as long as it is serialized and can be given as the `core::Buffer`.",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/cpp/threads.mdx",
        "type": "mdx",
        "chunkIndex": 2,
        "headers": [
          "Creating Threads"
        ],
        "title": "Creating Threads",
        "codeBlocks": [
          "```cpp\n// ...\n\nstd::vector<core::UserWithPubKey> managers {\n    {.userId = USER1_ID, .pubKey = USER1_PUBLIC_KEY}\n};\n\nstd::vector<core::UserWithPubKey> users {\n    {.userId = USER1_ID, .pubKey = USER1_PUBLIC_KEY},\n    {.userId = USER2_ID, .pubKey = USER2_PUBLIC_KEY}\n};\n\n// create a new Thread with access for USER_1 as manager and USER_2 as regular user\nauto threadId {threadApi.createThread(\n    CONTEXT_ID, \n    users, managers, \n    core::Buffer::from(\"some thread's public meta-data\"), \n    core::Buffer::from(\"some thread's private meta-data\")\n)};\n\n// ...\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.901Z",
        "size": 823
      }
    },
    {
      "pageContent": "## Fetching Threads\n\nGetting a list of Threads available for the user in the given Context:\n\n```cpp\n// ...\n\nauto threadsList = threadApi.listThreads(CONTEXT_ID, defaultListQuery);\n\n// ...\n```\n\nAs a result you will receive an object:\n```cpp\n// threadsList:\n{\n    readItems: [<threadObject1>, <threadObject2>,..., <threadObjectN>],\n    totalAvailable: <number_of_all_threads>\n}\n```\n\nGetting a single Thread:\n\n```cpp\n// ...\n\nauto thread = threadApi.getThread(threadId, defaultListQuery);\n\n// ...\n```\nA detailed description of the `Thread` object fields can be found in [API Reference](../reference/endpoint/thread/types#thread).",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/cpp/threads.mdx",
        "type": "mdx",
        "chunkIndex": 3,
        "headers": [
          "Fetching Threads"
        ],
        "title": "Fetching Threads",
        "codeBlocks": [
          "```cpp\n// ...\n\nauto threadsList = threadApi.listThreads(CONTEXT_ID, defaultListQuery);\n\n// ...\n```",
          "```cpp\n// threadsList:\n{\n    readItems: [<threadObject1>, <threadObject2>,..., <threadObjectN>],\n    totalAvailable: <number_of_all_threads>\n}\n```",
          "```cpp\n// ...\n\nauto thread = threadApi.getThread(threadId, defaultListQuery);\n\n// ...\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.901Z",
        "size": 625
      }
    },
    {
      "pageContent": "## Modifying Threads\n\n\n### How Updates Work\nTo update a Thread you must always provide a full list of parameters.\n\nThe `updateThread(...)` method needs all the parameters as in the `createThread(...)` method and a few more. If you want to update\none of the parameters – provide it in a new modified form. If, on the other hand, you want to leave\nthe parameter unchanged – provide it as it was before.\n\n```cpp\n// ...\nauto currentThread {threadApi.getThread(threadId, defaultListQuery)};\n\nstd::vector<core::UserWithPubKey> managers {\n    {.userId = USER1_ID, .pubKey = USER1_PUBLIC_KEY}\n};\n\nstd::vector<core::UserWithPubKey> users {\n    {.userId = USER1_ID, .pubKey = USER1_PUBLIC_KEY}\n};\n\n// update a new Thread with access for USER_1 as the only user.\nauto threadId {threadApi.updateThread(\n    threadId, \n    users, managers, \n    currentThread.publicMeta, \n    currentThread.privateMeta,\n    currentThread.version, // <- pass the version of the Thread you will perform the update on\n    false, // <- force update (without checking version)\n    false // <- force to regenerate a key for the Thread\n)};\n\n// ...\n```",
      "metadata": {
        "source": "/home/neriousy/programming/mcp-privmx/spec/mdx/cpp/threads.mdx",
        "type": "mdx",
        "chunkIndex": 4,
        "headers": [
          "Modifying Threads",
          "How Updates Work"
        ],
        "title": "Modifying Threads",
        "codeBlocks": [
          "```cpp\n// ...\nauto currentThread {threadApi.getThread(threadId, defaultListQuery)};\n\nstd::vector<core::UserWithPubKey> managers {\n    {.userId = USER1_ID, .pubKey = USER1_PUBLIC_KEY}\n};\n\nstd::vector<core::UserWithPubKey> users {\n    {.userId = USER1_ID, .pubKey = USER1_PUBLIC_KEY}\n};\n\n// update a new Thread with access for USER_1 as the only user.\nauto threadId {threadApi.updateThread(\n    threadId, \n    users, managers, \n    currentThread.publicMeta, \n    currentThread.privateMeta,\n    currentThread.version, // <- pass the version of the Thread you will perform the update on\n    false, // <- force update (without checking version)\n    false // <- force to regenerate a key for the Thread\n)};\n\n// ...\n```"
        ],
        "lastModified": "2025-06-05T19:33:57.901Z",
        "size": 1114
      }
    }
  ],
  "metadata": {
    "totalDocuments": 673,
    "byType": {
      "mdx": 673
    },
    "byLanguage": {
      "swift": 79,
      "kotlin": 76,
      "js": 145,
      "java": 81,
      "csharp": 9,
      "cpp": 51
    },
    "sources": [
      "/home/neriousy/programming/mcp-privmx/spec/mdx/swift/entries.mdx",
      "/home/neriousy/programming/mcp-privmx/spec/mdx/swift/events.mdx",
      "/home/neriousy/programming/mcp-privmx/spec/mdx/swift/files.mdx",
      "/home/neriousy/programming/mcp-privmx/spec/mdx/swift/getting-started.mdx",
      "/home/neriousy/programming/mcp-privmx/spec/mdx/swift/handling-events.mdx",
      "/home/neriousy/programming/mcp-privmx/spec/mdx/swift/inboxes.mdx",
      "/home/neriousy/programming/mcp-privmx/spec/mdx/swift/index.mdx",
      "/home/neriousy/programming/mcp-privmx/spec/mdx/swift/messages.mdx",
      "/home/neriousy/programming/mcp-privmx/spec/mdx/swift/policy-builders.mdx",
      "/home/neriousy/programming/mcp-privmx/spec/mdx/swift/stores.mdx",
      "/home/neriousy/programming/mcp-privmx/spec/mdx/swift/threads.mdx",
      "/home/neriousy/programming/mcp-privmx/spec/mdx/start/api-reference.mdx",
      "/home/neriousy/programming/mcp-privmx/spec/mdx/start/architecture.mdx",
      "/home/neriousy/programming/mcp-privmx/spec/mdx/start/authorization.mdx",
      "/home/neriousy/programming/mcp-privmx/spec/mdx/start/certificates.mdx",
      "/home/neriousy/programming/mcp-privmx/spec/mdx/start/encryption.mdx",
      "/home/neriousy/programming/mcp-privmx/spec/mdx/start/events.mdx",
      "/home/neriousy/programming/mcp-privmx/spec/mdx/start/features.mdx",
      "/home/neriousy/programming/mcp-privmx/spec/mdx/start/generating-keys.mdx",
      "/home/neriousy/programming/mcp-privmx/spec/mdx/start/index.mdx",
      "/home/neriousy/programming/mcp-privmx/spec/mdx/start/installation.mdx",
      "/home/neriousy/programming/mcp-privmx/spec/mdx/start/managing-users.mdx",
      "/home/neriousy/programming/mcp-privmx/spec/mdx/start/pagination.mdx",
      "/home/neriousy/programming/mcp-privmx/spec/mdx/start/performance.mdx",
      "/home/neriousy/programming/mcp-privmx/spec/mdx/start/privmx-bridge.mdx",
      "/home/neriousy/programming/mcp-privmx/spec/mdx/start/project-map.mdx",
      "/home/neriousy/programming/mcp-privmx/spec/mdx/start/public-private-meta.mdx",
      "/home/neriousy/programming/mcp-privmx/spec/mdx/start/quick-start.mdx",
      "/home/neriousy/programming/mcp-privmx/spec/mdx/start/versioning.mdx",
      "/home/neriousy/programming/mcp-privmx/spec/mdx/start/threads/encryption.mdx",
      "/home/neriousy/programming/mcp-privmx/spec/mdx/start/threads/listening-for-changes.mdx",
      "/home/neriousy/programming/mcp-privmx/spec/mdx/start/threads/managing.mdx",
      "/home/neriousy/programming/mcp-privmx/spec/mdx/start/threads/messages.mdx",
      "/home/neriousy/programming/mcp-privmx/spec/mdx/start/threads/overview.mdx",
      "/home/neriousy/programming/mcp-privmx/spec/mdx/start/stores/downloading-files.mdx",
      "/home/neriousy/programming/mcp-privmx/spec/mdx/start/stores/encryption.mdx",
      "/home/neriousy/programming/mcp-privmx/spec/mdx/start/stores/handling-files.mdx",
      "/home/neriousy/programming/mcp-privmx/spec/mdx/start/stores/instant-updating.mdx",
      "/home/neriousy/programming/mcp-privmx/spec/mdx/start/stores/managing.mdx",
      "/home/neriousy/programming/mcp-privmx/spec/mdx/start/stores/overview.mdx",
      "/home/neriousy/programming/mcp-privmx/spec/mdx/start/stores/uploading-files.mdx",
      "/home/neriousy/programming/mcp-privmx/spec/mdx/start/production/deploy-to-vps.mdx",
      "/home/neriousy/programming/mcp-privmx/spec/mdx/start/inboxes/inbox-entries.mdx",
      "/home/neriousy/programming/mcp-privmx/spec/mdx/start/inboxes/inbox-updates.mdx",
      "/home/neriousy/programming/mcp-privmx/spec/mdx/start/inboxes/overview.mdx",
      "/home/neriousy/programming/mcp-privmx/spec/mdx/start/inboxes/usage.mdx",
      "/home/neriousy/programming/mcp-privmx/spec/mdx/start/guides/managing-keys.mdx",
      "/home/neriousy/programming/mcp-privmx/spec/mdx/start/guides/sms-notifications.mdx",
      "/home/neriousy/programming/mcp-privmx/spec/mdx/start/guides/user-management.mdx",
      "/home/neriousy/programming/mcp-privmx/spec/mdx/start/concepts/acl.mdx",
      "/home/neriousy/programming/mcp-privmx/spec/mdx/start/concepts/metrics.mdx",
      "/home/neriousy/programming/mcp-privmx/spec/mdx/start/concepts/policies.mdx",
      "/home/neriousy/programming/mcp-privmx/spec/mdx/kotlin/downloading-files.mdx",
      "/home/neriousy/programming/mcp-privmx/spec/mdx/kotlin/entries.mdx",
      "/home/neriousy/programming/mcp-privmx/spec/mdx/kotlin/events.mdx",
      "/home/neriousy/programming/mcp-privmx/spec/mdx/kotlin/files.mdx",
      "/home/neriousy/programming/mcp-privmx/spec/mdx/kotlin/getting-started.mdx",
      "/home/neriousy/programming/mcp-privmx/spec/mdx/kotlin/handling-events.mdx",
      "/home/neriousy/programming/mcp-privmx/spec/mdx/kotlin/inboxes.mdx",
      "/home/neriousy/programming/mcp-privmx/spec/mdx/kotlin/introduction.mdx",
      "/home/neriousy/programming/mcp-privmx/spec/mdx/kotlin/messages.mdx",
      "/home/neriousy/programming/mcp-privmx/spec/mdx/kotlin/policy-builders.mdx",
      "/home/neriousy/programming/mcp-privmx/spec/mdx/kotlin/stores.mdx",
      "/home/neriousy/programming/mcp-privmx/spec/mdx/kotlin/threads.mdx",
      "/home/neriousy/programming/mcp-privmx/spec/mdx/js/application-server.mdx",
      "/home/neriousy/programming/mcp-privmx/spec/mdx/js/entries.mdx",
      "/home/neriousy/programming/mcp-privmx/spec/mdx/js/events.mdx",
      "/home/neriousy/programming/mcp-privmx/spec/mdx/js/files.mdx",
      "/home/neriousy/programming/mcp-privmx/spec/mdx/js/first-app.mdx",
      "/home/neriousy/programming/mcp-privmx/spec/mdx/js/handling-events.mdx",
      "/home/neriousy/programming/mcp-privmx/spec/mdx/js/inboxes.mdx",
      "/home/neriousy/programming/mcp-privmx/spec/mdx/js/introduction.mdx",
      "/home/neriousy/programming/mcp-privmx/spec/mdx/js/messages.mdx",
      "/home/neriousy/programming/mcp-privmx/spec/mdx/js/stores.mdx",
      "/home/neriousy/programming/mcp-privmx/spec/mdx/js/threads.mdx",
      "/home/neriousy/programming/mcp-privmx/spec/mdx/js/next/01-introduction.mdx",
      "/home/neriousy/programming/mcp-privmx/spec/mdx/js/next/02-privmx-bridge.mdx",
      "/home/neriousy/programming/mcp-privmx/spec/mdx/js/next/app/03-create-app.mdx",
      "/home/neriousy/programming/mcp-privmx/spec/mdx/js/next/app/04-sign-up.mdx",
      "/home/neriousy/programming/mcp-privmx/spec/mdx/js/next/app/05-sign-in.mdx",
      "/home/neriousy/programming/mcp-privmx/spec/mdx/js/next/app/06-setup-events.mdx",
      "/home/neriousy/programming/mcp-privmx/spec/mdx/js/next/app/07-list-notes.mdx",
      "/home/neriousy/programming/mcp-privmx/spec/mdx/java/downloading-files.mdx",
      "/home/neriousy/programming/mcp-privmx/spec/mdx/java/entries.mdx",
      "/home/neriousy/programming/mcp-privmx/spec/mdx/java/events.mdx",
      "/home/neriousy/programming/mcp-privmx/spec/mdx/java/files.mdx",
      "/home/neriousy/programming/mcp-privmx/spec/mdx/java/getting-started.mdx",
      "/home/neriousy/programming/mcp-privmx/spec/mdx/java/handling-events.mdx",
      "/home/neriousy/programming/mcp-privmx/spec/mdx/java/inboxes.mdx",
      "/home/neriousy/programming/mcp-privmx/spec/mdx/java/introduction.mdx",
      "/home/neriousy/programming/mcp-privmx/spec/mdx/java/messages.mdx",
      "/home/neriousy/programming/mcp-privmx/spec/mdx/java/plugin-configuration.mdx",
      "/home/neriousy/programming/mcp-privmx/spec/mdx/java/policy-builders.mdx",
      "/home/neriousy/programming/mcp-privmx/spec/mdx/java/stores.mdx",
      "/home/neriousy/programming/mcp-privmx/spec/mdx/java/threads.mdx",
      "/home/neriousy/programming/mcp-privmx/spec/mdx/csharp/getting-started.mdx",
      "/home/neriousy/programming/mcp-privmx/spec/mdx/csharp/installation.mdx",
      "/home/neriousy/programming/mcp-privmx/spec/mdx/csharp/introduction.mdx",
      "/home/neriousy/programming/mcp-privmx/spec/mdx/cpp/context-users.mdx",
      "/home/neriousy/programming/mcp-privmx/spec/mdx/cpp/custom-events.mdx",
      "/home/neriousy/programming/mcp-privmx/spec/mdx/cpp/custom-fields-and-queries.mdx",
      "/home/neriousy/programming/mcp-privmx/spec/mdx/cpp/entries.mdx",
      "/home/neriousy/programming/mcp-privmx/spec/mdx/cpp/events.mdx",
      "/home/neriousy/programming/mcp-privmx/spec/mdx/cpp/files.mdx",
      "/home/neriousy/programming/mcp-privmx/spec/mdx/cpp/first-app.mdx",
      "/home/neriousy/programming/mcp-privmx/spec/mdx/cpp/inboxes.mdx",
      "/home/neriousy/programming/mcp-privmx/spec/mdx/cpp/introduction.mdx",
      "/home/neriousy/programming/mcp-privmx/spec/mdx/cpp/messages.mdx",
      "/home/neriousy/programming/mcp-privmx/spec/mdx/cpp/stores.mdx",
      "/home/neriousy/programming/mcp-privmx/spec/mdx/cpp/threads.mdx"
    ]
  }
}